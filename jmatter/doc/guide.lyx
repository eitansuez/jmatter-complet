#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

The 
\emph on 
JMatter
\emph default 
 Framework
\layout Author

Eitan Suez
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter

Overview
\layout Standard

Welcome! 
\emph on 
JMatter
\emph default 
 is a software application framework.
 It is designed specifically for building business software applications
 for work groups.
 Examples might include accounting software, software for legal firms, medical
 software for small practices, software for auto mechanic shops, software
 for small software development shops, and more
\begin_inset Foot
collapsed true

\layout Standard

By 
\emph on 
small
\emph default 
 we mean organizations with up to 100 users.
\end_inset 

.
\layout Standard

The principal advantage of developing a business software application with
 JMatter is a dramatic reduction in development time.
 It is not an exaggeration to say that the difference in development time
 compared to traditional methods is roughly a factor of 10! That is, one
 order of magnitude.
\layout Standard

Take for example, the Issue Manager demo application described in chapter
 
\begin_inset LatexCommand \ref{cha:Issue-Manager}

\end_inset 

.
 Surprisingly, even though this application is presented as a 
\begin_inset Quotes eld
\end_inset 

demo
\begin_inset Quotes erd
\end_inset 

, it nevertheless is a complete and working Issue Management software applicatio
n that can be used for day-to-day tracking and management of software issues.
 The authors of the JMatter framework actually use this application for
 tracking bugs and enhancements to JMatter.
\layout Standard

This Issue Manager software application was implemented by a single developer
 in roughly four hours.
 Contrast this to comparable systems such as 
\begin_inset LatexCommand \htmlurl[Bugzilla]{http://www.bugzilla.org/}

\end_inset 

, 
\begin_inset LatexCommand \htmlurl[JIRA]{http://jira.atlassian.com/}

\end_inset 

, and 
\begin_inset LatexCommand \htmlurl[trac]{http://www.edgewall.com/trac}

\end_inset 

 which, albeit may have a few more features, have taken somewhere in the
 neighborhood of one or more man-years to develop.
\layout Standard

Equally important is the number of lines of code necessary to implement
 such a software application.
 Using JMatter, the entire Issue Manager application consists of 300 lines
 of code at the moment, including white-space (blank lines), strewn across
 
\emph on 
three
\emph default 
 Java classes.
 Compare that to approximately 13,000 lines of python code
\begin_inset Foot
collapsed true

\layout Standard

Measured using 
\emph on 
wc -l
\emph default 
 on 
\emph on 
python-2.4/site-packages/trac
\end_inset 

 in 
\emph on 
trac
\emph default 
 spread among roughly 170 files (I don't mean to pick on trac, which is
 a very nice issue management application; I just happen to have a copy
 installed on my computer).
\layout Standard

This brings up another point: the JMatter framework is written in the Java
 programming language.
 This means that your software applications can run in a heterogeneous IT
 environment, including computers running the Linux, MacOS, Solaris, and
 Windows Operating Systems
\begin_inset Foot
collapsed true

\layout Standard

This includes both the client and server portions of the solution.
\end_inset 

.
\layout Standard

Software development professionals or teams that use the JMatter framework
 therefore enjoy a significant competitive advantage over other software
 development firms that employ more traditional methods of developing software.
\layout Standard

At this point you should be asking yourself some very important questions:
 
\emph on 
Can this really be? How? Is it really possible to shave 90% or more of an
 application's code? To deliver software in so much less time? 
\emph default 
Read on to find out more.
\layout Section

How?
\layout Standard

Let's take a moment and reflect a little on how software applications are
 constructed.
 The reason for developers' high productivity with JMatter is simple, but
 needs a little elaboration.
\layout Standard

All applications have a great deal in common.
 Examples include, a login dialog, the need for authentication (controlling
 who can and cannot access the system), etc\SpecialChar \ldots{}

\layout Standard

Believe it or not though, most developers build these same features over
 and over again each time they work on a new application.
 With JMatter, things are different.
 JMatter provides those common things so that developers don't have to start
 from scratch each time.
 You won't find a single line of authentication code in a software application
 constructed using JMatter; that's all tucked away in the framework.
\layout Standard

If it were all about login dialogs, JMatter wouldn't buy you very much.
 What sets JMatter apart is the fact that there are plenty more things that
 developers write from scratch for each new application; things that are
 common to them all.
 Here are some of them:
\layout Description

A\SpecialChar ~
User\SpecialChar ~
Interface
\begin_deeper 
\layout Standard

A window, the ability to create new users, change their passwords, the ability
 to create a new contact, edit the address for an existing contact, delete
 an old contact.
 The basic need to Create, view (Read), Update, and Delete information is
 termed 
\emph on 
CRUD
\emph default 
.
 It's true that for each type of thing you're creating (a User, a Business,
 a Person, etc..), the forms will vary because each thing contains a different
 set of fields.
 However, the mechanism is the same.
 Developing a user interface from scratch is a very tedious job.
 Estimates state that approximately 60% of the time spent developing an
 application is spent constructing its user interface;
\end_deeper 
\layout Description

Query\SpecialChar ~
Services
\begin_deeper 
\layout Standard

The basic need to filter information.
 For example, the ability to ask the question: 
\emph on 
Display all Persons who live in a certain city;
\end_deeper 
\layout Description

Validation 
\begin_deeper 
\layout Standard

The ability to specify which fields are required, which are optional, what
 constitutes a valid phone number, date, etc..
 when performing form entry tasks;
\end_deeper 
\layout Description

Persistence
\begin_deeper 
\layout Standard

The ability to save information, associations between objects, and more;
\end_deeper 
\layout Description

Calendaring
\begin_deeper 
\layout Standard

Many varying applications have the basic need to deal with time: scheduling
 activities, looking up a calendar, etc..
\end_deeper 
\layout Description

Basic\SpecialChar ~
knowledge\SpecialChar ~
of\SpecialChar ~
simple\SpecialChar ~
types\SpecialChar ~
of\SpecialChar ~
information
\begin_deeper 
\layout Standard

So many business applications need to process dates, phone numbers, social
 security numbers, images, passwords, percentages, currencies, names, addresses,
 notes, and more.
 Yet here again, you will discover sofware developers spending time [re-]writing
 code to parse, validate, and format such basic information as a phone number;
\end_deeper 
\layout Description

Logging
\begin_deeper 
\layout Standard

Tracking activity in the system, the fact that someone logged in at a specific
 time, that they deleted an entry, etc..
\end_deeper 
\layout Description

Authorization
\begin_deeper 
\layout Standard

Specifying who is allowed to perform what actions in a system;
\end_deeper 
\layout Description

Reporting
\begin_deeper 
\layout Standard

The ability to produce printable (PDF) reports from the information that
 an application manages.
\end_deeper 
\layout Description

Wizards
\begin_deeper 
\layout Standard

A component of user interface construction, often used to break down complex
 tasks into a series of steps
\end_deeper 
\layout Standard

Most of this work has nothing to do with the specific problem domain: they're
 generic services that all applications should have, but that [unfortunately]
 are constructed from scratch each time
\begin_inset Foot
collapsed true

\layout Standard

or not! It's rare to find a complete application that provides all of these
 services.
\end_inset 

.
 I like to say that these services are 
\emph on 
orthogonal
\emph default 
 to the problem domain.
\layout Standard

We can see now why software projects are often delivered late and over budget:
 developers have a great deal of work to perform when building even the
 most basic of business applications.
 Before they have a chance to begin working on the problem domain, they're
 faced with building an entire software infrastructure.
 The end-result is often a combination of:
\layout Itemize

a poorly-constructed general foundation for an application that is tightly
 and needlessly coupled to the problem domain
\layout Itemize

a solution that compromises the end-user's feature requirements to stay
 within time and cost constraints
\layout Standard

JMatter promises to empower developers to work on the task at hand without
 having to worry about all these other things.
 At the time of this writing, JMatter provides most of the listed orthogonal
 services.
 Authorization implementation is well on its way, though not yet complete.
 Reporting has not yet been implemented.
\layout Standard

So to sum things up for now, the JMatter framework's goal is to provide
 all of these orthogonal services, 
\emph on 
out of the box
\emph default 
, so to speak without requiring 
\emph on 
any
\emph default 
 extra effort on the part of the application developer.
\layout Section

Seeing is believing
\layout Standard

Here's what lays ahead in the upcoming chapters: we'll walk through installing
 JMatter on your system.
 Then we'll begin by studying one of the JMatter demo applications: the
 
\emph on 
Contact Manager
\emph default 
 (Chapter 
\begin_inset LatexCommand \ref{cha:A-Short-Tour}

\end_inset 

).
 By the end of that chapter, you'll have a good feel for JMatter applications,
 what they look like, how to interact with them.
\layout Standard

Next, we're going to delve into writing JMatter applications.
 We'll start by building our own contact management software.
 In each succeeding chapter we'll build a new application, each one building
 upon the notions learned in the preceding chapters.
\layout Standard

Bold claims have been made in this introduction.
 Coming from the authors of the JMatter framework, these should be regarded
 with a healthy dose of skepticism.
 It is for you, the reader, to judge the cost-benefit proposition of the
 JMatter framework for delivering software applications.
 What I hope to do in this document is to arm you with the information you
 need to make an informed decision.
\layout Chapter

Installation
\layout Comment

Not complete.
 Following are general installation instructions.
 Details to be inserted.
\layout Standard

The following instructions assume that you've downloaded the JMatter framework
 zip file from our 
\begin_inset LatexCommand \htmlurl[web site]{http://www.u2d.com/}

\end_inset 

.
 These instructions are designed for software developers; an understanding
 of the 
\emph on 
command line
\emph default 
 (DOS or Unix) is assumed.
\layout Section

Prerequisites
\layout Subsection

Java Standard Edition, version 5 (JSE 5)
\layout Standard

JMatter is a Java-based framework and thus requires Java Standard Edition
 from Sun Microsystems.
 Download a copy from 
\begin_inset LatexCommand \htmlurl{http://java.sun.com}

\end_inset 

.
\layout Subsection

Ant
\layout Standard

Ant is a Java build tool which JMatter heavily relies upon.
 You can obtain 
\emph on 
ant
\emph default 
 from 
\begin_inset LatexCommand \htmlurl{http://ant.apache.org/}

\end_inset 

.
\layout Standard

After instlalling 
\emph on 
ant
\emph default 
, verify that it is properly installed by typing:
\layout LyX-Code

ant -version
\layout Standard

at the command prompt.
 Here is what the output of the above command looks like on my screen:
\layout LyX-Code

Apache Ant version 1.6.5 compiled on September 14 2005
\layout Subsection

A Relational Database Management System
\layout Standard

The JMatter framework taps the power of database systems.
 JMatter employs the excellent 
\emph on 
Hibernate
\emph default 
 
\begin_inset Quotes eld
\end_inset 

O/R Mapping
\begin_inset Quotes erd
\end_inset 

 framework which affords JMatter database independence.
 That is, you're not constrained to using a specific database system.
 Options include PostgresQL, MySQL, Oracle, DB2, Sybase, Informix, SAP DB,
 and many more.
 We recommend PostgresQL, a mature, stable and open source database.
 In this document, I'll be using PostgresQL.
\layout Standard

To get started however, you don't need to do anything.
 JMatter comes bundled with a lightweight Java database: 
\begin_inset LatexCommand \url[hsqldb]{http://hsqldb.org/}

\end_inset 

.
 So if setting up a database is too much trouble, you can skip this step
 entirely.
\layout Standard

The jMatter distribution also pre-bundles jdbc drivers for PostgreSQL, MySQL,
 and hsqldb.
 If you choose to use a different database vendor, you will also need to
 obtain the corresponding JDBC driver jar file.
\layout Section

Unzip the file to your hard disk
\layout LyX-Code

unzip jmatter.zip
\layout Standard

You should now have a folder named 
\emph on 
jmatter
\emph default 
.
\layout Standard

If applicable, place a copy of the JDBC driver 
\emph on 
.jar file
\emph default 
 for your database in JMatter's 
\emph on 
lib/src
\emph default 
 subdirectory.
\layout Standard

That's it.
\layout Chapter

A Short Tour
\begin_inset LatexCommand \label{cha:A-Short-Tour}

\end_inset 


\layout Standard

Let's take a first look at a software application developed using JMatter.
 We're going to setup and launch, and then study the 
\emph on 
Contact Manager
\emph default 
 demo application that is bundled with JMatter.
 You will find it in a folder named 
\emph on 
ContactMgr
\emph default 
 inside the 
\emph on 
demo-apps
\emph default 
 directory.
\layout Section

Setup
\layout Standard

Here are the steps we need to follow before we can launch the 
\emph on 
Contact Manager
\emph default 
:
\layout Enumerate

Create a database where the Contact Manager information will reside
\layout Enumerate

Specify the database connection information in a text file
\layout Enumerate

Generate the database schema
\layout Subsection

Create a Database
\begin_inset LatexCommand \label{sub:Create-a-Database}

\end_inset 


\layout Standard

To create a database in PostgresQL, invoke a command similar to this one:
\layout LyX-Code

createdb -U postgres contactmgr
\layout Standard

The -U flag is used to specify the name of the user who is creating the
 database.
 The username you should use depends on your specific installation (consult
 the PostgresQL documentation).
\layout Standard

You might also want to create a user specifically for this application
\begin_inset Foot
collapsed true

\layout Standard

Both 
\emph on 
createdb
\emph default 
 and 
\emph on 
createuser
\emph default 
 are programs that come with PostgresQL
\end_inset 

:
\layout LyX-Code

createuser -U postgres contactmgr
\layout Subsection

Specify the Database Connection Information
\begin_inset LatexCommand \label{sub:Specify-DB-ConnInfo}

\end_inset 


\layout Standard

Make sure that you're in the 
\emph on 
ContactMgr
\emph default 
 folder before proceeding.
 Edit the file 
\emph on 
hibernate.properties
\emph default 
 located in the 
\emph on 
resources
\emph default 
 directory.
 Modify these three lines accordingly
\begin_inset Foot
collapsed true

\layout Standard

Let's assume for now that the database will reside on the same machine as
 your application.
 
\end_inset 

:
\layout LyX-Code

#
\layout LyX-Code

hibernate.connection.url=jdbc:postgresql://localhost/contactmgr
\layout LyX-Code

hibernate.connection.username=contactmgr
\layout LyX-Code

hibernate.connection.password=
\layout Standard

If you're using a database other than PostgresQL, you'll also need to revise
 these two lines:
\layout LyX-Code

#
\layout LyX-Code

hibernate.connection.driver_class=org.postgresql.Driver
\layout LyX-Code

hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
\layout Standard

Save the file.
\layout Subsection

Generate the Database Schema
\layout Standard

From the 
\emph on 
ContactMgr
\emph default 
 base directory, invoke this command:
\layout LyX-Code

ant schema-export
\layout Section

The Tour
\layout Standard

OK, we should now be all set to launch the application.
 Type:
\layout LyX-Code

ant run
\layout Standard

You should be greeted with the login screen shown in figure 
\begin_inset LatexCommand \ref{cap:Contact-Manager-Login}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CM-1.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Contact-Manager-Login}

\end_inset 

Contact Manager Login Screen
\end_inset 


\layout Standard

When an application is first created, a single user will exist in the system.
 The user name and password values are 
\emph on 
admin
\emph default 
.
 Later on, we'll show you how to change the admin password.
\layout Standard

Go ahead and login.
 You are now presented to your application's 
\emph on 
desktop
\emph default 
 (see figure 
\begin_inset LatexCommand \ref{cap:Contact-Manager-Desktop}

\end_inset 

).
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CM-2.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Contact-Manager-Desktop}

\end_inset 

Contact Manager Application Desktop
\end_inset 


\layout Standard

On the left hand side you see a toolbar.
 This toolbar is a little different from most application toolbars.
 Instead of containing various actions (such as 
\emph on 
copy
\emph default 
, 
\emph on 
paste
\emph default 
, and others typically found in a word processing application, for example),
 this toolbar contains types of things: Persons, Businesses, Users, Folders,
 etc..
 I'm going to call this toolbar the 
\emph on 
Class Bar
\emph default 
 from here on if you don't mind.
\layout Standard

To perform actions on these things, you 
\emph on 
right-click
\emph default 
 on the thing in question
\begin_inset Foot
collapsed false

\layout Standard

The mechanism of first selecting an object, and then selecting an action
 is known as a noun-verb user interface metaphor.
 It turns out that we naturally tend to think in similar terms in real life
 as well.
 That is, most of the time, we first identify an object and then decide
 what action to perform relative to that object.
 For example, we might see a ball, and then decide to kick it.
 Unfortunately many applications' user interfaces today don't abide by this
 metaphor.
 Typical applications' toolbars contain actions and it's not entirely clear
 what objects they relate to.
 When working with menus, you'll pick an action first and an object second
 (think about how we usually open files in software applications: we pick
 the open action first and select the file second).
\end_inset 

.
 So for example, to browse the list of users defined in the system, you
 can move your mouse to the 
\emph on 
Users
\emph default 
 icon, right-click on it and a menu of actions will appear.
 One of these actions is the 
\emph on 
Browse
\emph default 
 action.
 Go ahead and browse 
\emph on 
Users
\emph default 
.
 You should see something similar to figure 
\begin_inset LatexCommand \ref{cap:Users}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CM-3.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Users}

\end_inset 

Users
\end_inset 


\layout Standard

I promised I'd show you how to change the 
\emph on 
admin
\emph default 
 user's password.
 Let's do this now:
\layout Enumerate

Right-click on the 
\emph on 
admin
\emph default 
 user in the list
\layout Enumerate

Select the action 
\emph on 
Change Password
\layout Enumerate

You will be presented with a dialog and prompted to enter the new password
 (twice, to guard against typos)
\layout Standard

There.
 You're done.
 The next time you log in to the application, you'll have to enter the new
 password.
 Passwords are stored in the database as hashes and so are not vulnerable
 to prying eyes.
\layout Standard

Close the window containing the listing of users for now.
 Let's go ahead and add a person to our contact manager.
 You've probably already guessed how to do it: right-click on the 
\emph on 
Persons
\emph default 
 icon in the 
\emph on 
Class Bar
\emph default 
.
 Sure enough there's an action on its context menu called 
\emph on 
New
\emph default 
.
 That's the one.
\layout Standard

Your screen should now look like figure 
\begin_inset LatexCommand \ref{cap:New-Person}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CM-4.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:New-Person}

\end_inset 

Creating a new Person
\end_inset 


\layout Standard

Go ahead and complete the form.
 Note that there are two tabs' worth of information to enter: the person's
 name 
\emph on 
and
\emph default 
 their contact information.
 Furthermore, the second tab contains a collapsible element: the address
 portion of the contact information can be expanded to reveal the address
 fields (street, city, state, zip, etc..).
 After you've finished entering the information, go ahead and click the
 
\emph on 
Save
\emph default 
 button.
 Your view of the information you just entered will change to a read-only
 mode.
 To edit the information further, click the 
\emph on 
Edit
\emph default 
 button.
 Don't worry if you closed the window.
 Your information has been saved and you can retrieve this new person's
 information at any time.
 Note that other users logged in to the system can also view the contact
 information for this new person.
\layout Standard

Right-click 
\emph on 
Browse
\emph default 
 on 
\emph on 
Persons
\emph default 
 to view a listing of all the persons in your system.
 If you have a system with 300 persons in them, JMatter will make sure to
 page the listing 15 entries at a time
\begin_inset Foot
collapsed true

\layout Standard

The page size can be customized.
\end_inset 

.
 Also, notice that if you modify the 
\emph on 
Preferred Contact Method
\emph default 
 for a person from, say, 
\emph on 
Home Phone
\emph default 
 to 
\emph on 
Email
\emph default 
, then when you're viewing that person in a minimized context (say browsing
 through a list of persons), the title for that person will automatically
 change.
 In the former case, it might say 
\emph on 
Joe Burns, (512) 333-444
\emph default 
 and in the latter case it will change to 
\emph on 
Joe Burns, jb@yahoo.com
\emph default 
.
\layout Standard

You can also create objects of type 
\emph on 
Business
\emph default 
, for example, if you need to keep track of contact information for various
 businesses that you interact with.
 The mechanism for performing 
\emph on 
CRUD
\begin_inset Foot
collapsed true

\layout Standard

CRUD: Create, Read, Update, Delete
\end_inset 


\emph default 
 operations on any type (Person, Business, User, etc..) is the same.
\layout Standard

Lastly, notice that you can delete persons, though we want to prevent the
 possibility of accidental deletion of important information.
 JMatter does this by protecting the 
\emph on 
Delete
\emph default 
 action with a lock.
 Just click on the lock first to unlock the action and then click on the
 button to perform the deletion.
\layout Subsection

Folders
\layout Standard

Notice the 
\emph on 
Folders
\emph default 
 icon in the Class Bar.
 Right-click the 
\emph on 
New with name
\emph default 
 action, and specify a name for the new folder you're creating.
 Let's say that you want to keep track of important contacts, in which case
 you might want to name the folder 
\emph on 
Important Contacts
\emph default 
.
 After entering the folder name, click 
\emph on 
OK
\emph default 
.
 The folder is created and displayed on the screen.
\layout Standard

From a listing of Persons, you can simply drag and drop an entry onto the
 folder to add that person.
 You can put pretty much anything you want in a folder.
 The concept is completely analogous to the notion of folders on Operating
 System desktops.
 The difference of course is that you are not putting folders and files
 into a folder, but any type of object that is defined by the application,
 including Folders, Persons, Businesses, Queries, and more.
\layout Standard

Drag and Drop is only one mechanism to add items to a folder.
 I'll be showing you other ways of doing the same thing later on.
\layout Subsection

Queries
\layout Standard

Assume you have plenty of contacts in your contact management system.
 This is not a problem of course since the application is backed by a database
 management system, designed to hold thousands of records, gigabytes of
 information.
 The primary advantage of a database of course is its ability to mine informatio
n.
\layout Standard

I'd like to look up all members of the Suez family in my contact manager.
 Here's one way to do this using JMatter: right-click on 
\emph on 
Persons
\emph default 
 in the 
\emph on 
Class Bar
\emph default 
 and pick the corresponding action, which this time will be 
\emph on 
Find
\emph default 

\begin_inset Foot
collapsed true

\layout Standard

You should begin to get a little tired of hearing this by now :-)
\end_inset 

.
\layout Standard


\emph on 
Aside
\emph default 
: this metaphor of invoking actions on things should be familiar to anyone
 who's done object-oriented software development: you're simply sending
 messages to objects.
 So in this case there is an object that represents the Person type, which
 defines (actually inherits) the ability to receive and act upon the message
 
\emph on 
Find
\emph default 
.
\layout Standard

When invoking 
\emph on 
Find
\emph default 
 on 
\emph on 
Person
\emph default 
s, a window will appear containing a way for us to specify a query.
 This one will be fairly easy:
\layout Enumerate

From the pull-down menu on the left, select 
\emph on 
Person Name's Last; 
\layout Enumerate

From the second pull-down menu, select the appropriate comparison operation;
 in this case it does not really matter, let's pick 
\emph on 
contains
\layout Enumerate

In the text field on the right hand side, enter 
\emph on 
Suez
\emph default 
 (or whatever last name you're searching for);
\layout Enumerate

Finally go ahead and click on the 
\emph on 
Find
\emph default 
 button to perform the query.
\layout Standard

The search results will appear in the listing below the query you just performed.
\layout Standard

Let's take this example one step further: click on 
\emph on 
Save Query.

\emph default 
 At this point your screen should look something similar to figure 
\begin_inset LatexCommand \ref{cap:Query-1}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CM-5.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Query-1}

\end_inset 

Performing and Saving a Query
\end_inset 


\layout Standard

Give your query a name (I called it 
\emph on 
The Suez's)
\emph default 
 and click 
\emph on 
Save
\emph default 
.
 We've just defined and executed a query, then named it and finally saved
 it.
\layout Standard

It turns out that in JMatter, a query is nothing more than yet another type
 of thing, like a Person or a Business.
 That's why there exists an entry in the Class Bar called queries.
 Go ahead and browse queries (right-click 
\emph on 
Browse
\emph default 
 on 
\emph on 
Queries
\emph default 
 in the Class Bar) and you'll see your new query show up in the list (see
 figure 
\begin_inset LatexCommand \ref{cap:Browsing-Queries}

\end_inset 

).
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CM-6.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Browsing-Queries}

\end_inset 

Browsing Queries
\end_inset 


\layout Standard

If you like, you can even query queries.
 This may sound far-fetched but after a while, after you've defined lots
 of queries, the ability to search for a query (by name) might come in handy.
\layout Standard

Now that your query is defined and saved, you can execute it at any time.
 You guessed it, just right-click the 
\emph on 
Execute
\emph default 
 action on any query listed and you'll get the search results.
 If another matching entry is entered into the system after a query is created,
 the search results will include the new entry as well, of course.
 JMatter calls this feature a 
\emph on 
Smart List
\emph default 
.
\layout Standard

Finally, since the query we just saved was a query on Persons, JMatter went
 ahead and established an association between the Persons 
\emph on 
type
\emph default 
 and this new query.
 It took the liberty to add a new action to the 
\emph on 
Persons
\emph default 
 context menu.
 That is, you can now right-click 
\emph on 
The Suez's
\emph default 
 on 
\emph on 
Persons
\emph default 
.
\layout Subsubsection

Quick Recap
\layout Standard

I know we haven't yet reached the chapter about actually writing applications
 in JMatter.
 Still, it's important to note even at this early stage that the query facilitie
s baked into this application are provided by the framework.
 You will not find a single line of code in the Contact Manager application
 to support these capabilities.
\layout Standard

Something should be 
\emph on 
clicking
\emph default 
 at this point.
 Attempt to quantify how many lines of code exist in a 
\begin_inset Quotes eld
\end_inset 

traditional
\begin_inset Quotes erd
\end_inset 

 software application to support searches; specifially for a type of application
 such as an issue manager.
 Issue managers are all about entering and updating and searching issues.
 Since entering and updating and searching things is built-in in JMatter,
 then very little work actually remains: the need to define that there exists
 such as thing as an issue.
 That's about it.
\layout Standard

Also, notice how both developers and end users are empowered by this model
 of building applications:
\layout Enumerate

end users do not have to go to a developer in order to define a new query
 in the system, they can do it themselves
\layout Enumerate

developers' time is freed to work on higher business-value tasks
\layout Subsection

Logs
\layout Standard

To really drive the notion that all kinds of objects can play in the JMatter
 
\emph on 
sandbox,
\emph default 
 so to speak, have a look at the type called 
\emph on 
Log
\emph default 
 in the Class Bar.
 Browse the list of log entries and you'll see a screen that looks like
 figure 
\begin_inset LatexCommand \ref{cap:Log-Listing}

\end_inset 

.
\layout Comment

Consider revising Log title to include User (who) property and rebuild screensho
t, so it shows 
\begin_inset Quotes eld
\end_inset 

admin
\begin_inset Quotes erd
\end_inset 

 logged in, 
\begin_inset Quotes eld
\end_inset 

eitan
\begin_inset Quotes erd
\end_inset 

 logged out, etc..
 Same goes for 
\begin_inset Quotes eld
\end_inset 

Object
\begin_inset Quotes erd
\end_inset 

 updated, which becomes 
\begin_inset Quotes eld
\end_inset 

Eitan Suez
\begin_inset Quotes erd
\end_inset 

 updated.
 Lastly, finish implementing delete as a move to the deleted table rather
 than a real delete to prevent integrity constraint issues in the db when
 an object cannot be deleted because another object still references it.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CM-7.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Log-Listing}

\end_inset 

Log Listing
\end_inset 


\layout Standard

What we discover is that the framework keeps track of specific events such
 as when a user logs in or out of the system or when a specific piece of
 information is created or updated
\begin_inset Foot
collapsed true

\layout Standard

It's fairly trivial for an application to tap into this log system to log
 additional activities.
\end_inset 

.
 The system creates a log entry: a message, possibly a longer description
 of the event that took place, who performed the specific action, and what
 object this action was performed on.
 Since log objects are proper JMatter objects (like 
\emph on 
Person
\emph default 
 and 
\emph on 
Business
\emph default 
) they inherit the same benefits: the ability to search through logs, to
 view and even edit logs (though technically that last bit should be forbidden,
 and can be made so
\begin_inset Foot
collapsed true

\layout Standard

We'll talk about authorization and other mechanisms to make information
 read-only in ?[to be decided]
\end_inset 

).
 You can also see in figure 
\begin_inset LatexCommand \ref{cap:Log-Listing}

\end_inset 

 that the listing is currently showing you the first of two pages of logs,
 with a page navigation arrow at the bottom.
\layout Subsection

Multiple Views
\layout Standard

Before we end our tour, there's one last major aspect of the user interface
 that we need to discuss: the notion of multiple views.
\layout Standard

You might have noticed four little icons on the top right-hand-side of listings
 windows.
 Bring up a listing of persons (right-click 
\emph on 
Browse
\emph default 
 on 
\emph on 
Person
\emph default 
s) and click on the icon with the yellow star in it.
 You should see something similar to figure 
\begin_inset LatexCommand \ref{cap:Icon-Alternate-View}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CM-8.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Icon-Alternate-View}

\end_inset 

Icon Alternate List View
\end_inset 


\layout Standard

The user interface for the Contact Manager application basically provides
 multiple alternative ways of viewing information.
 You can view a listing of Persons (or Queries or Logs) as a simple listing
 or as a list of Icons, or as a table, with the Person's fields (name, contact
 information) laid out in separate columns, or as a composite view: a listing
 on the left-hand-side combined with a form view of the currently selected
 item on the right hand side.
 This notion of multiple views should feel familiar, as it's akin to the
 way file managers on our desktops behave: we can view a listing of files
 and directories in 
\emph on 
detail
\emph default 
 view or 
\emph on 
iconized
\emph default 
 view and so on.
\layout Standard

For single objects, say a single contact, you will likewise find alternate
 views.
 You can use a tree view for a contact where the tree is arranged in such
 a way that associations between objects can be traversed.
 So for example, we can lookup a log entry about someone logging in to the
 system and view that entry in a composite tree view, as shown in figure
 
\begin_inset LatexCommand \ref{cap:Composite-Tree-View}

\end_inset 

.
 By expanding the tree nodes we can discover some of the associations between
 log objects and other objects.
 In this case, the person who logged in was the administrator.
 We also discover that users can be assigned to roles.
 The admin user belongs to the Administrators role, which in turn also keeps
 a list of all the users in the system that have the same role.
 Finally we see that roles maintain lists of field and command restriction
 objects.
 It is by adding such restrictions to roles that we can begin to specify
 an authorization policy for our system: who is allowed to view what fields,
 who is allowed to invoke what actions, etc..
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CM-8b.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Composite-Tree-View}

\end_inset 

Composite Tree View for a Log Object
\end_inset 


\layout Standard

So this composite tree view is actually a wonderful way to explore and quickly
 learn the way information is modeled in a system, the various associations
 between types of objects, and how to traverse them.
 In chapters 
\begin_inset LatexCommand \ref{cha:MyTunes-Under-200}

\end_inset 

 and 
\begin_inset LatexCommand \ref{cha:A-Conference-Manager}

\end_inset 

 we'll have a chance to explore such relationships.
\layout Subsubsection

Custom Views
\begin_inset LatexCommand \label{sub:Custom-Views}

\end_inset 


\layout Standard

Going back to the notion that we can have multiple different and complementary
 views for objects or lists of objects: certain types of objects have additional
 custom views, specific to that type.
 For example the Class Bar is nothing but a custom view of a folder of folders.
 Although I won't show you how to do this until section 
\begin_inset LatexCommand \ref{sec:Custom-Views-Revisited}

\end_inset 

, you can look for a special folder named 
\emph on 
Class List
\emph default 
 whose contents are reflected in the 
\emph on 
Class Bar
\emph default 
.
\layout Standard

Figure 
\begin_inset LatexCommand \ref{cap:Three-Views}

\end_inset 

 shows a composite tree view of the class bar.
 You can right-click 
\emph on 
Browse
\emph default 
 or 
\emph on 
New
\emph default 
 on any of the three views of the 
\emph on 
Persons
\emph default 
 type, for example.
 Furthermore, it is possible to customize the class bar by placing other
 types into that folder (for example the 
\emph on 
Role
\emph default 
 type, which would be useful for system administrators who sometimes need
 to define a new role, or add new users to an existing role).
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CM-9.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Three-Views}

\end_inset 

Three Views of the 
\emph on 
Class List
\emph default 
 Folder: A tree, an icon list, and the class bar
\end_inset 


\layout Standard

This brings up an important point about the philosophy behind the design
 of the JMatter framework: to the greatest extent possible, the JMatter
 framework strives to give the end user more control of the application,
 more independence from the developer.
 How often have you been in a position where you really wanted to make a
 simple change to the way an application is configured only to find out
 that the change could not be performed from its user interface (i.e.
 it required programming)?
\layout Subsection

Tour Summary
\layout Standard

Let's review what we've accomplished so far.
\layout Standard

We've seen how to launch the Contact Manager application, log in, and create
 a new user if we wish to.
 We learned how to browse and create contacts, and once our contact list
 becomes very large, how to make practical use of the query feature to find
 the information we're looking for.
 We also know how to switch between alternate views of the same information,
 and have a good grasp of what JMatter applications are all about, from
 the end user's perspective.
\layout Standard

Finally, we have a general understanding of the noun-verb metaphor that
 JMatter application user interfaces model.
 That is, the notion that one first selects a target object on which to
 perform an action, and then looks for and invokes a specific action on
 that object.
 This knowledge should enable us to quickly learn the user interfaces of
 other applications written with JMatter, even ones we're encountering for
 the first time.
\layout Standard

In the next chapter, we'll start exploring how to write JMatter applications.
 We'll build our own contact manager.
 You may or may not be surprised by now if I were to tell you that the task
 will take us only a few minutes.
\layout Chapter

A Zero-Code Contact Manager
\layout Standard

Let's write our own version of the contact manager.
 The point of this chapter is to lay the foundation for writing JMatter
 applications.
 You will learn how to create and setup a project, what information goes
 where, some of the configuration files and their role in a JMatter application.
 As the title of this chapter indicates, we will not have to write a single
 line of code to implement our first application!
\layout Section

Set Up the Project's Directory Structure
\layout Standard

The first thing we need to do is setup a directory structure for our project.
 Let's call our project 
\emph on 
CM
\emph default 
, short for ContactMgr, to ensure that the name doesn't conflict with the
 existing demo version of the contact manager application.
\layout Standard

Here is how:
\layout LyX-Code

cd jmatter
\layout LyX-Code

ant new-project -Dnew.project.name=CM
\layout Standard

After pressing 
\emph on 
Enter
\emph default 
, JMatter creates the directory structure for our project, in a base directory
 named CM.
 Switch to the newly created CM directory:
\layout LyX-Code

cd CM
\layout Section

Create a Database
\layout Standard

We now need to create a database for our application.
 We already did this in the previous chapter: we had to create a database
 and a user, and then specify the connection information in the text file
 
\emph on 
hibernate.properties
\emph default 
.
 The only difference of course is the database name and username information,
 which this time will be 
\emph on 
cm
\emph default 
.
\layout Standard

Follow the instructions in sections 
\begin_inset LatexCommand \ref{sub:Create-a-Database}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sub:Specify-DB-ConnInfo}

\end_inset 

 to perform these tasks for this version of the contact manager.
\layout Section

The Schema
\layout Standard

We would normally proceed by modeling our application: identifying the entities,
 and implementing them as Java classes.
 With JMatter however, things are a little different.
 JMatter was designed to be a framework for building business applications.
 As such, JMatter predefines a number of common types of business objects,
 including persons, their contact information, addresses, and businesses.
 In this chapter we'll reuse the predefined implementations of Person and
 Business, whose fully-qualified class names are
\emph on 
 com.u2d.type.composite.Person
\emph default 
 and 
\emph on 
com.u2d.type.composite.Business
\emph default 
, respectively.
\layout Standard

Before we generate our schema, we need a way to communicate to JMatter the
 various types of objects that we need to persist.
\layout Standard

We do this by editing a text file, actually an xml file, located in 
\emph on 
src/com/u2d
\emph default 
, named 
\emph on 
app-config.xml
\emph default 
.
 Open this file in a text or xml editor.
 You will see two comments labeled 
\emph on 
TODO
\emph default 
.
 Here's the first:
\layout LyX-Code

<?xml version=
\begin_inset Quotes erd
\end_inset 

1.0
\begin_inset Quotes erd
\end_inset 

?>
\layout LyX-Code

<!-- TODO: specify application name (or title) below (the 
\layout LyX-Code

                 'name' attribute) -->
\layout LyX-Code

<application name="jMatter Application"> 
\layout Standard

Revise the application name, maybe to 
\emph on 
Contact Manager
\emph default 
 or whatever you deem appropriate.
 The text you enter will appear in the title bar of the application's main
 window.
\layout Standard

The second looks like this:
\layout LyX-Code

<persist-classes>
\layout LyX-Code

   <!-- TODO: add model classes to this list to make them a part 
\layout LyX-Code

                    of the persistence schema -->
\layout LyX-Code

   <class>com.u2d.type.USState</class>
\layout LyX-Code

   <class>com.u2d.type.composite.ContactMethod</class>
\layout LyX-Code

   <class>com.u2d.type.composite.Folder</class>
\layout LyX-Code

   ..
\layout LyX-Code

\layout Standard

For every application, JMatter defines a list of Java classes that it needs
 to persist to database.
 Add the two types 
\emph on 
Person
\emph default 
 and 
\emph on 
Business
\emph default 
 to the top of the list, like this:
\layout LyX-Code

<persist-classes>
\layout LyX-Code

   <class>com.u2d.type.composite.Person</class>
\layout LyX-Code

   <class>com.u2d.type.composite.Business</class>
\layout LyX-Code

   ..
\layout Standard

We're now ready to generate the database schema:
\layout LyX-Code

ant schema-export
\layout Standard

Behind the scenes, JMatter introspects the classes we specified in 
\emph on 
app-config.xml
\emph default 
 and for each, it generates a Hibernate mapping file.
 JMatter then asks hibernate to generate the DDL (data definition language)
 instructions and send them to the database.
\layout Standard

You should now be able to inspect the contents of your database and verify
 that it contains these tables:
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout LyX-Code

contactmgr=> 
\backslash 
dt
\layout LyX-Code

                 List of relations
\layout LyX-Code

 Schema |        Name         | Type  |   Owner
\layout LyX-Code

--------+---------------------+-------+------------
\layout LyX-Code

 public | business            | table | contactmgr
\layout LyX-Code

 public | commandrestriction  | table | contactmgr
\layout LyX-Code

 public | complextype         | table | contactmgr
\layout LyX-Code

 public | compositequery      | table | contactmgr
\layout LyX-Code

 public | contactmethod       | table | contactmgr
\layout LyX-Code

 public | fieldrestriction    | table | contactmgr
\layout LyX-Code

 public | folder              | table | contactmgr
\layout LyX-Code

 public | folder_items        | table | contactmgr
\layout LyX-Code

 public | loggedevent         | table | contactmgr
\layout LyX-Code

 public | person              | table | contactmgr
\layout LyX-Code

 public | queryspecifications | table | contactmgr
\layout LyX-Code

 public | restriction         | table | contactmgr
\layout LyX-Code

 public | role                | table | contactmgr
\layout LyX-Code

 public | users               | table | contactmgr
\layout LyX-Code

 public | usstate             | table | contactmgr
\layout LyX-Code

(15 rows)
\layout Caption


\begin_inset LatexCommand \label{cap:Generated-Database-Schema}

\end_inset 

Generated Database Schema
\end_inset 


\layout LyX-Code

\layout LyX-Code

\layout Section

The Class Bar
\layout Standard

Similar to the task of specifying which types to persist to the database,
 we also need to specify which types to expose to the user interface via
 the Class Bar.
 Next to 
\emph on 
app-config.xml
\emph default 
 you'll find another xml file: 
\emph on 
class-list.xml
\emph default 
.
 Similar to the way you added two entries to the 
\emph on 
app-config
\emph default 
 file, add two entries to the class list, like so:
\layout LyX-Code

      <folder>
\layout LyX-Code

         <name>Model</name>
\layout LyX-Code

         <items>
\layout LyX-Code

           <type>com.u2d.type.composite.Person</type>
\layout LyX-Code

           <type>com.u2d.type.composite.Business</type>
\layout LyX-Code

           <type>com.u2d.app.User</type>
\layout Standard

Notice that these files already list a set of basic types including: 
\emph on 
User
\emph default 
, 
\emph on 
Folder
\emph default 
, 
\emph on 
CompositeQuery
\emph default 
 and 
\emph on 
LoggedEvent
\emph default 
.
 For the class list, they're not technically required.
 For the persisted classes listed in 
\emph on 
app-config.xml
\emph default 
, they are.
\layout Standard

The xml vocabulary exposed by class-list.xml reinforces the fact that the
 class list is modeled as a folder containing folders of types.
 To understand why the class list is modeled this way, go ahead and:
\layout Enumerate

rename the subfolder from 
\emph on 
Model
\emph default 
 to 
\emph on 
Manager
\layout Enumerate

create a second subfolder called 
\emph on 
Administrative
\layout Enumerate

place Person, Business, Folder, and CompositeQuery in 
\emph on 
Manager
\layout Enumerate

place User, LoggedEvent, and a new type: ComplexType in 
\emph on 
Administrative
\layout Standard

Your copy of 
\emph on 
class-list.xml
\emph default 
 should now look like this:
\layout LyX-Code

<?xml version="1.0" encoding="UTF-8"?>
\layout LyX-Code

<folder>
\layout LyX-Code

   <name>Class List</name>
\layout LyX-Code

   <items>
\layout LyX-Code

      <folder>
\layout LyX-Code

         <name>Manager</name>
\layout LyX-Code

         <items>
\layout LyX-Code

           <type>com.u2d.type.composite.Person</type>
\layout LyX-Code

           <type>com.u2d.type.composite.Business</type>
\layout LyX-Code

           <type>com.u2d.type.composite.Folder</type>
\layout LyX-Code

           <type>com.u2d.find.CompositeQuery</type>
\layout LyX-Code

         </items>
\layout LyX-Code

      </folder>
\layout LyX-Code

      <folder>
\layout LyX-Code

         <name>Administrative</name>
\layout LyX-Code

         <items>
\layout LyX-Code

           <type>com.u2d.app.User</type>
\layout LyX-Code

           <type>com.u2d.type.composite.LoggedEvent</type>
\layout LyX-Code

           <type>com.u2d.model.ComplexType</type>
\layout LyX-Code

         </items>
\layout LyX-Code

      </folder>
\layout LyX-Code

   </items>
\layout LyX-Code

</folder>
\layout Standard

When we run our application in the next section, we'll see how this data
 structure manifests itself visually.
\layout Standard

One last note: 
\emph on 
class-list.xml
\emph default 
 is used strictly to seed the database.
 Subsequent customizations to the class bar are performed directly from
 the UI
\begin_inset Foot
collapsed true

\layout Standard

UI: User Interface
\end_inset 

.
\layout Section

Running Your Contact Manager
\layout Standard

Let's do one more thing before we run our application: let's give it a splash
 screen.
 Do this by dropping a file named 
\emph on 
splash.png
\emph default 
 (or 
\emph on 
splash.jpg
\emph default 
 or 
\emph on 
splash.gif
\emph default 
) into the 
\emph on 
resources/images
\emph default 
 folder.
 If you like, just copy the one from the demo application.
\layout Standard

Ok, let's run our app:
\layout LyX-Code

ant run
\layout Standard

That's it.
 We now have a working contact manager application.
 Go ahead and exercise it: create new person ojbects, etc..
 Notice that the Class Bar looks similar to the type of toolbar popularized
 by Microsoft Outlook (see figure 
\begin_inset LatexCommand \ref{cap:Classlist-organized}

\end_inset 

).
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CH4-1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Classlist-organized}

\end_inset 

Classes organized into two subfolders: 
\emph on 
Manager
\emph default 
 and 
\emph on 
Administrative
\end_inset 


\layout Section

Custom Views Revisited
\begin_inset LatexCommand \label{sec:Custom-Views-Revisited}

\end_inset 


\layout Standard

In subsection 
\begin_inset LatexCommand \ref{sub:Custom-Views}

\end_inset 

 I had mentioned that the Class Bar can be customized directly from the
 User Interface.
 We're at a good place to show you how this works.
 Follow these instructions:
\layout Enumerate

Launch the application and log in
\layout Enumerate

Click on the 
\begin_inset Quotes eld
\end_inset 

Administrative
\begin_inset Quotes erd
\end_inset 

 folder in the Class Bar
\layout Enumerate

Browse 
\emph on 
Types
\emph default 
 (right-click Types, select 
\emph on 
Browse
\emph default 
)
\layout Standard

We've just asked our application to show us all the types defined in our
 system.
 Noticed that 
\emph on 
Contact Methods
\emph default 
 is among the list of defined types, though it doesn't have an icon, and
 thus shows up with a 
\begin_inset Quotes eld
\end_inset 

question mark
\begin_inset Quotes erd
\end_inset 

 icon.
\layout Enumerate

Click on the 
\emph on 
Manager
\emph default 
 folder in the Class Bar
\layout Enumerate

Drag 
\emph on 
Contact Methods
\emph default 
 to the empty area inside the 
\emph on 
Manager
\emph default 
 folder in the class bar
\layout Standard

We have just added a type to the class list! Our class bar should now resemble
 figure 
\begin_inset LatexCommand \ref{cap:Class-Bar-Customized}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/ClassBar-1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Class-Bar-Customized}

\end_inset 

Class Bar Customized with an Additional Type: Contact Methods
\end_inset 


\layout Standard

Even though we initially customized the class list by directly editing its
 xml file, we could have done it all from the user interface, as long as
 ComplexType and Folder are exposed to the initial class list.
\layout Section

Review
\layout Standard

Here's a quick recap of what we've done so far:
\layout Enumerate

We learned how to create a new project skeleton with the 
\emph on 
ant new-project
\emph default 
 command;
\layout Enumerate

We should be aware of the two configuration files 
\emph on 
app-config.xml
\emph default 
 and 
\emph on 
class-list.xml
\emph default 
 and how to configure them;
\layout Enumerate

Also, we learned that images go in the 
\emph on 
resources/images
\emph default 
 folder;
\layout Enumerate

Finally we learned the basic commands for creating our schema and running
 our application: 
\emph on 
ant schema-export
\emph default 
 and 
\emph on 
ant run
\layout Section

A Closer Look
\layout Standard

Before we leave this chapter, let's try to answer a few more questions and
 take a closer look at the files in our project.
\layout Subsection

Files
\layout Standard

JMatter defines certain conventions for where to place files.
 These conventions are probably very similar to your existing project convention
s.
 Here is a summary of these conventions:
\layout Enumerate

Source code resides in the 
\emph on 
src
\emph default 
 directory
\layout Enumerate

You will find certain resources, such as images, in the 
\emph on 
resources
\emph default 
 directory
\layout Enumerate

The 
\emph on 
ant
\emph default 
 build file for your project uses the default name 
\emph on 
build.xml
\emph default 
 and resides in your project's base directory
\layout Enumerate

Your source code is compiled to the target directory 
\emph on 
build/classes
\layout Enumerate

JMatter generates 
\emph on 
Hibernate
\emph default 
 mapping files for persisting your domain objects; these files by convention
 bear the suffix 
\begin_inset Quotes eld
\end_inset 


\emph on 
.hbm.xml
\emph default 

\begin_inset Quotes erd
\end_inset 

 and also are written to the 
\emph on 
build/classes
\emph default 
 directory
\layout Enumerate

When deploying your application with Java Web Start (see chapter 
\begin_inset LatexCommand \ref{cha:Deploying-your-Application}

\end_inset 

), the distribution file is placed in the 
\emph on 
dist
\emph default 
 directory
\layout Enumerate

The 
\emph on 
doc
\emph default 
 directory contains two text files: 
\emph on 
README
\emph default 
 and 
\emph on 
Cliche
\emph default 
, which you can use as a quick reference and simple setup instructions to
 help you get started on a new project
\layout Enumerate

The 
\emph on 
test
\emph default 
 directory is created for you to place JUnit tests you write to ensure that
 your code and business logic is correct and bug-free
\layout Enumerate

Any jar files, libraries that your project depends on at runtime are to
 be placed in the 
\emph on 
lib/src
\emph default 
 directory
\layout Enumerate

Any additional jar files necessary for testing should be placed in the 
\emph on 
lib/test
\emph default 
 directory
\layout Enumerate

Any jar files for tools that your project uses at design/build time should
 be placed in 
\emph on 
lib/tools
\layout Subsection

Ant Targets
\layout Standard

You don't need to memorize the names of the ant targets that we invoke (e.g.
 
\emph on 
ant run
\emph default 
, 
\emph on 
ant schema-export
\emph default 
); simply type:
\layout LyX-Code

ant -projecthelp
\layout Standard

to view a list of all the defined targets: their name and description.
\layout Subsection

A Peek at the Source Code
\layout Standard

Open the file 
\emph on 
Person.java
\emph default 
 in a text editor or IDE
\begin_inset Foot
collapsed true

\layout Standard

IDE: Integrated Development Environment
\end_inset 

 (it is located in 
\emph on 
jmatter/src/com/u2d/type/composite
\emph default 
).
 We're not going to attempt to understand every line of code just yet.
\layout Standard

What I want you to notice is that a Person defines two fields: 
\emph on 
name
\emph default 
, and 
\emph on 
contact
\emph default 
:
\layout LyX-Code

protected final Name _name = new Name();
\layout LyX-Code

protected final Contact _contact = new Contact();
\layout Standard

The Java classes 
\emph on 
Name
\emph default 
 and 
\emph on 
Contact
\emph default 
 are also defined in the framework.
 The 
\emph on 
Name
\emph default 
 class is composed of the parts that make up a name: prefix, first, middle,
 last, and suffix.
\layout Standard

If you dig a little deeper, you will see that 
\emph on 
Contact.java
\emph default 
 defines these fields:
\layout LyX-Code

private final USPhone _workPhone = new USPhone();
\layout LyX-Code

private final USPhone _mobilePhone = new USPhone();
\layout LyX-Code

private final USPhone _fax = new USPhone();
\layout LyX-Code

private final Email _email = new Email();
\layout LyX-Code

private final USAddress _address = new USAddress();
\layout LyX-Code

private ContactMethod _preferredContactMethod = new ContactMethod();
\layout Standard

Here we see that JMatter has a built-in understanding of types such as a
 US Phone number, an Email address, a US Address and a Contact Method.
\layout Standard

If you take a close look at the generated database schema for our application
 in figure 
\begin_inset LatexCommand \ref{cap:Generated-Database-Schema}

\end_inset 

, you will not find a database table to hold contact information or addresses.
\layout Standard

The reason is that with JMatter, you have the choice of modeling a field
 either as an association or as an aggregation.
 In the context of the class 
\emph on 
Person
\emph default 
, 
\emph on 
Contact
\emph default 
 and 
\emph on 
USAddress
\emph default 
 are modeled as aggregations, and so are treated in a manner similar to
 value fields such as the work phone or email address.
 The fields that make up the contact information and address are aggregated
 into the parent type's table.
 Hibernate calls these 
\emph on 
Components
\emph default 
.
\layout Standard

We'll learn more about ways of modeling relationships between objects in
 the next chapter.
 And we'll finally get a chance to write some code for a change.
 :-)
\layout Section

Summary
\layout Standard

With the basics for setting up, configuring, and running projects under
 our belt, we're now ready to do some real work.
 In the next chapter, we're finally going to get a chance to write some
 code in the MyTunes music application.
\layout Chapter

MyTunes in under 200 Lines of Code
\begin_inset LatexCommand \label{cha:MyTunes-Under-200}

\end_inset 


\layout Standard

Tunes seem to be a popular topic these days.
 Let's build a music player! Before we get started, bear in mind that we
 won't have to build features such as Smart Lists for songs; JMatter will
 give us those things for free.
 We'll be able to concentrate on the task at hand: modeling our application
 and implementing the behaviours of our music player, such as importing
 songs into our song database, and playing songs, of course.
 Let's get started.
\layout Section

The Usual
\layout Standard

Ok, we know how to begin: from the 
\emph on 
jmatter
\emph default 
 directory, invoke
\layout LyX-Code

ant new-project -Dnew.project.name=MyTunes
\layout LyX-Code

cd MyTunes
\layout LyX-Code

ant -projecthelp
\layout Standard

So far so good.
 Let's create our database:
\layout LyX-Code

psql -U postgres template1
\layout LyX-Code

create database mytunes
\layout LyX-Code


\backslash 
q
\layout LyX-Code

createuser -U postgres mytunes
\layout LyX-Code

vi resources/hibernate.properties
\layout LyX-Code

[edit the connection parameters]
\layout LyX-Code

:wq
\layout Standard

Ok, next, let's setup our project in our favorite IDE because we're finally
 going to be writing code.
\layout Section

Setup your Project in an IDE
\begin_inset LatexCommand \label{sec:Setup-your-IDE}

\end_inset 


\layout Standard

Technically, this step is optional.
 These days, the state of Integrated Development Environments (IDEs) for
 writing software in Java is so advanced that it is compelling to use one.
 These IDEs sport command completion features, intelligent-assisted editing,
 automatic code formatting, useful hints, refactoring support, and the list
 goes on.
\layout Standard

At the time of this writing, the three major IDEs for Java are 
\begin_inset LatexCommand \htmlurl[Eclipse]{http://www.eclipse.org/}

\end_inset 

, 
\begin_inset LatexCommand \htmlurl[IntelliJ IDEA]{http://www.jetbrains.com/idea/}

\end_inset 

, and 
\begin_inset LatexCommand \htmlurl[NetBeans]{http://www.netbeans.org/}

\end_inset 

.
 It doesn't really matter which you use, or whether you use one at all,
 as long as you're comfortable in your development environment.
\layout Standard

Below is a description of the steps that I take as I setup my project in
 IntelliJ IDEA:
\layout Enumerate

Launch the IDE program
\layout Enumerate

Create New Project (launches a wizard)
\begin_deeper 
\layout Enumerate

specify the project name as 
\emph on 
MyTunes
\emph default 
, and 
\layout Enumerate

the base directory path
\end_deeper 
\layout Enumerate

Pick the version of Java that I wish to use (Java 5)
\layout Enumerate

Specify that we'll be using a single module project
\layout Enumerate

Select the module type: Java module
\layout Enumerate

Specify the module name as 
\emph on 
MyTunes
\emph default 
 (accept the defaults)
\layout Enumerate

Make sure the source directory name is 
\emph on 
src
\layout Enumerate

Make sure the build directory path (where the compiled classes are placed)
 is 
\emph on 
build/classes
\layout Enumerate

Click 
\emph on 
Finish
\layout Standard

Nothing special here.
 Actually, most of the defaults were already correct; that is, I mostly
 clicked 
\emph on 
Next > Next > Next
\emph default 
, with one or two deviations from the defaults.
 My project is almost completely setup.
 The last thing we need to do is add the jar files in lib/src to our IDE
 classpath so that it won't complain about not being able to find classes.
 Since the specific instructions vary from IDE to IDE, and since this is
 such a basic operation, I won't hold your hand through this task.
 :-)
\layout Section

Getting Started
\layout Standard

Ok, checking out my 
\emph on 
iTunes
\emph default 
 application on a nearby powerbook, I see that the main entities in a music
 player system appear to be 
\emph on 
Songs
\emph default 
, 
\emph on 
Albums
\emph default 
, 
\emph on 
Artists
\emph default 
, and 
\emph on 
Genres
\emph default 
.
 Pretty straightforward.
 Let's get started by modeling each of these:
\layout Enumerate

Create a package to hold your classes; mine will be com.u2d.mytunes
\layout Enumerate

Create four classes: Song, Album, Artist, and Genre
\layout Standard

Let's take a look at a basic template for implementing the 
\emph on 
Artist
\emph default 
 JMatter class:
\layout LyX-Code

package com.u2d.mytunes;
\layout LyX-Code

\layout LyX-Code

import com.u2d.model.AbstractComplexEObject;
\layout LyX-Code

import com.u2d.model.Title;
\layout LyX-Code

import com.u2d.type.atom.StringEO;
\layout LyX-Code

import com.u2d.type.atom.TextEO;
\layout LyX-Code

\layout LyX-Code

public class Artist extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   private final StringEO _name = new StringEO();
\layout LyX-Code

   private final TextEO _bio = new TextEO();
\layout LyX-Code

   
\layout LyX-Code

   public static final String[] fieldOrder = {"name", "bio"};
\layout LyX-Code

\layout LyX-Code

   public Artist() {}
\layout LyX-Code

\layout LyX-Code

   public StringEO getName() { return _name; }
\layout LyX-Code

   public TextEO getBio() { return _bio; }
\layout LyX-Code

\layout LyX-Code

   public Title title() { return _name.title(); }
\layout LyX-Code

}
\layout Standard

Let's analyze the above:
\layout Enumerate


\emph on 
Artist extends AbstractComplexEObject
\emph default 

\newline 
In Java all the classes you write extend Object.
 When building JMatter applications, the base class for complex entities
 (ones that have more than a single field) is AbstractComplexEObject.
 Just like 
\emph on 
Object
\emph default 
 gives us 
\emph on 
toString()
\emph default 
 for free, 
\emph on 
AbstractComplexEObject
\emph default 
 also gives us a few things for free
\begin_inset Foot
collapsed true

\layout Standard

See section 
\begin_inset LatexCommand \ref{sec:Must-Extend}

\end_inset 

 for further discussion of this design decision.
 
\end_inset 

.
\layout Enumerate


\emph on 
Artist
\emph default 
 has two fields: 
\emph on 
name
\emph default 
, and 
\emph on 
bio
\emph default 

\newline 
It happens to be a personal style choice of the author to name instance
 variables with the underscore prefix.
 This, of course, is not necessary.
\layout Enumerate

Funky types: name is a StringEO, bio is a TextEO
\newline 
That's right.
 JMatter gives you a whole slew of atomic types to choose from, including
 types for phone numbers, social security numbers, time durations, images,
 email addresses, and much more.
 It's quite easy to adapt a String as a StringEO and vice versa
\begin_inset Foot
collapsed true

\layout Standard

See section 
\begin_inset LatexCommand \ref{sec:ValueHolder-vs-POJO}

\end_inset 

 for further discussion of this design decision.
\end_inset 

.
 There are two differences between a StringEO and a TextEO: [a] StringEO's
 are saved to the database as varchar types whereas TextEO's are saved as
 text types or some other similar large text object; and [b] StringEO editors
 in the GUI are text fields whereas TextEO editors are text areas.
\newline 
Think of the 
\emph on 
EO
\emph default 
 part of the type name as being an acronym for 
\emph on 
Enhanced Object.
\layout Enumerate

Name and Bio are marked final!
\newline 
Yep.
 That's part of the 
\emph on 
ValueHolder
\emph default 
 contract, these are never 
\emph on 
null
\emph default 
.
 To set a value on an atomic type, call the 
\emph on 
setValue()
\emph default 
 method.
 Consequently, atomic fields in JMatter classes have only getters.
\layout Enumerate


\emph on 
public static final String[] fieldOrder = {
\begin_inset Quotes erd
\end_inset 

name
\begin_inset Quotes erd
\end_inset 

, 
\begin_inset Quotes erd
\end_inset 

bio
\begin_inset Quotes erd
\end_inset 

}
\newline 

\emph default 
This is essentially metadata.
 You're giving JMatter a hint as to the order that you'd like these fields
 displayed when viewed using a form view.
 Name should come first, bio second.
 Notice that the field names are those derived from the accessor methods
 according to the JavaBeans convention, not the actual variable names.
\layout Enumerate


\emph on 
public Title title() { return _name.title(); }
\newline 

\emph default 
Every JMatter class you define should specify a title and how titles for
 instances should be formatted.
 In this case, the title for an artist object will simply be the artist's
 name.
 For the Person class in the previous chapter it was a concatenation of
 the person's name and the value of their preferred contact method (phone
 number or email address).
 The idea for the 
\emph on 
Title
\emph default 
 class was shamelessly taken from the 
\emph on 
NakedObjects
\emph default 
 framework, though you'll find in it a few additional features, such as
 the 
\emph on 
appendParens()
\emph default 
 method which allows you to perform concatenation by wrapping the argument
 in parentheses.
\layout Standard

That's it.
 The code is not very lengthy, but this first-time explanation certainly
 is.
\layout Standard

One last note: If you're thinking right now that metadata such as the fieldOrder
 field above might be better modeled using Java 5 annotations, I would agree
 with you; I may do just that in the next version of JMatter.
 But this design decision's impact on your productivity as a software developer
 is negligible.
\layout Section

The Album Class
\layout Standard

In a fashion similar to the way we wrote 
\emph on 
Artist
\emph default 
, let's now write a simple implementation for an Album:
\layout LyX-Code

package com.u2d.mytunes;
\layout LyX-Code

\layout LyX-Code

import com.u2d.type.atom.StringEO;
\layout LyX-Code

import com.u2d.type.atom.ImgEO;
\layout LyX-Code

import com.u2d.model.AbstractComplexEObject;
\layout LyX-Code

import com.u2d.model.Title;
\layout LyX-Code

import com.u2d.list.RelationalList;
\layout LyX-Code

\layout LyX-Code

public class Album extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   private final StringEO _name = new StringEO();
\layout LyX-Code

   private final ImgEO _cover = new ImgEO();
\layout LyX-Code

   
\layout LyX-Code

   public static final String[] fieldOrder = {"name", "cover"};
\layout LyX-Code

\layout LyX-Code

  public Album() {}
\layout LyX-Code

\layout LyX-Code

   public StringEO getName() { return _name; }
\layout LyX-Code

   public ImgEO getCover() { return _cover; }
\layout LyX-Code

\layout LyX-Code

   public Title title() { return _name.title(); }
\layout LyX-Code

}
\layout Standard

There's really very little new here.
 The only thing possibly worth mentioning is that we're defining a cover
 illustration for an album, that is of type 
\emph on 
ImgEO
\emph default 
.
 This basic type represents an image (gif, jpg, or png) that will be saved
 to database as some kind of binary large object (blob).
\layout Section

The Genre Class
\layout Standard

Let's take a look at 
\emph on 
Genre
\emph default 
 next.
 
\emph on 
Genre
\emph default 
 is a little more interesting.
 I decided to consider this type more like an enumeration.
 That is, that there should exist a fairly small, finite list of genres.
 However, unlike enumerations, we don't want to hard-code the list of genres
 in Java.
 We would like the end-user to be able to add entries to the list directly
 from the user interface.
 This is the template that JMatter says we should use:
\layout LyX-Code

package com.u2d.mytunes;
\layout LyX-Code

\layout LyX-Code

import com.u2d.type.AbstractChoiceEO;
\layout LyX-Code

import com.u2d.type.atom.StringEO;
\layout LyX-Code

import com.u2d.model.ComplexType;
\layout LyX-Code

\layout LyX-Code

public class Genre extends AbstractChoiceEO
\layout LyX-Code

{
\layout LyX-Code

   private final StringEO _code = new StringEO();
\layout LyX-Code

   private final StringEO _caption = new StringEO();
\layout LyX-Code

\layout LyX-Code

   public static String[] identities = {"code"};
\layout LyX-Code

   
\layout LyX-Code

   public Genre() {}
\layout LyX-Code

   public Genre(String code, String caption)
\layout LyX-Code

   {
\layout LyX-Code

      _code.setValue(code);
\layout LyX-Code

      _caption.setValue(caption);
\layout LyX-Code

   }
\layout LyX-Code

   
\layout LyX-Code

   public StringEO getCode() { return _code; }
\layout LyX-Code

   public StringEO getCaption() { return _caption; }
\layout LyX-Code

   public ComplexType choiceType() { return type(); }
\layout LyX-Code

}
\layout Standard

JMatter will make sure to give us a database table to hold genres.
 Notice that we've extended a different class: 
\emph on 
AbstractChoiceEO
\emph default 
.
 In the GUI, when we want to specify a genre for a song, we'll be picking
 the genre from a JComboBox (also called a 
\emph on 
select
\emph default 
 or 
\emph on 
pull-down
\emph default 
 menu).
 For each Genre object we'll specify both a code and a caption.
 The line
\layout LyX-Code

public static String[] identities = {"code"};
\layout Standard

is metadata telling JMatter that the code column in the table should be
 unique for all Genres (that is, you can't have two genres with the same
 code, 'rock' for example).
\layout Comment

This won't do.
 Investigate.
 If choiceType needs to be in parent, put it in parent and delete next paragraph.
\layout Standard

Honestly, I don't recall why you have to implement choiceType() and why
 choiceType() is simply not tucked away in the superclass, AbstractChoiceEO.
 This may simply be an oversight.
\layout Section

The Song Class
\layout Standard

Here's a first stab at the Song class:
\layout LyX-Code

package com.u2d.mytunes;
\layout LyX-Code

\layout LyX-Code

[imports collapsed]
\layout LyX-Code

\layout LyX-Code

public class Song extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   private final StringEO _title = new StringEO();
\layout LyX-Code

   private final TimeEO _duration = new TimeEO();
\layout LyX-Code

   private Album _album;
\layout LyX-Code

   private final Genre _genre = new Genre();
\layout LyX-Code

   private Artist _artist;
\layout LyX-Code

\layout LyX-Code

   static { TimeEO.setFormat("m:ss"); }
\layout LyX-Code

\layout LyX-Code

   public static String[] fieldOrder = 
\layout LyX-Code

                    {"title", "duration", "artist", "album", "genre"};
\layout LyX-Code

\layout LyX-Code

   public Song() {}
\layout LyX-Code

\layout LyX-Code

   public StringEO getTitle() { return _title; }
\layout LyX-Code

   public TimeEO getDuration() { return _duration; }
\layout LyX-Code

\layout LyX-Code

   public Album getAlbum() { return _album; }
\layout LyX-Code

   public void setAlbum(Album album)
\layout LyX-Code

   {
\layout LyX-Code

      Album oldAlbum = _album;
\layout LyX-Code

      _album = album;
\layout LyX-Code

      firePropertyChange("album", oldAlbum, _album);
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

   public Genre getGenre() { return _genre; }
\layout LyX-Code

\layout LyX-Code

   public Artist getArtist() { return _artist; }
\layout LyX-Code

   public void setArtist(Artist artist)
\layout LyX-Code

   {
\layout LyX-Code

      Artist oldValue = _artist;
\layout LyX-Code

      _artist = artist;
\layout LyX-Code

      firePropertyChange("artist", oldValue, _artist);
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

   public Title title() { return _title.title().appendBracket(_duration);
 }
\layout LyX-Code

\layout LyX-Code

}
\layout Standard

So far, this is more of the same, with a few new concepts.
 Let's review this class:
\layout Enumerate

The song class defines the fields: 
\emph on 
title, duration, album, genre, and artist
\emph default 
.
 As usual, we define the fieldOrder String array as a means of specifying
 the order in which these fields are to be displayed.
\layout Enumerate

The 
\emph on 
duration
\emph default 
 field is of a type we haven't seen before: 
\emph on 
TimeEO
\emph default 
.
 This type can be used to specify a certain length of time.
\layout Enumerate


\emph on 
static { TimeEO.setFormat("m:ss"); }
\emph default 

\newline 
This static code block is a small code wrinkle in the framework: we're specifyin
g that in this application we're going to want to format durations using
 minutes and seconds.
 The format string complies with the contract specified by 
\emph on 
java.text.SimpleDateFormat
\emph default 
.
\layout Enumerate

Accessors and Mutators
\newline 
Finally we see that not all fields are 
\emph on 
owned
\emph default 
 by the Song class.
 The fields album and artist are 
\emph on 
associations
\emph default 
 to other types.
 The convention for defining and specifying the accessors and mutators for
 association fields is different.
 It complies with the JavaBeans convention for bound properties.
 Notice we: [a] provide both a getter and a setter, and [b] fire a PropertyChang
eEvent after the assignment.
\layout Enumerate

Here we have a better example of a title() method.
 First, don't confuse the song title with the song type's title() method.
 They're two different things.
 We want songs to display their titles and durations and so we concatenate
 the two.
 I use the utility method 
\emph on 
appendBracket
\emph default 
 to display the song duration in brackets.
\layout Section

Running our Application
\layout Standard

We've been a little zealous here and defined all four classes Artist, Album,
 Genre, and Song at once.
 This is not an example of good incremental coding practice.
 However, we made sure to keep these classes really simple.
 We didn't implement any behavior, we simply defined four types along with
 some pretty basic properties on each, such as the Artist's name, a Song's
 title.
 If you like, feel free to keep the Song class even more simple by just
 giving it a title for now.
\layout Subsection

Configuration
\layout Standard

Add Artist, Album, Genre, and Song to 
\emph on 
app-config.xml
\emph default 
 and 
\emph on 
class-list.xml
\emph default 
.
 Here's class-list.xml:
\layout LyX-Code

<?xml version="1.0" encoding="UTF-8"?>
\layout LyX-Code

<folder>
\layout LyX-Code

   <name>Class List</name>
\layout LyX-Code

   <items>
\layout LyX-Code

      <folder>
\layout LyX-Code

         <name>Model</name>
\layout LyX-Code

         <items>
\layout LyX-Code

           <type>com.u2d.mytunes.Song</type>
\layout LyX-Code

           <type>com.u2d.mytunes.Album</type>
\layout LyX-Code

           <type>com.u2d.mytunes.Artist</type>
\layout LyX-Code

           <type>com.u2d.mytunes.Genre</type>
\layout LyX-Code

           <type>com.u2d.app.User</type>
\layout LyX-Code

           <type>com.u2d.type.composite.Folder</type>
\layout LyX-Code

           <type>com.u2d.find.CompositeQuery</type>
\layout LyX-Code

           <type>com.u2d.type.composite.LoggedEvent</type>
\layout LyX-Code

         </items>
\layout LyX-Code

      </folder>
\layout LyX-Code

   </items>
\layout LyX-Code

</folder>
\layout LyX-Code

\layout Standard

And app-config.xml:
\layout LyX-Code

<?xml version="1.0"?>
\layout LyX-Code

<application name="MyTunes">
\layout LyX-Code

   <view-mechanism>com.u2d.view.swing.SwingViewMechanism</view-mechanism>
\layout LyX-Code

   <look-and-feel>Metal</look-and-feel>
\layout LyX-Code

   <page-size>15</page-size>
\layout LyX-Code

   <persistence-mechanism>com.u2d.persist.HBMSingleSession
\layout LyX-Code

                                                   </persistence-mechanism>
\layout LyX-Code

   <persist-classes>
\layout LyX-Code

      <class>com.u2d.mytunes.Song</class>
\layout LyX-Code

      <class>com.u2d.mytunes.Album</class>
\layout LyX-Code

      <class>com.u2d.mytunes.Artist</class>
\layout LyX-Code

      <class>com.u2d.mytunes.Genre</class>
\layout LyX-Code

      <class>com.u2d.type.composite.Folder</class>
\layout LyX-Code

      <class>com.u2d.find.CompositeQuery</class>
\layout LyX-Code

      <class>com.u2d.type.composite.LoggedEvent</class>
\layout LyX-Code

      <class>com.u2d.app.User</class>
\layout LyX-Code

      <class>com.u2d.app.Role</class>
\layout LyX-Code

      <class>com.u2d.restrict.CommandRestriction</class>
\layout LyX-Code

      <class>com.u2d.restrict.FieldRestriction</class>
\layout LyX-Code

      <class>com.u2d.restrict.Restriction</class>
\layout LyX-Code

   </persist-classes>
\layout LyX-Code

</application>
\layout Subsection

Finally Running the Application
\layout Standard

Nothing new here.
 Let's run our app:
\layout LyX-Code

ant schema-export
\layout LyX-Code

ant run
\layout Standard

After logging in we should see something that looks like figure 
\begin_inset LatexCommand \ref{cap:MyTunes-FirstLook}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/MyTunes-1.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:MyTunes-FirstLook}

\end_inset 

A first look at MyTunes
\end_inset 


\layout Standard

This is problematic: we haven't specified any icons for our types.
 Let me tell you (and I speak from experience) that the choice and quality
 of your icons is as important (if not more important) to the success of
 your application than the quality of the code itself.
 Apple knows this very well.
 How often have you been fooled that an application is really nice by the
 amount of lipstick its authors put on its user interfaces?
\layout Standard

Here's how to specify icons for each type: in the 
\emph on 
resources/images
\emph default 
 directory, place 16x16 and 32x32 pixel versions of an icon for each type.
 The naming of these image files is important.
 It is by the file naming convention that JMatter knows to associate an
 image with a type.
 This idea again was shamelessly taken from the NakedObjects framework.
 If you haven't guessed it by now, NakedObjects had a strong influence on
 my thinking.
\layout Standard

Ok, images can be of type jpg, png, or gif, or anything that Java Standard
 Edition supports.
 Here is a listing of my 
\emph on 
resources/images
\emph default 
 folder:
\layout LyX-Code

eitan@ubuntu:~/projects/ds/MyTunes$ ls -lF resources/images/
\layout LyX-Code

total 40
\layout LyX-Code

-rwxr-xr-x  1 eitan eitan  855 2005-11-28 21:38 Album16.png*
\layout LyX-Code

-rwxr-xr-x  1 eitan eitan 1961 2005-11-28 21:39 Album32.png*
\layout LyX-Code

-rwxr-xr-x  1 eitan eitan 1961 2005-11-29 07:56 App32.png*
\layout LyX-Code

-rwxr-xr-x  1 eitan eitan  859 2005-11-28 21:39 Artist16.png*
\layout LyX-Code

-rwxr-xr-x  1 eitan eitan 2170 2005-11-28 21:40 Artist32.png*
\layout LyX-Code

-rwxr-xr-x  1 eitan eitan  925 2005-11-28 21:39 Genre16.png*
\layout LyX-Code

-rwxr-xr-x  1 eitan eitan 2596 2005-11-28 21:39 Genre32.png*
\layout LyX-Code

-rw-r--r--  1 eitan eitan  753 2005-11-28 21:13 README
\layout LyX-Code

-rwxr-xr-x  1 eitan eitan  696 2005-11-28 21:38 Song16.png*
\layout LyX-Code

-rwxr-xr-x  1 eitan eitan 1720 2005-11-28 21:38 Song32.png*
\layout LyX-Code

eitan@ubuntu:~/projects/ds/MyTunes$
\layout Standard

The convention is quite simple: [ClassName]16.png and [ClassName]32.png for
 each class.
 If, like me, producing icons is not your forte, then I highly recommend
 
\begin_inset LatexCommand \htmlurl[the incors professional icons collection]{http://www.iconexperience.com/}

\end_inset 

.
 Ok, now things should look a little bit nicer (see figure 
\begin_inset LatexCommand \ref{cap:MyTunes-with-Icons}

\end_inset 

).
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/MyTunes-2.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:MyTunes-with-Icons}

\end_inset 

MyTunes with Icons
\end_inset 


\layout Standard

That's much better, don't you agree?
\layout Comment

TODO: Need to setup Genres first before creating songs.
 Address this (later).
\layout Standard

We can play with the user interface some more and create songs and so on,
 but we're not quite finished with our application.
\layout Section

Back To the Code
\layout Standard

We've basically laid the model foundation.
 But we're missing something: an album should define and maintain a list
 of songs.
 We already have the other side of that association in 
\emph on 
Song.album
\emph default 
.
 Let's add that one-to-many relationship right now.
 In Album.java, add these:
\layout LyX-Code

   private final RelationalList _songs = new RelationalList(Song.class);
\layout LyX-Code

   public static final Class songsType = Song.class;
\layout LyX-Code

\layout LyX-Code

   public RelationalList getSongs() { return _songs; }
\layout Standard

If you're thinking that the above might be better modeled using Java 5 generics,
 I would agree with you; I may do just that in the next version of JMatter.
 But this design decision's impact on your productivity as a software developer
 is negligible.
\layout Standard

We defined a relational list of type song.
 The reason for the static Class 
\emph on 
songsType
\emph default 
 is to allow JMatter to introspect the list type statically.
 It's not pretty but it will do for now.
\layout Standard

One last thing: we have a bidirectional one-to-many relationship between
 a song and an album.
 We need to add two more lines of metadata to tell JMatter about it.
 In Album:
\layout LyX-Code

   public static String songsInverseFieldName = "album";
\layout Standard

And in Song:
\layout LyX-Code

   public static final String albumInverseFieldName = "songs";
\layout Standard

Our model might quickly get of sync with the database tables we generated
 when we add new fields to types.
 There are two ways to bring them back in sync.
 The easy way:
\layout LyX-Code

ant schema-update
\layout Standard

The harder, possibly more correct way:
\layout Enumerate

Dump your data out of the database
\layout Enumerate

ant schema-export (wipes out the data)
\layout Enumerate

restore the data
\layout Standard

As I understand it, this task is one of the specialties of database administrato
rs.
 The restoration of data usually needs to be broken down into at least these
 steps:
\layout Enumerate

drop constraints on your schema
\layout Enumerate

restore the data
\layout Enumerate

add the constraints back in
\layout Standard

Anyhow, in our case, we don't have any precious data to save and restore
 yet so we'll go the easy route of either using schema-update or schema-export.
 JMatter places the script template 
\emph on 
dump_db.sh
\emph default 
 in your project's base directory that you can use to dump your data out
 of a postgres database.
 This script is nothing more than a thin wrapper around PostgresQL's 
\emph on 
pg_dump
\emph default 
 command.
\layout Section

Validation
\layout Standard

You might have also noticed that you can now create albums or songs with
 no name or title.
 This is a little disconcerting.
 There are two ways to address this issue.
 The first might be to specify that a song's title or album's name should
 be unique.
 We've seen this already with 
\emph on 
Genre
\emph default 
: you can specify the field metadata 
\emph on 
identities
\emph default 
 to enforce this.
 So in Album, you can add this:
\layout LyX-Code

public static String[] identities = {
\begin_inset Quotes erd
\end_inset 

name"};
\layout Standard

Like 
\emph on 
fieldOrder
\emph default 
, you can specify multiple identity fields if necessary.
 The field is flagged with the 'unique' database constraint and in addition,
 JMatter treats identity fields as required.
\layout Standard

There's another way.
 You can edit the file 
\emph on 
resources/model-metadata.properties
\emph default 
 like so:
\layout LyX-Code

#
\layout LyX-Code

Song.title.required=true
\layout LyX-Code

Album.name.required=true
\layout LyX-Code

Artist.name.required=true
\layout LyX-Code

#
\layout Standard

Now JMatter will give you built-in validation support in the user interface:
\layout Enumerate

Required fields' captions are automatically styled in blue;
\layout Enumerate

Validation checks will automatically be performed when attempting to create
 or save instances;
\layout Enumerate

The user interface will automatically display validation error messages
 in the proper locations on the form
\layout Standard

Figure 
\begin_inset LatexCommand \ref{cap:Validation}

\end_inset 

 shows the behavior of the JMatter user interface after the change.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/MyTunes-3.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Validation}

\end_inset 

Validation
\end_inset 


\layout Standard

I attempted to create a new Artist, leaving the name blank.
 So JMatter is pre-wired to support validation.
 This mechanism we just specified is the simple way, for required fields.
 There's an additional method
\emph on 
 validate()
\emph default 
 that we can override in any of our types to specify more complex validation
 rules that have dependencies on multiple fields.
\layout Subsection

A word about the model-metadata.properties File
\layout Standard

Although the mechanism of specifying model metadata in a text file may continue
 to exist in the future, it is the goal of the JMatter framework to move
 all of that work directly into the GUI.
 That is, whether a field is required, a field's default value, its caption
 and more will all be entered in the same way one enters the username for
 a new User.
 The intent is for Field types (and meta-types in general) to become full-fledge
d JMatter objects, with a GUI, editability, and so on.
\layout Section

Behaviour
\layout Standard

So far, we seem to have nice, working model for a music application: we
 can create song definitions, album definitions, associate them.
 We can define artists like the famous 
\emph on 
Shlomo Artzi
\emph default 
 etc..
\layout Standard

This modeling is important, don't get me wrong.
 After we've defined a thousand songs, we'll have powerful search features
 at our disposal to find that one special song.
 What's missing is behaviour: the ability to play songs! Also, it would
 be awfully tedious to enter all that information by hand.
 Can't we just import that stuff from our iTunes library?
\layout Standard

So, we've just defined some additional work: we'd like to be able to play
 songs and we'd like to be able to import songs listings.
\layout Standard

A short glance at the Java sound API javadocs tells us that we can attempt
 to play an mp3 file with this bit of code:
\layout LyX-Code

   try
\layout LyX-Code

   {
\layout LyX-Code

      AudioClip clip = Applet.newAudioClip(_path.fileValue().toURL());
\layout LyX-Code

      clip.play();
\layout LyX-Code

   }
\layout LyX-Code

   catch (MalformedURLException ex)
\layout LyX-Code

   {
\layout LyX-Code

      System.err.println(ex);
\layout LyX-Code

   }
\layout Standard

Ok, so we need to keep track of the path where our song file is located.
 So we'll need to add a new field to Song:
\layout LyX-Code

   private final FileEO _path = new FileEO();
\layout Standard

And add the new field to our fieldOrder array:
\layout LyX-Code

   public static String[] fieldOrder = 
\layout LyX-Code

             {"title", "duration", "artist", "album", "genre", "path"};
\layout Standard

It sure would be nice to construct a song in a single line, so let's add
 this construcotr:
\layout LyX-Code

   public Song(File path)
\layout LyX-Code

   {
\layout LyX-Code

      _title.setValue(path.getName());
\layout LyX-Code

      _path.setValue(path);
\layout LyX-Code

   }
\layout Standard

Don't forget the accessor method for 
\emph on 
_path
\emph default 
:
\layout LyX-Code

   public FileEO getPath() { return _path; }
\layout Standard

Finally we need to expose a 
\emph on 
play
\emph default 
 command to our user interface.
 Since we're already there, why not also add a pause command?
\layout LyX-Code

   private AudioClip _clip;
\layout LyX-Code

\layout LyX-Code

   @CommandAt(mnemonic='p')
\layout LyX-Code

   public Object Play(CommandInfo cmdInfo)
\layout LyX-Code

   {
\layout LyX-Code

      try
\layout LyX-Code

      {
\layout LyX-Code

         _clip = Applet.newAudioClip(_path.fileValue().toURL());
\layout LyX-Code

         vmech().onMessage("Playing song.."+this);
\layout LyX-Code

         _clip.play();
\layout LyX-Code

         return null;
\layout LyX-Code

      }
\layout LyX-Code

      catch (MalformedURLException ex)
\layout LyX-Code

      {
\layout LyX-Code

         System.err.println(ex);
\layout LyX-Code

         return ex.getMessage();
\layout LyX-Code

      }
\layout LyX-Code

   }
\layout LyX-Code

   @CommandAt
\layout LyX-Code

   public void Pause(CommandInfo cmdInfo)
\layout LyX-Code

   {
\layout LyX-Code

      if (_clip != null) _clip.stop();
\layout LyX-Code

   }
\layout Standard

It turns out this will work for certain audio files but not for MP3's.
 A quick google and we discover a nice little utility that gives us an MP3
 Service Provider Interface (SPI) for the Java Sound API.
 We download it.
 Its 
\emph on 
README.txt
\emph default 
 file tells us we just need to add three jar files to our classpath:
\layout LyX-Code

cp mp3spi1.9.3.jar ~/projects/ds/MyTunes/lib/src
\layout LyX-Code

cp lib/*.jar ~/projects/ds/MyTunes/lib/src
\layout Standard

Now we're in business
\begin_inset Foot
collapsed true

\layout Standard

And you thought that the part in the movie 
\emph on 
The Matrix
\emph default 
 where a helicopter manual is summoned a few seconds prior to flying one
 was pure science fiction.
 :-)
\end_inset 

.
 Let's give it a shot:
\layout LyX-Code

ant schema-export
\layout LyX-Code

ant run
\layout LyX-Code

[create a song, specify a path to an mp3 file, save, and click Play]
\layout Standard

On my machine, Ubuntu thought for maybe 2-3 seconds while it loaded the
 mp3 song and then started playing 
\emph on 
Amour Perdu
\emph default 
, by 
\emph on 
Adamo
\emph default 
 (see figure 
\begin_inset LatexCommand \ref{cap:Playing-Amour-Perdu}

\end_inset 

).
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/MyTunes-amoutperdu.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Playing-Amour-Perdu}

\end_inset 

Playing 
\emph on 
Amour Perdu
\end_inset 


\layout Standard

Time to slow down and explain some of what we just did..
\layout Section

Analysis
\layout Subsection

FileEO
\layout Standard

JMatter provides editors for all kinds of basic types including Files.
 Our path was of type FileEO and so when I'm ready to assign a path to a
 song, JMatter will give me a JFileChooser.
 Simple enough.
\layout Subsection

Commands
\layout Standard

Exposing commands on types in JMatter is as simple as exposing types.
 A method maps to a command just as a class maps to a type.
 The convention to follow if one desires to expose a command to the GUI
 is to decorate the method with the 
\emph on 
@CommandAt
\emph default 
 annotation.
 This annotation is currently defined to accept a number of options, including
 the mnemonic character that the user interface will use to make the command
 more keyboard-accessible.
 There's one additional requirement, that these methods take a CommandInfo
 argument.
 We don't actually need that information in this particular case but there
 exist situations when we do.
 Anyhow, it's part of the current convention established by JMatter.
\layout Standard

The caption that JMatter uses in menu items and buttons representing a command
 method is derived from the method name.
 For an annotated method named ProduceHCFA_WithForm, for example, the caption
 will be 
\emph on 
Produce HCFA With Form
\emph default 
.
\layout Standard

Notice that we did not have to worry about launching the song in a separate
 thread.
 JMatter does all this for us.
 Our user interface remains responsive the entire time.
 Although the UI replaces the mouse cursor with a WAIT_CURSOR (which these
 days seems to be some kind of spinning wheel on Ubuntu Linux anyway) to
 indicate that the song has not finished playing, we have full control over
 the UI and can close our window, open new ones, perform queries, etc..
 all while our Song plays in the background.
\layout Subsection

onMessage()
\layout Standard

There's a curious line of code in the middle of the command implementation:
\layout LyX-Code

vmech().onMessage("Playing song.."+this);
\layout Standard

From the codebase, you have access to the status bar of the GUI.
 
\emph on 
vmech()
\emph default 
 is a method that returns a reference to the view mechanism.
 
\emph on 
onMessage()
\emph default 
 signals to the view mechanism to display a bit of text to the status bar.
\layout Subsection

Return Type
\layout Standard

Our command method returns an Object.
 Here is yet another simple convention established by JMatter that if for
 some reason your command returns a bit of text, that bit of text will be
 displayed to the GUI.
 Notice that if for some reason we get an exception attempting to play our
 song, we're returning an error message, which will be displayed to the
 user.
\layout Standard

JMatter tries to do this in good taste.
 Rather than display some kind of dialog box that one is forced to dismiss,
 JMatter displays a timed, semi-transparent, borderless dialog with the
 message which automatically disappears after a few seconds or when clicked
 on.
\layout Standard

It's time to deal MyTunes its final blow: let's implement a mechanism for
 importing songs from our iTunes library.
\layout Section

The Final Blow
\layout Standard

So here's the issue: sitting in my 
\emph on 
~/music/iTunes Music/
\emph default 
 folder are a bunch of mp3 files.
 I don't want to add them to my system one by one.
 I'd like to basically right-click on 
\emph on 
Songs
\emph default 
 and request that MyTunes scan for songs on my disk, from a specific base
 path.
 I decided to call my command 
\emph on 
Scan From Base Path
\emph default 
 and so will name my command method accordingly:
\layout LyX-Code

   @CommandAt
\layout LyX-Code

   public static Object ScanFromBasePath(CommandInfo cmdInfo,
\layout LyX-Code

                                         @ParamAt("Base Path") FileEO basePath)
\layout LyX-Code

   {
\layout LyX-Code

      if (!basePath.fileValue().isDirectory())
\layout LyX-Code

         return "You must specify a directory as the base path";
\layout LyX-Code

      List songFiles = basePath.listRecursive(mp3Filter);
\layout LyX-Code

      Set songs = new HashSet();
\layout LyX-Code

      for (int i=0; i<songFiles.size(); i++)
\layout LyX-Code

      {
\layout LyX-Code

         songs.add(new Song((File) songFiles.get(i)));
\layout LyX-Code

      }
\layout LyX-Code

      HBMSingleSession pmech = (HBMSingleSession)
\layout LyX-Code

            AppFactory.getInstance().getApp().getPersistenceMechanism();
\layout LyX-Code

      pmech.saveMany(songs);
\layout LyX-Code

      return "Finished importing MP3s";
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

   private static FileFilter mp3Filter = new FileFilter()
\layout LyX-Code

   {
\layout LyX-Code

      public boolean accept(File file)
\layout LyX-Code

      {
\layout LyX-Code

         return file.getName().toLowerCase().endsWith(".mp3");
\layout LyX-Code

      }
\layout LyX-Code

   };
\layout LyX-Code

\layout Standard

Let's study this bit of code:
\layout Enumerate

Our method is defined as static to ensure that our command is added to the
 Song type, and not to song instances.
 The command will be accessible from the Class Bar (right-click on Song).
\layout Enumerate

Next, we see that we use the same little trick of returning a bit of String
 if the specified path is not a directory.
 So the user will get an error message when they pick a base path that is
 invalid.
\newline 
Wait a minute.
 Where or when did we tell JMatter to give us a base path? Notice that the
 command method takes an additional argument of type FileEO.
 When this command is invoked, JMatter will see that this method needs a
 path and will prompt the user for it.
\layout Enumerate

Look towards the bottom of the listing: we're defining a plain old Java
 file filter (POJFF) to let through only files with a .mp3 suffix.
 Then we invoke a method 
\emph on 
listRecursive()
\emph default 
 on FileEO, passing in the file filter.
 Now we have a listing of all the mp3 files nested inside the base directory.
\layout Enumerate

Now all we need to do is create a Song object for each file and save all
 these songs.
 Not bad for ~ 10 lines of code, if I may say so.
\layout Standard

Let's try this out.
 We don't need to sync with the database this time, just re-run the app:
\layout LyX-Code

ant run
\layout Standard

Figure 
\begin_inset LatexCommand \ref{cap:Songs-after-import}

\end_inset 

 shows the song listing of the base directory after invoking 
\emph on 
Scan From Base Path
\emph default 
 on Song.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/MyTunes-SongListing.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Songs-after-import}

\end_inset 

Song Listing after Import
\end_inset 


\layout Standard

The operation created 159 Song objects or eleven pages of songs.
 The durations are not correct of course.
 A better way to solve this problem would be to interpret the iTunes xml
 file, which contains all sorts of song metadata besides the basic song
 file information.
\layout Section

Not Completely Finished
\layout Standard

If we take a moment to think about our implementation, we'll realize that
 our work is not exactly done.
 Although our songs actually play, our implementation is naive.
 Is the song actually streamed? Are resources disposed of properly?
\layout Standard

A little more research into Java sound shows us that the API we're using
 is really outdated.
 There is a newer Java sound API in the 
\emph on 
javax.sound
\emph default 
 package.
 Furthermore, even that API has been somewhat deprecated by the Java Media
 Framework, which is an add-on to the standard Java distribution.
 Finally, we discover that JMF itself has been in maintenance mode for a
 number of years now.
 Some advocate using Apple's QuickTime for Java API (QTJ).
 I personally have an issue with using QTJ as it's not a true multi-platform
 solution: it'll work only on proprietary systems such as MacOSX and Windows.
\layout Standard

Here is a list of enhancements we can think of for our MyTunes player:
\layout Enumerate

Replace our audio playing implementation with one that is based on the Java
 Media Framework
\layout Enumerate

Add a second import implementation that interprets iTunes' XML metafile
\layout Enumerate

Revise our model to define the notion of a current playlist, add a command
 to Song to add it to the playlist, and finally, move the play and pause
 commands from Song to the new PlayList.
 This revised model seems to make a little more sense.
\layout Standard

The point here is that JMatter frees you to work on the important things,
 like properly importing or playing a song.
 You don't have to worry about infrastructure services such as persistence,
 queries, or a user interface.
\layout Standard

In very little time, we created a basic music player with Smart Lists.
 Figure 
\begin_inset LatexCommand \ref{cap:That-Special-Song}

\end_inset 

 shows the 
\emph on 
quick search
\emph default 
 feature built into JMatter where you can just type in a song title in a
 listing's searchbar to filter the list accordingly.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/MyTunes-search.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:That-Special-Song}

\end_inset 

That One Special Song..
\end_inset 


\layout Section

Summary
\layout Standard

To say that we covered a lot of ground in this chapter would be an understatemen
t.
 And yet, if we go through the due diligence of measuring how much code
 we actually produced:
\layout LyX-Code

eitan@ubuntu:~/projects/ds/MyTunes/src/com/u2d/mytunes$ wc -l *.java
\layout LyX-Code

  28 Album.java
\layout LyX-Code

  21 Artist.java
\layout LyX-Code

  24 Genre.java
\layout LyX-Code

 119 Song.java
\layout LyX-Code

 192 total
\layout LyX-Code

eitan@ubuntu:~/projects/ds/MyTunes/src/com/u2d/mytunes$
\layout Standard

We discover that we wrote our music player in under 200 lines of code! That's
 readable.
 That's workable.
 But not just 200 lines of code: a full-fledged music player in under an
 hour? That's a paradigm shift.
\layout Standard

Let's quickly review what we learned in this chapter:
\layout Enumerate

We learned how to setup our project in an IDE.
\layout Enumerate

We've learned the basic class template for our business objects in JMatter:
 our classes extend AbstractComplexEObject, they have aggregate properties
 that follow the ValueHolder pattern, and they have associations to other
 objects that follow the JavaBeans accessor-mutator pattern.
\layout Enumerate

We learned how to control the field order in the GUI with the 
\emph on 
fieldOrder
\emph default 
 static member; we can specify that a property is unique by including it
 in the 
\emph on 
identities
\emph default 
 static member.
\layout Enumerate

We learned how to associate icons with types by placing our icons in the
 
\emph on 
resources/images
\emph default 
 folder, and following a specific naming convention.
\layout Enumerate

We learned how to expose both instance and class (static) actions to the
 UI, again by following a specific method signature convention for command
 methods.
 We've also seen how JMatter can handle actions that take arguments.
\layout Enumerate

We've been exposed to some of the atomic types that JMatter provides out
 of the box, including: StringEO, TextEO, ImgEO, TimeEO, and FileEO.
\layout Enumerate

We've also been exposed to a simple mechanism for specifying field metadata,
 such as whether a field is required or not.
\layout Standard

Although we have indeed 
\begin_inset Quotes eld
\end_inset 

scratched the surface,
\begin_inset Quotes erd
\end_inset 

 we're not even half-way down: jMatter bears many more features that we
 have yet to discuss and uncover.
\layout Standard

A small but useful additional feature that we're going to use in the next
 chapter is the ability to customize icons on a per-instance basis.
 That is, we can use the artist's photo as the basis for its icon in the
 MyTunes user interface; though we'll introduce this feature in the context
 of a new application, a Conference Manager.
\layout Standard

Some other, more serious features in JMatter include
\layout Enumerate

Integration with JFreeReport for producing PDFs
\layout Enumerate

Calendaring (we'll see this in the next chapter)
\layout Enumerate

Wizards
\layout Enumerate

Polymorphic modeling support including interface-based modeling
\layout Chapter

A Conference Manager
\begin_inset LatexCommand \label{cha:A-Conference-Manager}

\end_inset 


\layout Standard

In this chapter we're going to build a conference management application.
 The idea for this application came to me while a speaker in a real series
 of conferences: The 
\emph on 
No Fluff Just Stuff
\emph default 
 Java and Open Source symposia.
\layout Standard

Here are some of the features of JMatter that I will be introducing in this
 chapter:
\layout Enumerate

Reinforcing our understanding of modeling a domain according to the conventions
 of the JMatter framework
\layout Enumerate

More metadata
\layout Enumerate

How to use an object's image field as its icon representation
\layout Enumerate

How to add Calendaring support to your application
\layout Enumerate

Polymorphic modeling
\layout Section

Analysis
\layout Standard

Let's begin by reviewing the 
\emph on 
nofluffjuststuff.com
\emph default 
 web site to get a feel for the business domain we're going to be working
 with.
\layout Standard

From the home page:
\layout Enumerate

click on 
\emph on 
Speakers
\emph default 
 in the toolbar
\layout Enumerate

Browse through the list of speakers
\layout Enumerate

Drill down to a specific speaker
\layout Enumerate

We note that a speaker has a name and a biography, as well as a list of
 presentations
\layout Enumerate

A presentation appears to have a title, an abstract, and an association
 back to the speaker
\layout Standard

Let's now take a look at upcoming or past symposia.
 Looking at the list of past symposia, I see that the Rocky Mountain Software
 Symposium took place during the weekend of November 11 2005.
 Click on a specific symposium and you'll see a list of speakers, and a
 list of sessions.
 If you click on the link for the agenda, you'll see another view of the
 sessions for this particular symposium.
 Note that conferences will often have multiple sessions taking place at
 the same time, but at different presentation rooms.
\layout Standard

So we can derive from this little stroll through the 
\emph on 
NFJS
\emph default 
 web site that some of the basic entities in a conference management system
 include a 
\emph on 
Speaker
\emph default 
, a 
\emph on 
Talk
\emph default 
 (or Presentation), a 
\emph on 
Session
\emph default 
, a 
\emph on 
Symposium
\emph default 
, and probably a 
\emph on 
Room
\emph default 
.
 We also have a fairly good understanding of how these types interrelate.
 We can say that:
\layout Enumerate

A conference management system is essentially a list of symposia
\layout Enumerate

Each symposium consists of a list of sessions
\layout Enumerate

A session is essentially a talk given at a specific location, at a specific
 time, with a specified duration
\layout Enumerate

A Talk is given by a Speaker, who might have an entire portfolio of talks
\layout Standard

We could also think about how such a software application might assist in
 the task of planning a new symposium, perhaps with scheduling sessions,
 printing agenda, etc..
\layout Section

Setting up the Project
\layout Standard

Setting up our project should be a familiar task by now.
 Luckily, our little 
\emph on 
new-project
\emph default 
 ant target does most of the work for us:
\layout LyX-Code

ant new-project -Dnew.project.name=Sympster
\layout LyX-Code

cd Sympster
\layout Standard

And we also have to create a database..
\layout LyX-Code

createdb -U postgres sympster
\layout LyX-Code

createuser -U postgres sympster
\layout LyX-Code

vi resources/hibernate.properties
\layout LyX-Code

[edit the connection parameters]
\layout LyX-Code

:wq
\layout Standard

Go ahead and setup your project in your favorite IDE (see section 
\begin_inset LatexCommand \ref{sec:Setup-your-IDE}

\end_inset 

).
 We proceed by writing our model classes.
\layout Section

The Model
\layout Standard

In our analysis, we came up with a list of the primary types we wanted in
 our system: 
\emph on 
Symposium
\emph default 
, 
\emph on 
Speaker
\emph default 
, 
\emph on 
Talk
\emph default 
, 
\emph on 
Session
\emph default 
, and 
\emph on 
Room
\emph default 
.
 Let's create a Java package where our classes will reside; proceed by creating
 a class for each of these types.
\layout Subsection

Type Icons and Config File Setup
\layout Standard

For each type, we need to:
\layout Enumerate

provide a pair of icons, name them <typename>16.png and <typename>32.png,
 and place them in 
\emph on 
resources/images
\layout Enumerate

specify the fully-qualified type name in app-config.xml
\layout Enumerate

specify the fully-qualified type name in class-list.xml
\layout Subsection

The Symposium Class
\layout Standard

Here's a simple implementation for a Symposium:
\layout LyX-Code

package com.u2d.sympster;
\layout LyX-Code

\layout LyX-Code

import com.u2d.model.AbstractComplexEObject;
\layout LyX-Code

import com.u2d.model.Title;
\layout LyX-Code

import com.u2d.type.atom.StringEO;
\layout LyX-Code

\layout LyX-Code

public class Symposium extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   private final StringEO name = new StringEO();
\layout LyX-Code

   
\layout LyX-Code

   public Symposium() {}
\layout LyX-Code

   
\layout LyX-Code

   public StringEO getName() { return name; }
\layout LyX-Code

   public Title title() { return name.title(); }
\layout LyX-Code

   public static String pluralName() { return "Symposia"; }
\layout LyX-Code

}
\layout Standard

We're extending from the base class AbstractComplexEObject.
 We defined a single field so far: the symposium's name.
 We have a getter method for the 
\emph on 
name
\emph default 
 field, and our 
\emph on 
title()
\emph default 
 method.
 The only new bit is the optional implementation of the static method 
\emph on 
pluralName()
\emph default 
.
 The default derivation of the plural name for Symposium is not intelligent
 enough in this case so we provide it.
 We've already seen how a type's plural name is used in JMatter's user interface
: the title for each entry in the class bar uses it; the title bar for listings
 also displays the list item type's plural name.
\layout Subsection

The Speaker Class
\layout Standard

Again, the code here is fairly 
\begin_inset Quotes eld
\end_inset 

bare bones:
\begin_inset Quotes erd
\end_inset 


\layout LyX-Code

package com.u2d.sympster;
\layout LyX-Code

\layout LyX-Code

import com.u2d.model.AbstractComplexEObject;
\layout LyX-Code

import com.u2d.model.Title;
\layout LyX-Code

import com.u2d.type.atom.StringEO;
\layout LyX-Code

import com.u2d.type.atom.TextEO;
\layout LyX-Code

import com.u2d.type.atom.ImgEO;
\layout LyX-Code

import com.u2d.list.RelationalList;
\layout LyX-Code

\layout LyX-Code

public class Speaker extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   private final StringEO name = new StringEO();
\layout LyX-Code

   private final StringEO title = new StringEO();
\layout LyX-Code

   private final TextEO bio = new TextEO();
\layout LyX-Code

   private final ImgEO photo = new ImgEO();
\layout LyX-Code

   
\layout LyX-Code

   private final RelationalList talks = new RelationalList(Talk.class);
\layout LyX-Code

   public static Class talksType = Talk.class;
\layout LyX-Code

   public static String talksInverseFieldName = "speaker";
\layout LyX-Code

\layout LyX-Code

   public static String[] fieldOrder = {"name", "title", "photo", "bio",
 "talks"};
\layout LyX-Code

   
\layout LyX-Code

   public Speaker() {}
\layout LyX-Code

\layout LyX-Code

   public StringEO getName() { return name; }
\layout LyX-Code

   public StringEO getTitle() { return title; }
\layout LyX-Code

   public TextEO getBio() { return bio; }
\layout LyX-Code

   public ImgEO getPhoto() { return photo; }
\layout LyX-Code

   public RelationalList getTalks() { return talks; }
\layout LyX-Code

\layout LyX-Code

   public Title title() { return name.title(); }
\layout LyX-Code

}
\layout Standard

We see that speakers have a name, title, short biography, and a photo.
 Speakers also have a portfolio of talks, modeled as a list, or one-many
 relationship.
 Since I plan to make this relationship bidirectional (a talk will have
 a reference to its speaker), I also specified the inverse field's name.
 We also see the 
\emph on 
fieldOrder
\emph default 
 metafield used to specify the display order of a speaker's fields.
\layout Standard

Notice that I could have chosen to use a 
\emph on 
Name
\emph default 
 type to represent the speaker's name.
 In this instance I chose to keep the name simple as a single atomic field.
\layout Subsection

The Talk Class
\layout Standard

We're still in the process of laying the foundation for our application.
 Here's the code for our first pass implementation for a Talk:
\layout LyX-Code

package com.u2d.sympster;
\layout LyX-Code

\layout LyX-Code

import com.u2d.model.AbstractComplexEObject;
\layout LyX-Code

import com.u2d.model.Title;
\layout LyX-Code

import com.u2d.type.atom.StringEO;
\layout LyX-Code

import com.u2d.type.atom.TextEO;
\layout LyX-Code

\layout LyX-Code

public class Talk extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   private final StringEO title = new StringEO();
\layout LyX-Code

   private final TextEO talkAbstract = new TextEO();
\layout LyX-Code

   private Speaker speaker;
\layout LyX-Code

   public static String speakerInverseFieldName = "talks";
\layout LyX-Code

\layout LyX-Code

   public static String[] fieldOrder = {"title", "talkAbstract", "speaker"};
\layout LyX-Code

\layout LyX-Code

   public Talk() {}
\layout LyX-Code

\layout LyX-Code

   public StringEO getTitle() { return title; }
\layout LyX-Code

   public TextEO getTalkAbstract() { return talkAbstract; }
\layout LyX-Code

   public Speaker getSpeaker() { return speaker; }
\layout LyX-Code

   public void setSpeaker(Speaker speaker)
\layout LyX-Code

   {
\layout LyX-Code

      Speaker oldSpeaker = this.speaker;
\layout LyX-Code

      this.speaker = speaker;
\layout LyX-Code

      firePropertyChange("speaker", oldSpeaker, this.speaker);
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

   public Title title() { return title.title(); }
\layout LyX-Code

}
\layout Standard

A talk has a title, an abstract, and a reference to its speaker.
 We see again that to-one associations use the JavaBeans bound property
 conventions and fire an event when they're set.
\layout Subsection

The Room Class
\layout Standard

Here is the implementation:
\layout LyX-Code

package com.u2d.sympster;
\layout LyX-Code

\layout LyX-Code

import com.u2d.model.AbstractComplexEObject;
\layout LyX-Code

import com.u2d.model.Title;
\layout LyX-Code

import com.u2d.type.atom.StringEO;
\layout LyX-Code

\layout LyX-Code

public class Room extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   private final StringEO name = new StringEO();
\layout LyX-Code

\layout LyX-Code

   public Room() {}
\layout LyX-Code

\layout LyX-Code

   public StringEO getName() { return name; }
\layout LyX-Code

   public Title title() { return name.title(); }
\layout LyX-Code

}
\layout Standard

Nothing new here.
\layout Subsection

The Session Class
\layout Standard


\emph on 
Session
\emph default 
 is a little more interesting, as it acts as an association class relating
 talks in specific rooms or locations:
\layout LyX-Code

package com.u2d.sympster;
\layout LyX-Code

\layout LyX-Code

import com.u2d.model.AbstractComplexEObject;
\layout LyX-Code

import com.u2d.model.Title;
\layout LyX-Code

import com.u2d.type.atom.TimeSpan;
\layout LyX-Code

\layout LyX-Code

public class Session extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   private final TimeSpan time = new TimeSpan();
\layout LyX-Code

   private Talk talk;
\layout LyX-Code

   private Room location;
\layout LyX-Code

\layout LyX-Code

   public static String[] fieldOrder = {"talk", "time", "location"};
\layout LyX-Code

\layout LyX-Code

   public Session() {}
\layout LyX-Code

\layout LyX-Code

   public TimeSpan getTime() { return time; }
\layout LyX-Code

\layout LyX-Code

   public Talk getTalk() { return talk; }
\layout LyX-Code

   public void setTalk(Talk talk)
\layout LyX-Code

   {
\layout LyX-Code

      Talk oldTalk = this.talk;
\layout LyX-Code

      this.talk = talk;
\layout LyX-Code

      firePropertyChange("talk", oldTalk, this.talk);
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

   public Room getLocation() { return location; }
\layout LyX-Code

   public void setLocation(Room location)
\layout LyX-Code

   {
\layout LyX-Code

      Room oldLocation = this.location;
\layout LyX-Code

      this.location = location;
\layout LyX-Code

      firePropertyChange("location", oldLocation, this.location);
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

   public Title title()
\layout LyX-Code

   {
\layout LyX-Code

      return time.title().append(":", talk).append(" in", location);
\layout LyX-Code

   }
\layout LyX-Code

}
\layout Standard

Again, very little new here.
 We have three fields: the talk, the location, and the time span.
 
\emph on 
TimeSpan
\emph default 
 is yet another basic type provided by the framework.
 It's a combination of a date-time field and a duration.
 You can also think of a time span as having both a start time and end time
 fields.
 Actually, this is how its default renderer and editor depict it.
\layout Standard

The 
\emph on 
title()
\emph default 
 method is also somewhat interesting as it attempts to concatenate the time
 span along with the talk's title and location title.
\layout Subsection

A First Look
\layout Standard

I realize that I've been rushing through this a little.
 We could have easily written one class at a time and each time ran our
 application, thus building our application more incrementally.
 This in fact is a very good practice and a highly recommended one.
 Feel free not to follow me to the letter here.
\layout Standard

Let's take our first-draft for a spin:
\layout LyX-Code

ant schema-export
\layout LyX-Code

ant run
\layout Standard

Log in using the 
\emph on 
admin
\emph default 
/
\emph on 
admin
\emph default 
 credentials and you should see a screen similar to figure 
\begin_inset LatexCommand \ref{cap:Conf-Mgr-Firstlook}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/NFJS-1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

First Look at our Conference Manager
\begin_inset LatexCommand \label{cap:Conf-Mgr-Firstlook}

\end_inset 


\end_inset 


\layout Standard

Let's go ahead and exercise our objects a little.
 Go ahead and create a Symposium, give it a name and save it.
 Similarly, create a room.
 Then go ahead and create a speaker and assign him or her a photo.
 Since a speaker has a list of talks, you can create and associate a talk
 to your speaker very simply by clicking the plus (+) icon, which is a popup
 menu, and selecting the 
\emph on 
New
\emph default 
 action, and then entering the information about the talk.
 The association will be made for you automatically.
 Alternatively, you can create a talk separately and then drag and drop
 the talk onto the speaker's talks listing.
 Figure 
\begin_inset LatexCommand \ref{cap:Speaker-Talk}

\end_inset 

 is a snapshot of my screen after creating a speaker and a talk.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/NFJS-2.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

A Speaker and Associated Talk
\begin_inset LatexCommand \label{cap:Speaker-Talk}

\end_inset 


\end_inset 


\layout Standard

Now that we have created a talk and a room, go ahead and create a session
 object.
 The timespan can be edited by specifying the date and start and end times.
 Notice that the date editor provides a date picker to facilitate entry.
 The time editors likewise attempt to facilitate entry by providing small
 spinner arrows for incrementing and decrementing the hour and minute fields.
 To associate a talk and a room, again you have two choices:
\layout Enumerate

Drop a talk onto the talk field of the session object (and similarly for
 the location field, drop a room object), or
\layout Enumerate

Right-click 
\emph on 
Browse
\emph default 
, 
\emph on 
Find
\emph default 
, or 
\emph on 
New
\emph default 
 to browse and select an existing talk to associate to this session, to
 query for and select a talk, or to create a new talk and then associate
 it to the session in question
\layout Standard

Here is a snapshot of my screen after creating and setting a session:
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/NFJS-3.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

Creating and associating a Session
\end_inset 


\layout Section

Enhancements
\layout Standard

Let's get back to our code and make a few additions, enhancements.
\layout Subsection

Type Color Coding
\layout Standard

Here's a useful piece of metadata to help distinguish between different
 types of objects in our system: color-coding.
 Here's an example of how to specify this metadata:
\layout LyX-Code

   public static Color colorCode = new Color(0xffff00);
\layout Standard

Just add the above line to any of your model classes (Room, Talk, Speaker,
 and so on) using a different color value for each, of course.
 The titlebar for each object will automatically be painted with a gradient
 background that starts with the specified color.
 Also, type listings paint the background color of alternating lines using
 that color code combined with a semi-transparent alpha value.
 This should help users quickly distinguish various listings or types of
 objects in your user interface.
\layout Subsection

Speaker's Photo for Speaker Icon
\layout Standard

We have a nice little icon representing a speaker.
 However, we have an even nicer one, and one that could help distinguish
 between speakers: their photo.
 Can't we simply use the speaker's photo as the basis for that instance's
 icon? Certainly.
 Here's the magic bit of code:
\layout LyX-Code

private transient PhotoIconAssistant assistant = 
\layout LyX-Code

                        new PhotoIconAssistant(this, photo);
\layout LyX-Code

public Icon iconLg() { return assistant.iconLg(); }
\layout LyX-Code

public Icon iconSm() { return assistant.iconSm(); }
\layout Standard

JMatter provides a class named 
\emph on 
PhotoIconAssistant
\emph default 
 that you simply instantiate, passing in a reference to the containing object,
 and to the photo field in question.
 Then simply override the superclass's 
\emph on 
iconLg()
\emph default 
 and 
\emph on 
iconSm()
\emph default 
 methods and delegate the work to your assistant.
 Pretty simple.
\layout Subsection

A Second Look
\layout Standard

Let's check out our application with the changes in place.
\layout LyX-Code

ant run
\layout Standard

I went ahead and created a few 
\emph on 
Speaker
\emph default 
 instances so we'd have something to look at.
 Figure 
\begin_inset LatexCommand \ref{cap:Speaker-Icon-using}

\end_inset 

 shows two views of the speakers' listing along with a maximized view of
 Jason Hunter, a long-time NFJS speaker.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/NFJS-4.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

Speaker Icon using Photo Property
\begin_inset LatexCommand \label{cap:Speaker-Icon-using}

\end_inset 


\end_inset 


\layout Standard

By opening other listings and other types of instances we can also quickly
 see the color-coding in effect.
 These are small, nice, and valued enhancements to our user interface.
\layout Section

Calendaring
\layout Standard

One of the main tasks of managing conferences (or symposia, as they're called
 here) is scheduling them, determining what sessions will be offered: where
 and when talks are to be given.
\layout Standard

What will it take to build these features into our application? Let's begin
 by studying the way JMatter models calendaring.
\layout Subsection

How JMatter Models Calendaring
\layout Standard

The JMatter framework defines three main types of objects that work together
 to provide calendaring features:
\layout Enumerate

Calendar Events
\newline 
These are basically items that one puts on a calendar.
 A meeting is a calendar event, for example.
 A visit between a physician and a patient is another example.
 Here's a third example: a session at a conference.
\layout Enumerate

Resources, or Schedulables
\newline 
As its name implies, a Resource is something that can be occupied or consumed
 for a span of time.
 In our example, a room where a presentation is given is a resource.
 In the code, JMatter calls them schedulables.
 In a physician's clinic, the physician becomes the resource.
\layout Enumerate

Grouping of Resources, or Calendarables
\newline 
Finally, it's important to get a view of how multiple resources are utilitized
 in time.
 We'd like to be able to see what sessions are going on at the same time
 in six different rooms, so we can pick which presentation we want to attend,
 for example.
 A nurse would like to see which physicians are available during a specific
 block of time, and so on.
\layout Standard

So in our system, the Calendar Events are our Sessions, the resource is
 the Room, and finally our Calendarable is the Symposium.
 We can have many symposia and so each one will have its own calendar.
 Each room will have its own schedule.
\layout Standard

Technically, we need to extend our model to make this work in the field:
 symposia can take place in different venues.
 One could take place at a hotel in New York City, another at a convention
 center in San Francisco, and a third could be taking place at a university
 campus in Austin.
 Each venue would then have its own list of rooms where presentations are
 held.
\layout Standard

For now we're going to keep the venue constant.
 We'll extend the model to support multiple types of venues in section 
\begin_inset LatexCommand \ref{sec:Polymorphism}

\end_inset 

.
\layout Standard

JMatter's calendaring model can be found in the package 
\emph on 
com.u2d.calendar
\layout Subsection

Enhancing Sympster to Support Calendaring
\layout Standard

Ok, let's get to the code.
 Here is the simplest way to introduce calendaring to our application.
 Now that we've identified the relative roles of Session, Room, and Symposium
 and how they map to JMatter's model for calendaring, we can proceed to
 enhance our code base.
 Let's start with 
\emph on 
Session
\emph default 
.
\layout Subsubsection

Enhancing Session
\layout Standard

We need to:
\layout Enumerate

make session a subclass of 
\emph on 
CalEvent;
\layout Enumerate

implement the contract for 
\emph on 
CalEvent.
\layout Standard

The first revision is easy:
\layout LyX-Code

public class Session extends CalEvent
\layout Standard

The second is pretty easy too:
\layout LyX-Code

   public static String timespanFieldname = "time";
\layout LyX-Code

   public static String schedulableFieldname = "location";
\layout LyX-Code

   public Title calTitle()
\layout LyX-Code

   {
\layout LyX-Code

      if (talk == null)
\layout LyX-Code

         return new Title("--");
\layout LyX-Code

      else
\layout LyX-Code

         return talk.title();
\layout LyX-Code

   }
\layout Standard

We're required to provide the name of the field in the class 
\emph on 
Session
\emph default 
 that corresponds to its timespan, so that JMatter knows how to display
 sessions in a calendar or a schedule widget.
 The name of this field happens to be 
\emph on 
time
\emph default 
.
 Likewise, our calendar will display calendar events for different resources,
 so we also need to provide the name of the schedulable field on Session:
 
\emph on 
location
\emph default 
.
\layout Standard

The third requirement, the 
\emph on 
calTitle()
\emph default 
 method could have been made optional but it is required by JMatter at the
 moment.
 It gives you a chance to specify a title for a Session object that is more
 appropriate in the context of a calendar.
 For example, the calendar will make obvious the time and duration and location
 of the session, so you might not want to repeat that information redundantly
 in the title.
 In this case, we specify the talk's title as the calendar-context title
 for 
\emph on 
Session
\emph default 
.
\layout Standard

That's it for 
\emph on 
Session
\emph default 
.
 Let's look at 
\emph on 
Room
\emph default 
 next.
\layout Subsubsection

Enhancing Room
\layout Standard

We need to:
\layout Enumerate

make Room a subclass of 
\emph on 
ScheduleEO;
\layout Enumerate

implement the contract for 
\emph on 
ScheduleEO.
\layout Standard

Here they are:
\layout LyX-Code

public class Room extends ScheduleEO
\layout Standard

And:
\layout LyX-Code

public Class eventType() { return Session.class; }
\layout Standard

Pretty easy? We specify that events in Rooms are of type 
\emph on 
Session
\emph default 
.
\layout Subsubsection

Enhancing Symposium
\layout Standard

Here again, we need to:
\layout Enumerate

make Symposium a subclass of CalendarEO;
\layout Enumerate

implement the contract for CalendarEO.
\layout Standard

The first change:
\layout LyX-Code

public class Symposium extends CalendarEO
\layout Standard

And for the second, add this code:
\layout LyX-Code

public AbstractListEO schedulables()
\layout LyX-Code

{
\layout LyX-Code

   return ComplexType.forClass(Room.class).list();
\layout LyX-Code

}
\layout LyX-Code

public Class defaultCalEventType() { return Session.class; }
\layout Standard

We need to implement the method schedulables(), which returns a list of
 all the resources that this calendar maintains.
 If each symposium had its own venue, the implementation would simply have
 been:
\layout LyX-Code

return getVenue().getRooms();
\layout Standard

In our case, we decided to keep our venu constant so we return the entire
 list of rooms.
\layout Standard

The second requirement is to provide the default calendar event type, which
 again is Session.
\layout Standard

That's it.
 We're done.
\layout Subsection

A Third Look
\layout Standard

Let's look at what we get in return for our efforts.
\layout LyX-Code

ant run
\layout Standard

Browse the list of symposia you created and right-click the command 
\emph on 
Show Calendar
\emph default 
.
 This command was inherited by 
\emph on 
CalendarEO
\emph default 
.
 We see a calendar widget, similar to the one shown in figure 
\begin_inset LatexCommand \ref{cap:Symposium-Calendar}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/NFJS-5.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

Symposium Calendar, along with a few Sessions
\begin_inset LatexCommand \label{cap:Symposium-Calendar}

\end_inset 


\end_inset 


\layout Standard

Feel free to explore this widget.
 It has a few useful features:
\layout Enumerate

A week view and a day view
\layout Enumerate

The ability to view the calendar using a time resolution of 15 minutes,
 30 minutes, or 60 minutes per row
\layout Enumerate

The ability to navigate to the next day or week by clicking on the navigation
 arrows (in day view, you'll be navigating to the next or previous day,
 in week view, you'll be navigating to the next or previous week)
\layout Enumerate

A mini month calendar, for quickly navigating to a specific date in another
 month or year
\layout Enumerate

A date navigation text field, to quickly navigate to a specific date by
 simply entering it and pressing enter (e.g.
 10212004 will take you to Oct 21 2004)
\layout Enumerate

The ability to toggle any schedule on or off the calendar
\layout Enumerate

You can create a new session at a specific time and location by double-clicking
 on a cell in day view
\layout Enumerate

You can create a new session at a specific time and location, with a specific
 talk by simply dropping a talk onto a cell in day view
\layout Enumerate

You can alter the default session duration by right-clicking on the Session
 class's (in the class bar) 
\emph on 
Set Default Duration Hrs
\emph default 
 command.
\layout Enumerate

You can alter the time or location of a session by simply dragging it onto
 another cell
\layout Enumerate

You can open an existing session by double clicking on its representation's
 titlebar in the calendar
\layout Enumerate

You can invoke any commands on a session displayed in the calendar by right-clic
king on its titlebar
\layout Standard

I think you'll agree that here again, JMatter provides tremendous leverage.
 The designers of the JMatter framework are reusing this calendar across
 different applications that span entirely different business domains.
 As the features of this calendar improve, all JMatter applications will
 inherit these improvements.
\layout Subsection

Inheritance vs Interfaces
\layout Standard

In order to gain the benefits of calendaring, we had to extend existing
 classes in our system.
 Luckily, our Session, Room, and Symposium did not already extend another
 base class.
 Designing by inheritance has its problems in a world where multiple inheritance
 is not supported.
 But you don't have to be locked in to it.
\layout Standard

It turns out that JMatter does not require that you extend ScheduleEO or
 CalendarEO to obtain these benefits.
 You can implement the 
\emph on 
Calendarable
\emph default 
 and 
\emph on 
Schedulable
\emph default 
 interfaces directly yourself and they really don't require that much effort.
 Have a look at the source code for 
\emph on 
CalendarEO
\emph default 
 and 
\emph on 
ScheduleEO
\emph default 
.
 They do very little indeed.
 All they do is instantiate a 
\emph on 
Calendar
\emph default 
 and 
\emph on 
Schedule
\emph default 
 object respectively, and expose an accessor method on it.
 That's basically it.
\layout Standard

At the moment, the same cannot be said about a 
\emph on 
CalEvent
\emph default 
.
 We are required to subclass 
\emph on 
CalEvent
\emph default 
.
 As we refine jMatter's calendaring feature further, we expect this requirement
 to be removed.
\layout Section

Polymorphism
\begin_inset LatexCommand \label{sec:Polymorphism}

\end_inset 


\layout Standard

Let's discuss how we would revise our application to accomodate symposia
 with different venues:
\layout Enumerate

Define a new field on Symposium called 
\emph on 
venue
\newline 

\emph default 
The goal is for a venue to be a base type for mutliple specializations,
 such as a Hotel, a Conference Center, or a Campus (each of these three
 would be concrete implementations of a 
\emph on 
Venue
\emph default 
)
\layout Enumerate

Define the base type Venue
\newline 
At the very least, a venue should have a name and a list of rooms.
 So 
\emph on 
Venue
\emph default 
 would likely include two methods: 
\emph on 
getName()
\emph default 
 and 
\emph on 
getRooms()
\layout Enumerate

Revise the implementation of 
\emph on 
Symposium.schedulables()
\emph default 
 to return 
\emph on 
venue.getRooms()
\layout Enumerate

Add 
\emph on 
Venue, Hotel, ConferenceCenter, 
\emph default 
and
\emph on 
 Campus
\emph default 
 to our app-config file (followed by an 
\emph on 
ant schema-update
\emph default 
)
\layout Enumerate

Possibly add one or more of these new types to one of our Class Bar subfolders
 (edit the Class Bar directly from the GUI)
\layout Standard

This particular situation lends itself nicely to implementing polymorphism
 via inheritance.
 Here's what 
\emph on 
Venue
\emph default 
 might look like:
\layout LyX-Code

public abstract class Venue extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   protected final StringEO name = new StringEO();
\layout LyX-Code

   protected final RelationalList rooms = new RelationalList(Room.class);
\layout LyX-Code

   public static Class roomsType = Room.class;
\layout LyX-Code

   
\layout LyX-Code

   public StringEO getName() { return name; }
\layout LyX-Code

   public RelationalList getRooms() { return rooms; }
\layout LyX-Code

   public Title title() { return name.title(); }
\layout LyX-Code

}
\layout Standard

Pretty simple really.
 We can now extend Venue for 
\emph on 
Hotel
\emph default 
, 
\emph on 
Campus
\emph default 
, and 
\emph on 
ConferenceCenter
\emph default 
.
 Here is 
\emph on 
Hotel
\emph default 
:
\layout LyX-Code

public class Hotel extends Venue
\layout LyX-Code

{
\layout LyX-Code

   public Hotel() {}
\layout LyX-Code

}
\layout Standard


\emph on 
Hotel
\emph default 
 is ready to be extended with specialized behaviours.
 We can similarly define 
\emph on 
Campus
\emph default 
 and 
\emph on 
ConferenceCenter
\emph default 
.
 We can distinguish these three types by the icon we choose to represent
 each type.
\layout Standard

We also need to add these four types to our 
\emph on 
app-config.xml
\emph default 
 file:
\layout LyX-Code

      <class>com.u2d.sympster.Venue</class>
\layout LyX-Code

      <class>com.u2d.sympster.Hotel</class>
\layout LyX-Code

      <class>com.u2d.sympster.Campus</class>
\layout LyX-Code

      <class>com.u2d.sympster.ConferenceCenter</class>
\layout Standard

Finally, here are the changes I've made to 
\emph on 
Symposium
\emph default 
:
\layout LyX-Code

   private Venue venue;
\layout LyX-Code

   public Venue getVenue() { return venue; }
\layout LyX-Code

   public void setVenue(Venue venue)
\layout LyX-Code

   {
\layout LyX-Code

      Venue oldVenue = this.venue;
\layout LyX-Code

      this.venue = venue;
\layout LyX-Code

      firePropertyChange("venue", oldVenue, this.venue);
\layout LyX-Code

   }
\layout LyX-Code

   public AbstractListEO schedulables()
\layout LyX-Code

   {
\layout LyX-Code

      // return ComplexType.forClass(Room.class).list();
\layout LyX-Code

      return venue.getRooms();
\layout LyX-Code

   }
\layout Standard

We need to synchronize our database to the model changes we've made:
\layout LyX-Code

ant schema-update
\layout Standard

In this particular case, JMatter generates hibernate mapping files using
 the joined subclass inheritance mapping strategy.
\layout Standard

And we should be ready to check out our application:
\layout LyX-Code

ant run
\layout Standard

I added 
\emph on 
Venue
\emph default 
 to the class list.
 Remember that 
\emph on 
Venue
\emph default 
 is an abstract base type.
 Figure 
\begin_inset LatexCommand \ref{cap:Sympster-Polymorphic}

\end_inset 

 shows two things:
\layout Enumerate

Right-clicking 
\emph on 
Browse
\emph default 
 on 
\emph on 
Venues
\emph default 
 in the Class Bar will perform a polymorphic query and return a listing
 including hotels, campuses, and conference centers.
\layout Enumerate

Right-clicking 
\emph on 
New
\emph default 
 on Venues will prompt the user to select which concrete type they would
 like to instantiate.
 This is baked in to the user interface.
 When associating a venue to a symposium, right-clicking 
\emph on 
New
\emph default 
, 
\emph on 
Browse
\emph default 
, or 
\emph on 
Find
\emph default 
 on the symposium's venue association field will do the right thing.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/NFJS-6.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

Sympster Extended with Venues
\begin_inset LatexCommand \label{cap:Sympster-Polymorphic}

\end_inset 


\end_inset 


\layout Section

Summary
\layout Standard

I hope you enjoyed this chapter.
 We didn't have to work too hard and yet we developed a fully-functional
 conference manager.
\layout Standard

In summary, new features of JMatter covered in this chapter include: type
 color coding, using an image field as the basis for an instance's icon,
 calendaring, and polymorphic modeling.
\layout Standard

Let's do our due diligence once again and get a measure of the amount of
 leverage we got out of JMatter in this application:
\layout LyX-Code

eitan@ubuntu:~/projects/ds/Sympster/src/com/u2d/sympster$ wc -l *.java
\layout LyX-Code

   7 Campus.java
\layout LyX-Code

   6 ConferenceCenter.java
\layout LyX-Code

   6 Hotel.java
\layout LyX-Code

  21 Room.java
\layout LyX-Code

  51 Session.java
\layout LyX-Code

  41 Speaker.java
\layout LyX-Code

  40 Symposium.java
\layout LyX-Code

  32 Talk.java
\layout LyX-Code

  19 Venue.java
\layout LyX-Code

 223 total
\layout Standard

Not bad.
 If you're not convinced by now of the implications of this new mode of
 developing software, this might be a good time to pick up another book
 :-).
\layout Standard

In the next chapter we're finally going to take a look at the Issue Manager
 demo application, the one I boasted about in the introduction.
 We'll be focusing on JMatter's support for objects with lifecycles.
\layout Chapter

Issue Manager
\begin_inset LatexCommand \label{cha:Issue-Manager}

\end_inset 


\layout Standard

In this chapter, we're going to discuss JMatter's support for business objects
 with lifecycles.
 We're going to write an Issue Manager, a familiar application for software
 developers who use such systems to help manage the development of software.
 Examples of issue managers include Bugzilla, Trac, and JIRA.
\layout Section

Analysis
\layout Standard

The central type in this application is the 
\emph on 
Issue
\emph default 
.
 The interesting aspect of issues is that they do have a life cycle.
 Issues are created and assigned to developers.
 Developers accept the issue and begin working on a fix.
 After resolving the issue, the person who opened the issue verifies that
 the resolution is indeed satisfactory, and proceeds to close the issue.
 If the issue is not resolved to satisfaction, the issue can be reopened.
\layout Standard

It's also important to keep some kind of trail of activity: who opened the
 issue? Who resolved it and when? An end user should have the ability to
 attach notes to an issue, to specify a description of the issue, steps
 to reproduce the problem (if applicable).
\layout Standard

The main trait of objects with life cycles is that their behaviour depends
 on their state.
 For example, one cannot attempt to 
\emph on 
accept
\emph default 
 an issue if it's already been closed.
 We can identify the various states for an 
\emph on 
Issue
\emph default 
, and define its lifecycle with the aid of state diagrams, transition tables,
 etc..
 Software developers will typically model such objects using the 
\emph on 
State Design Pattern
\emph default 

\begin_inset Foot
collapsed true

\layout Standard

The State Pattern is documented by the 
\emph on 
Gang of Four
\emph default 
 in their book, 
\emph on 
Design Patterns
\end_inset 

.
\layout Standard

I have decided to model an Issue with five states:
\layout Enumerate

New
\layout Enumerate

Assigned
\layout Enumerate

Accepted
\layout Enumerate

Fixed
\layout Enumerate

Closed
\layout Standard

In a normal flow, an issue moves sequentially through these states.
 An issue is created (
\emph on 
New
\emph default 
 state), then assigned to a developer (
\emph on 
Assigned
\emph default 
 state), and accepted by the developer (
\emph on 
Accepted
\emph default 
 state).
 The person who opened the issue has the option of rejecting the fix (in
 which case its state reverts to 
\emph on 
Accepted
\emph default 
) or approving it, moving 
\emph on 
Issue
\emph default 
 to the 
\emph on 
Closed
\emph default 
 state.
 An issue can also be reassigned to a different developer.
\layout Subsection

Modeling States in Java
\layout Standard

In Java, the State pattern is often and conveniently modeled using inner
 classes.
 Each state is implemented as an inner class which controls the behaviour
 of the 
\emph on 
Context
\emph default 
 object (in this case, 
\emph on 
Issue
\emph default 
) when in that state.
 Also, many texts encourage the design to use static inner classes for improving
 the performance of the system.
 That is, rather than create an instance of each inner class per Issue,
 a single instance of each inner class exists for all issues.
 The issue that is to be operated upon is passed in as an argument to that
 inner class's methods.
\layout Standard

Although there's no denying the improvement in memory requirements, I personally
 find this design less than ideal, from an object-oriented point of view.
 I find it akin to removing the implicit 
\emph on 
this
\emph default 
 keyword in instances and passing a reference to 
\emph on 
self
\emph default 
 with each method.
\layout Section

Getting Started
\layout Standard

We're about to start building our fourth application.
 Since we've done this together three times already, I'm not going to walk
 you through the steps of creating a new project, creating a database, entering
 the database connection information, etc..
 Please refer to previous chapters for specific instructions.
 I named my application 
\emph on 
IssueMgr
\emph default 
.
\layout Standard

Ok, we need to model 
\emph on 
Issue
\emph default 
.
 As a first pass, let's not worry right away about the various states we
 identified in the previous section.
 Let's instead start be defining the various properties we want an issue
 to have.
 Here are the properties I've come up with:
\layout LyX-Code

   private final StringEO _title = new StringEO();
\layout LyX-Code

   private final TextEO _description = new TextEO();
\layout LyX-Code

   
\layout LyX-Code

   // a loose definition for these (using a numeric value instead of an
 enumeration).
\layout LyX-Code

   private final IntEO _priority = new IntEO();
\layout LyX-Code

   private final IntEO _severity = new IntEO();
\layout LyX-Code

   
\layout LyX-Code

   private Issue _dependsOn;
\layout LyX-Code

   
\layout LyX-Code

   private final RelationalList _notes = new RelationalList(Note.class);
\layout LyX-Code

   public static Class notesType = Note.class;
\layout LyX-Code

\layout LyX-Code

   private User _openedBy;
\layout LyX-Code

   private User _assignedTo;
\layout LyX-Code

\layout LyX-Code

   private final RelationalList _history = new RelationalList(LoggedEvent.class);
\layout LyX-Code

   public static Class historyType = LoggedEvent.class;
\layout Standard

An issue then will have a title and a detailed description.
 Note how the description field is defined as a TextEO which causes it to
 be rendered using a text area, and saved as in the database as a large
 text type.
 I've decided for a first-pass to keep severity and priority really simple,
 as numeric values.
 The next one: 
\emph on 
dependsOn
\emph default 
 is interesting and fairly self-explanatory.
 It will give us the knowledge that Issue A will not be resolved before
 the issue it depends on (say Issue B) is resolved, for example.
\layout Standard

The next field, 
\emph on 
notes
\emph default 
, will allow us to tack on notes to an issue (as many notes as we want in
 fact).
 A 
\emph on 
Note
\emph default 
 is yet another predefined type in JMatter.
 It has a subject, a time stamp, an author, and the note text itself.
 When creating a note, the author is automatically assigned to the user
 who is currently logged in.
\layout Standard

The next two fields, 
\emph on 
openedBy
\emph default 
 and 
\emph on 
assignedTo
\emph default 
 are self-explanatory.
 The last field is an interesting one.
 The idea is that I'd like to keep track of the history of an issue: when
 was it opened, assigned, accepted, fixed, etc..
 Furthermore, when an issue is fixed, i want to require the developer to
 enter both a summary description of the fix and a lengthier one.
 I want to capture that information.
\layout Standard

After thinking about this for a little while, I realized that JMatter's
 built-in 
\emph on 
LoggedEvent
\emph default 
 type would be a perfect candidate for recording this information.
 It's already designed to hold precisely this type of information.
 It has a timestamp, a message, long message, it records the user who performed
 the action, it can even record what action was performed, and finally,
 has an association back to the object upon which the operation was performed.
 In the context of the issue manager, we'll be able to navigate from a log
 entry (with message 
\emph on 
Issue fixed at 4:30 pm
\emph default 
) back to the issue it is associated to.
\layout Standard

Ok, it looks like we have a fairly complete list of fields to start with.
 Of course, it's not enough to just define these fields, the JMatter conventions
 must be followed: define accessor methods for aggregate types and both
 accessors and mutators for association types, following the JavaBeans bound
 property convention.
\layout LyX-Code

   public StringEO getTitle() { return _title; }
\layout LyX-Code

   public TextEO getDescription() { return _description; }
\layout LyX-Code

\layout LyX-Code

   public IntEO getPriority() { return _priority; }
\layout LyX-Code

   public IntEO getSeverity() { return _severity; }
\layout LyX-Code

\layout LyX-Code

   public Issue getDependsOn() { return _dependsOn; }
\layout LyX-Code

   public void setDependsOn(Issue issue)
\layout LyX-Code

   {
\layout LyX-Code

      Issue oldValue = _dependsOn;
\layout LyX-Code

      _dependsOn = issue;
\layout LyX-Code

      firePropertyChange("dependsOn", oldValue, _dependsOn);
\layout LyX-Code

   }
\layout LyX-Code

  
\layout LyX-Code

   public RelationalList getNotes() { return _notes; }
\layout LyX-Code

\layout LyX-Code

   public User getOpenedBy() { return _openedBy; }
\layout LyX-Code

   public void setOpenedBy(User user)
\layout LyX-Code

   {
\layout LyX-Code

      User oldValue = _openedBy;
\layout LyX-Code

      _openedBy = user;
\layout LyX-Code

      firePropertyChange("openedBy", oldValue, _openedBy);
\layout LyX-Code

   }
\layout LyX-Code

   
\layout LyX-Code

   public User getAssignedTo() { return _assignedTo; }
\layout LyX-Code

   public void setAssignedTo(User user)
\layout LyX-Code

   {
\layout LyX-Code

      User oldValue = _assignedTo;
\layout LyX-Code

      _assignedTo = user;
\layout LyX-Code

      firePropertyChange("assignedTo", oldValue, _assignedTo);
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

   public RelationalList getHistory() { return _history; }
\layout Standard

I need to show you the context within which all this code is written:
\layout LyX-Code

public class Issue extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   public static String[] fieldOrder = {"title", "description", "notes",
\layout LyX-Code

         "openedBy", "assignedTo", "history", "severity", "priority"};
\layout LyX-Code

\layout LyX-Code

   public Issue() {}
\layout LyX-Code

\layout LyX-Code

   public Title title()
\layout LyX-Code

   {
\layout LyX-Code

      return _title.title().appendParens(""+getID());
\layout LyX-Code

   }
\layout LyX-Code

}
\layout Standard

We added the familiar 
\emph on 
fieldOrder
\emph default 
 metadata and the required 
\emph on 
title()
\emph default 
 method.
 Since it is customary to refer to issues by some unique numeric ID, I'm
 exposing the issue's ID property in its title.
 This property is inherited from 
\emph on 
AbstractComplexEObject
\emph default 
.
\layout Standard

If you like, you're welcome to go ahead and add 
\emph on 
Issue
\emph default 
 to our 
\emph on 
app-config
\emph default 
 file, export the schema, run the application and create a few issues.
\layout Section

Modeling Issues' LifeCycle
\layout Standard

The time has come to model issues' lifecycle.
\layout Standard

There are a number of concerns here.
 The first is keeping track of the state of our issue.
 And more specifically, to ensure that when an issue is persisted to the
 database, that its state is remembered and properly restored at a later
 point in time.
\layout Standard

A simple way to do this is to define yet another field to hold the name
 of the state.
 This field will be persisted to the database just like 
\emph on 
Issue
\emph default 
's other fields, and can be the basis for restoring Issues' state when reloading
 issues from the database.
\layout LyX-Code

   private final IssueState _status = new IssueState(NEW);
\layout Standard

Where 
\emph on 
NEW
\emph default 
 is one of a number of static string-based constants:
\layout LyX-Code

   static final String NEW = "New";
\layout LyX-Code

   static final String ASSIGNED = "Assigned";
\layout LyX-Code

   static final String ACCEPTED = "Accepted";
\layout LyX-Code

   static final String FIXED = "Fixed";
\layout LyX-Code

   static final String CLOSED = "Closed";
\layout Standard

We have identified five states and they're not likely to change.
 JMatter provides a mechanism for modeling enumerations by extending the
 JMatter type 
\emph on 
ChoiceEO
\emph default 
.
 Here is the implementaiton of the contract to define the 
\emph on 
IssueState
\emph default 
 enumeration:
\layout LyX-Code

public class IssueState extends ChoiceEO
\layout LyX-Code

{
\layout LyX-Code

   public IssueState() {}
\layout LyX-Code

   public IssueState(String value) { setValue(value); }
\layout LyX-Code

   
\layout LyX-Code

   private static Set STATUS_OPTIONS = new HashSet();
\layout LyX-Code

   static
\layout LyX-Code

   {
\layout LyX-Code

      STATUS_OPTIONS.add(Issue.NEW);
\layout LyX-Code

      STATUS_OPTIONS.add(Issue.ASSIGNED);
\layout LyX-Code

      STATUS_OPTIONS.add(Issue.ACCEPTED);
\layout LyX-Code

      STATUS_OPTIONS.add(Issue.FIXED);
\layout LyX-Code

      STATUS_OPTIONS.add(Issue.CLOSED);
\layout LyX-Code

   }
\layout LyX-Code

   
\layout LyX-Code

   public Collection entries() { return STATUS_OPTIONS; }
\layout LyX-Code

}
\layout Standard

Nothing too interesting really.
 We also must remember to add an accessor method for 
\emph on 
status
\emph default 
:
\layout LyX-Code

   public IssueState getStatus() { return _status; }
\layout Subsection

Defining the State Inner Classes
\layout Standard

Below I've defined five inner classes, one for each of the states that Issue
 can be in.
\layout LyX-Code

   public class NewState extends ReadState {}
\layout LyX-Code

   public class AssignedState extends ReadState
\layout LyX-Code

   {
\layout LyX-Code

      @CommandAt(mnemonic='a')
\layout LyX-Code

      public void Accept(CommandInfo cmdInfo)
\layout LyX-Code

      {
\layout LyX-Code

         transition(_acceptedState, makeLog("Issue accepted by developer"));
\layout LyX-Code

      }
\layout LyX-Code

   }
\layout LyX-Code

   public class AcceptedState extends ReadState
\layout LyX-Code

   {
\layout LyX-Code

      @CommandAt
\layout LyX-Code

      public void Fix(CommandInfo cmdInfo,
\layout LyX-Code

                      @ParamAt("Fix") StringEO fix,
\layout LyX-Code

                      @ParamAt("Description") TextEO description)
\layout LyX-Code

      {
\layout LyX-Code

         transition(_fixedState, makeLog("Fix: "+fix.stringValue(), description))
;
\layout LyX-Code

      }
\layout LyX-Code

   }
\layout LyX-Code

   public class FixedState extends ReadState
\layout LyX-Code

   {
\layout LyX-Code

      @CommandAt
\layout LyX-Code

      public void RejectFix(CommandInfo cmdInfo,
\layout LyX-Code

                            @ParamAt("Explanation") TextEO explanation)
\layout LyX-Code

      {
\layout LyX-Code

         transition(_acceptedState, makeLog("Fix rejected", explanation));
\layout LyX-Code

      }
\layout LyX-Code

      @CommandAt
\layout LyX-Code

      public void Close(CommandInfo cmdInfo,
\layout LyX-Code

                        @ParamAt("Explanation") TextEO explanation)
\layout LyX-Code

      {
\layout LyX-Code

         transition(_closedState, makeLog("Issue Closed", explanation));
\layout LyX-Code

      }
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

   public class ClosedState extends ReadState {}
\layout Standard

Notice that the convention for defining commands on these states is the
 same as the mechanism used for defining commands in general.
 The difference is that JMatter will ensure that these commands are accessible
 in a valid state.
\layout Standard

Although we've defined the classes, we must also create an instance for
 each:
\layout LyX-Code

   private transient final State _newState, _assignedState, _acceptedState,
\layout LyX-Code

         _fixedState, _closedState;
\layout LyX-Code

   {
\layout LyX-Code

      _newState = new NewState();
\layout LyX-Code

      _assignedState = new AssignedState();
\layout LyX-Code

      _acceptedState = new AcceptedState();
\layout LyX-Code

      _fixedState = new FixedState();
\layout LyX-Code

      _closedState = new ClosedState();
\layout LyX-Code

      _stateMap.put(_newState.getName(), _newState);
\layout LyX-Code

      _stateMap.put(_assignedState.getName(), _assignedState);
\layout LyX-Code

      _stateMap.put(_acceptedState.getName(), _acceptedState);
\layout LyX-Code

      _stateMap.put(_fixedState.getName(), _fixedState);
\layout LyX-Code

      _stateMap.put(_closedState.getName(), _closedState);
\layout LyX-Code

   }
\layout Standard

In addition to instantiation, I've also added each state to a map, defined
 in Issue's superclass.
 At the moment, this is a requirement of the framework.
 We haven't yet specified the starting state, so let's do that:
\layout LyX-Code

public State startState() { return _newState; }
\layout Standard

We also need to provide a mechanism for the Issue's state to be restored
 after an issue is fetched from the database:
\layout LyX-Code

public State restoredState()
\layout LyX-Code

{ 
\layout LyX-Code

  return (State) _stateMap.get(getStatus().code());
\layout LyX-Code

}
\layout Standard

Both of these are really simple.
 Here we see that we use the value of the issue's status (which was fetched
 from the database) as a means to fetch the state object from the state
 map.
\layout Standard

I have not yet showed you the support code for the transitions.
 In each state where a command is defined a transition takes place.
 A logged event is created and passed in to the method named transition().
 Here's how I create the logged event:
\layout LyX-Code

private LoggedEvent makeLog(String msg)
\layout LyX-Code

{
\layout LyX-Code

   LoggedEvent evt = (LoggedEvent) createInstance(LoggedEvent.class);
\layout LyX-Code

   evt.getMsg().setValue(msg);
\layout LyX-Code

   evt.getType().setValue(LoggedEvent.INFO);
\layout LyX-Code

   evt.setUser(currentUser());
\layout LyX-Code

   evt.setObject(this);
\layout LyX-Code

   return evt;
\layout LyX-Code

}
\layout LyX-Code

private LoggedEvent makeLog(String msg, TextEO longMsg)
\layout LyX-Code

{
\layout LyX-Code

   LoggedEvent evt = makeLog(msg);
\layout LyX-Code

   evt.getLongMsg().setValue(longMsg);
\layout LyX-Code

   return evt;
\layout LyX-Code

}
\layout Standard

I provide two utility methods for constructing logged events.
 The first does not require a long message, the second is an overloaded
 version that also sets the long message.
 Notice how commands such as 
\emph on 
Fix
\emph default 
, 
\emph on 
Close
\emph default 
 and 
\emph on 
RejectFix
\emph default 
 specify arguments.
 Recall that JMatter automagically prompts the end user for these arguments
 in the user interface and then feeds them to the commands when invoking
 their methods.
 These values are then passed in to the 
\emph on 
makeLog()
\emph default 
 methods.
\layout Standard

Finally, here is the implementation of the 
\emph on 
transition()
\emph default 
 method:
\layout LyX-Code

private void transition(State state, LoggedEvent evt)
\layout LyX-Code

{
\layout LyX-Code

   _history.add(evt);
\layout LyX-Code

   setState(state, true);
\layout LyX-Code

   _status.setValue(state.getName());
\layout LyX-Code

   firePropertyChange("icon", null, null);
\layout LyX-Code

   persistor().updateAssociation(this, evt);
\layout LyX-Code

}
\layout Standard

We see here that the logged event is added to the history field, the state
 transition takes place, the status field is updated accordingly (kept in
 sync with the issue's state).
 I'm also firing a property change event.
 This is interesting and deserves further discussion.
\layout Standard

Up until now, you've been told that for each type of object you define in
 JMatter, that JMatter will look for an image file with a specific naming
 convention to use to represent objects of that type.
 This is true, but it's not the whole story.
\layout Standard

Let's take an example.
 For the class 
\emph on 
Issue
\emph default 
, we provide 
\emph on 
Issue32.png
\emph default 
 and 
\emph on 
Issue16.png
\emph default 
.
 However, you're also free to provide additional icons, one for each state:
 
\emph on 
IssueAssigned32.png
\emph default 
, 
\emph on 
IssueAccepted32.png
\emph default 
, etc..
 So we see here an extension of the convention.
 For objects with lifecycles, the icon can be made to further reflect the
 state of the object you're viewing.
 I have specified custom icons for each of Issue's five states.
 Here's (figure 
\begin_inset LatexCommand \ref{cap:State-Specific-Icon-Support}

\end_inset 

) a screenshot of the icons in my 
\emph on 
resources/images
\emph default 
 directory, along with their corresponding file names.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/IssueMgr-1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

State-Specific Icon Support in DoS
\begin_inset LatexCommand \label{cap:State-Specific-Icon-Support}

\end_inset 


\end_inset 


\layout Standard

Firing a propertychange event ensures that the user interface is notified
 that the state of our object has changed and that its icon should be updated.
\layout Standard

Getting back to the implementation of 
\emph on 
transition()
\emph default 
, the final statement ensures that the updated issue and its association
 to the newly created logged event are all saved to the database.
\layout Section

Additional Metadata
\layout Standard

We've defined a number of commands, such as 
\emph on 
Fix(CommandInfo cmdInfo, StringEO fix, TextEO description)
\emph default 
.
 It would be nice if we could customize the captions for the two arguments
 
\emph on 
fix
\emph default 
, and 
\emph on 
description
\emph default 
 so the end user is clear about what information he or she will have to
 enter.
 We do this by annotating the method's arguments with 
\emph on 
@ParamAt
\emph default 
 annotations, as in this example:
\layout LyX-Code

public void Fix(CommandInfo cmdInfo,
\layout LyX-Code

                      @ParamAt("Fix") StringEO fix,
\layout LyX-Code

                      @ParamAt("Description") TextEO description)
\layout Standard

The annotation takes a single argument, the parameter caption.
\layout Standard

There's a second, much more important issue that needs to be addressed though.
 In the case of our issue manager application, it's not enough that the
 command 
\emph on 
accept
\emph default 
 be only accessible in 
\emph on 
Assigned
\emph default 
 state.
 Only the developer who has been assigned the particular issue should be
 allowed to accept the issue.
 The same applies to the 
\emph on 
fix
\emph default 
 command.
 For 
\emph on 
rejectFix
\emph default 
 and 
\emph on 
close
\emph default 
, the same idea applies: only the user who opened the issue should be allowed
 to close it, not the developer.
\layout Standard

JMatter provides a means to specify what user is the 
\emph on 
owner
\emph default 
 of a command.
 A command's owner is the only user who will be allowed to invoke it.
 JMatter will not even display the command's buttons and menu items to any
 other user.
 Here's how this is done:
\layout LyX-Code

static
\layout LyX-Code

{
\layout LyX-Code

   ComplexType type = ComplexType.forClass(Issue.class);
\layout LyX-Code

   type.command("Accept", AssignedState.class).setOwner(type.field("assignedTo"));
\layout LyX-Code

   type.command("Fix", AcceptedState.class).setOwner(type.field("assignedTo"));
\layout LyX-Code

   type.command("RejectFix", FixedState.class).setOwner(type.field("openedBy"));
\layout LyX-Code

   type.command("Close", FixedState.class).setOwner(type.field("openedBy"));
\layout LyX-Code

}
\layout Standard

I hope you'll agree this is fairly terse, yet clear and legible code.
 The last line, for example, interprets to 
\begin_inset Quotes eld
\end_inset 

the owner for the command named 
\emph on 
Close
\emph default 
 (in 
\emph on 
Fixed
\emph default 
 state) is the value of the issue's 
\emph on 
openedBy
\emph default 
 field.
 In otherwords, whoever opened the issue is the one authorized to close
 it.
\layout Section

A Few Loose Ends
\layout Subsection

Default Assigned-To Developer
\layout Standard

It sure would be nice if each time I created a new issue, a certain developer
 would be the default user assigned to the issue.
 One way to do this is to specify the default in the file 
\emph on 
resources/model-metadata.properties
\emph default 
, like this:
\layout LyX-Code

#
\layout LyX-Code

Issue.assignedTo.default=from User as user where user.username='eitan'
\layout Standard

We've already used this file to specify field metadata such as whether and
 which fields are required.
 Here we're specifying a default.
 We can either hard-code it, or specify any valid hql (hibernate query language)
 that will return an instance of a valid type.
\layout Subsection

Automatically Setting OpenedBy
\layout Standard

Each time we create an issue, the person who opened the issue is by definition
 the currently logged in user.
 How do we programmatically specify that this should automatically happen?
 Here is one way to do this:
\layout LyX-Code

   public void onBeforeCreate()
\layout LyX-Code

   {
\layout LyX-Code

      super.onBeforeCreate();
\layout LyX-Code

      setOpenedBy(currentUser());
\layout LyX-Code

   }
\layout Standard

This method overrides a superclass method, one that is notified prior to
 the creation of an object.
 It turns out that persistent objects (such as 
\emph on 
Issue
\emph default 
) are not the only ones that can listen to various object persistence lifecycle
 events.
 JMatter provides a generic notification mechanism that any object can take
 advantage of.
 Each type of event is defined by a string constant, such as ONDELETE, ONSAVE,
 ONBEFORECREATE, ONCREATE.
 You'll see an example use of this mechanism shortly.
 It's also worth noting that besides object persistence events, JMatter
 provides hooks for application events such as login and logout events.
\layout Subsection

Transitioning to AssignedState
\layout Standard

You might have noticed that I have left a glaring omission: how exactly
 does an issue transition to assigned state? The transition should take
 place when a user is associated to the 
\emph on 
assignedTo
\emph default 
 property of 
\emph on 
Issue
\emph default 
.
\layout Standard

We need to be careful here.
 The setter method is called not only when an association is made but also
 when the object is restored from the persistence store (the database).
 To distinguish between these two contexts, JMatter allows the definition
 of an additional method, the 
\emph on 
associate
\emph default 
 method.
 It works like this: if both a setter and an associator are defined, JMatter
 will make sure to call the associator only when associating (calling only
 the setter when restoring the property from db).
\layout Standard

Here's the implementation:
\layout LyX-Code

   public void associateAssignedTo(User user)
\layout LyX-Code

   {
\layout LyX-Code

      setAssignedTo(user);
\layout LyX-Code

      
\layout LyX-Code

      if (_assignedTo != null && !_assignedTo.isEmpty())
\layout LyX-Code

      {
\layout LyX-Code

         if (isEditableState())
\layout LyX-Code

         {
\layout LyX-Code

            addAppEventListener("ONCREATE", new AppEventListener()
\layout LyX-Code

            {
\layout LyX-Code

               public void onEvent(AppEvent appEvent)
\layout LyX-Code

               {
\layout LyX-Code

                  transition(_assignedState, makeLog("Assigned to "+_assignedTo)
);
\layout LyX-Code

               }
\layout LyX-Code

            });
\layout LyX-Code

         }
\layout LyX-Code

         else
\layout LyX-Code

         {
\layout LyX-Code

            transition(_assignedState, makeLog("Assigned to "+_assignedTo));
\layout LyX-Code

         }
\layout LyX-Code

      }
\layout LyX-Code

   }
\layout Standard

This code looks a little complicated.
 It has to concern itself with a specific issue.
 A call to the 
\emph on 
transition()
\emph default 
 method has the side effect of saving everything and putting the object
 in read state.
 We want to delay the call to transition if the association is made while
 the issue is in an editable state (before it has been saved, while it's
 being edited).
\layout Standard

I'm resorting to using JMatter's application event notification mechanism.
 If the association is made in read state, I simply transition.
 Otherwise, I delay transitioning until after the editing is complete.
\layout Section

Issue Categories
\layout Standard

Our implementation of Issue is now complete.
 Make sure you have the fully qualified class name specified in both xml
 config files.
 This last part is optional.
 It consists of adding one more class to our application: an issue category.
 It might be helpful to define various categories of issues and classify
 issues according to these categories.
\layout Standard

The first thing we do is define an issue category type:
\layout LyX-Code

public class IssueCategory extends AbstractComplexEObject
\layout LyX-Code

{
\layout LyX-Code

   private final StringEO _name = new StringEO();
\layout LyX-Code

   public IssueCategory() {}
\layout LyX-Code

   public StringEO getName() { return _name; }
\layout LyX-Code

\layout LyX-Code

   @CommandAt
\layout LyX-Code

   public Object Issues(CommandInfo cmdInfo)
\layout LyX-Code

   {
\layout LyX-Code

      ComplexType type = ComplexType.forClass(Issue.class);
\layout LyX-Code

      FieldPath path = new FieldPath("com.u2d.issuemgr.Issue#category");
\layout LyX-Code

      QuerySpecification spec = new QuerySpecification(path,
\layout LyX-Code

            new IdentityInequality().new Equals(), this);
\layout LyX-Code

      SimpleQuery query = new SimpleQuery(type, spec);
\layout LyX-Code

      
\layout LyX-Code

      return new PagedList(query);
\layout LyX-Code

   }
\layout LyX-Code

   public Title title() { return _name.title(); }
\layout LyX-Code

}
\layout Standard

Nothing fancy here.
 An issue category is defined to have a single field: a name.
 Rather than defining a to-many relationship to issue, I'm adding a command
 that will fetch a category's issues from the database and return a paged
 list.
\layout Standard

On the issue side, we need to add a to-one association to the issue category:
\layout LyX-Code

   private IssueCategory _category;
\layout LyX-Code

\layout LyX-Code

   public IssueCategory getCategory() { return _category; }
\layout LyX-Code

   public void setCategory(IssueCategory category)
\layout LyX-Code

   {
\layout LyX-Code

      IssueCategory oldValue = _category;
\layout LyX-Code

      _category = category;
\layout LyX-Code

      firePropertyChange("category", oldValue, _category);
\layout LyX-Code

   }
\layout Standard

We also need to update our 
\emph on 
fieldOrder
\emph default 
 metafield:
\layout LyX-Code

   public static String[] fieldOrder = {"status", "title", "description",
 "notes",
\layout LyX-Code

         "openedBy", "assignedTo", "history", "severity", "priority", "category"
};
\layout Standard

That's it for the coding.
 Make sure to ass IssueCategory to 
\emph on 
app-config.xml
\emph default 
, update the schema and let's run the application.
\layout Section

The Application
\layout Standard

Just because we finished coding does not mean that we're done configuring
 our application.
 For example, it might be useful to define a few standard queries such as
 
\emph on 
List Outstanding Issues
\emph default 
 and 
\emph on 
List Closed Issues
\emph default 
 that pre-filters the listing (using jMatter's Smart List mechanism).
\layout Standard

Figure 
\begin_inset LatexCommand \ref{cap:The-Issue-Manager}

\end_inset 

 below shows the issue manager in action.
 I'm listing all issues to illustrate how the issue's icon reflects the
 state it's in (the ones with a lock are closed, the ones with the pencil
 are accepted, and supposedly, being worked on).
 I'm also showing two smart lists that I've created and that I often use
 to check out outstanding issues.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/IssueMgr-2.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

The Issue Manager
\begin_inset LatexCommand \label{cap:The-Issue-Manager}

\end_inset 


\end_inset 


\layout Standard

I also often view issues in tabular view, which allows me to sort issues
 by priority or severity (sorting is invoked by clicking on the table column
 header).
\layout Section

Summary
\layout Standard

As in previous chapters, allow me to show you the stats for this application,
 in terms of lines of code:
\layout LyX-Code

eitan@ubuntu:~/projects/ds/IssueMgr/src/com/u2d/issuemgr$ wc -l *.java
\layout LyX-Code

  40 IssueCategory.java
\layout LyX-Code

 232 Issue.java
\layout LyX-Code

  28 IssueState.java
\layout LyX-Code

 300 total
\layout Standard

Three classes totalling 300 lines of code.
 The current state of lifecycle support in JMatter is pretty strong.
 Its implementation is a natural extension of the conventions already establishe
d for simpler business objects.
 Nevertheless, I believe the implementation can be taken further and place
 even less requirements on the developer.
 For example the requirement to add the various states to a state map could
 be performed by the framework.
\layout Standard

In summary, support for business objects lifecycle is a necessary component
 of supporting the development of business applications in general.
 Many business objects naturally embody lifecycles, including orders (new,
 confirmed, fulfilled, etc..), visits (scheduled, canceled, confrimed, ongoing,
 archived), and others.
\layout Standard

In the next chapter, we're going to take a look at the support that JMatter
 provides for:
\layout Enumerate

adding wizards (or assistants) to your user interface
\layout Enumerate

exporting data as CSV files
\layout Enumerate

producing PDFs
\layout Chapter

Wizards, CSV Export, and PDFs
\layout Standard

Remember our zero-code contact manager? Well, we're finally going to add
 some code to that application.
 Many desktop applications today provide these software assistants, or wizards,
 to help newbie users through a task.
\layout Standard

For example, when we created a contact person in our contact manager, we
 did not resort to an assistant.
 We just right-clicked 
\emph on 
New
\emph default 
 on Person and typed away.
 This works just fine.
 But maybe we would also like to break the process of entering contact informati
on into these steps:
\layout Enumerate

Enter person's name
\layout Enumerate

Enter person's physical address
\layout Enumerate

Enter remainder of their contact information (phone numbers, email address)
\layout Enumerate

Finish
\layout Standard

Having more than one way to do something can sometimes help.
 Each method can complement the other.
 Let's see what kind of support JMatter provides for adding assistants to
 our user interface.
\layout Section

Subclassing Person
\layout Standard

When we wrote this application, we used pre-written classes.
 One of them was 
\emph on 
com.u2d.type.composite.Person
\emph default 
.
 We want to enhance person with an additional behaviour: we want to add
 a command to launch our wizard.
 This should be a class command, not an instance command.
\layout Standard

So we need to subclass 
\emph on 
Person
\emph default 
.
 Let's create a package 
\emph on 
com.u2d.contactmgr
\emph default 
.
 In it we're going to create a new class: 
\emph on 
PersonContact
\emph default 
 like this:
\layout LyX-Code

package com.u2d.contactmgr;
\layout LyX-Code

\layout LyX-Code

import com.u2d.type.composite.Person;
\layout LyX-Code

import com.u2d.wizard.details.Wizard;
\layout LyX-Code

import com.u2d.element.CommandInfo;
\layout LyX-Code

\layout LyX-Code

public class PersonContact extends Person
\layout LyX-Code

{
\layout LyX-Code

   @CommandAt
\layout LyX-Code

   public static Wizard NewPersonWizard(CommandInfo cmdInfo)
\layout LyX-Code

   {
\layout LyX-Code

      return new Wizard(new NewPersonWizard());
\layout LyX-Code

   }
\layout LyX-Code

}
\layout Standard

Pretty simple.
 We're basically exposing a command that will return a 
\emph on 
Wizard
\emph default 
 object.
 JMatter knows what to do with these objects, how to display them, allow
 the end user to navigate through them, etc..
 All you need to do is provide the wizard.
\layout Section

Writing the Wizard
\layout Standard

JMatter models a wizard as a container for a series of steps.
 JMatter defines a several types of steps.
 There are basic (or atomic) steps, conditional steps, and composite steps.
 We need to write a class that is essentially a compositestep: one that
 defines the set of steps that makes up our wizard.
\layout Standard

Here is the first part of the implementation for our NewPersonWizard class:
\layout LyX-Code

package com.u2d.contactmgr;
\layout LyX-Code

\layout LyX-Code

import com.u2d.wizard.details.*;
\layout LyX-Code

import com.u2d.type.composite.*;
\layout LyX-Code

import com.u2d.model.ComplexType;
\layout LyX-Code

import com.u2d.view.swing.FormView;
\layout LyX-Code

import javax.swing.*;
\layout LyX-Code

\layout LyX-Code

public class NewPersonWizard extends CompositeStep
\layout LyX-Code

{
\layout LyX-Code

   private Name _name;
\layout LyX-Code

   private USAddress _address;
\layout LyX-Code

   private Contact _contact;
\layout LyX-Code

\layout LyX-Code

   public NewPersonWizard()
\layout LyX-Code

   {
\layout LyX-Code

      super("New Person Wizard");
\layout LyX-Code

      createObjects();
\layout LyX-Code

      setupSteps();
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

   private void createObjects()
\layout LyX-Code

   {
\layout LyX-Code

      _name = (Name) ComplexType.forClass(Name.class).instance();
\layout LyX-Code

      _address = (USAddress) ComplexType.forClass(USAddress.class).instance();
\layout LyX-Code

      _contact = (Contact) ComplexType.forClass(Contact.class).instance();
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

   private void setupSteps()
\layout LyX-Code

   {
\layout LyX-Code

      NameStep nameStep = new NameStep();
\layout LyX-Code

      AddressStep addrStep = new AddressStep();
\layout LyX-Code

      ContactStep contactStep = new ContactStep();
\layout LyX-Code

      addStep(nameStep);
\layout LyX-Code

      addStep(addrStep);
\layout LyX-Code

      addStep(contactStep);
\layout LyX-Code

      addStep(new CommitWizardStep());
\layout LyX-Code

      ready();
\layout LyX-Code

   }
\layout LyX-Code

\layout LyX-Code

}
\layout Standard

Let's analyze this code.
 We defined a class that extends 
\emph on 
CompositeStep
\emph default 
.
 Recall that our wizard is essentially four steps: specify a name, an address,
 contact info, and finish.
 So we define variables that will hold each of these three pieces of information.
\layout Standard

Next, in the constructor, we set the title for our wizard with the call
 to the super type's constructor.
 We proceed to instantiate our three objects and then to configure them.
 The convention for setting up the steps is pretty easy:
\layout Enumerate

create each step
\layout Enumerate

add the steps in the proper order
\layout Enumerate

call the ready() method
\layout Standard

Now all that's left to do is define three basic steps.
 I've decided to do this using inner classes, as follows:
\layout LyX-Code

class NameStep extends BasicStep
\layout LyX-Code

{
\layout LyX-Code

   public String title() { return "Name Information"; }
\layout LyX-Code

   public String description() { return "Enter Person's Name"; }
\layout LyX-Code

   public JComponent getView()
\layout LyX-Code

   {
\layout LyX-Code

      return new FormView(_name, false, false);
\layout LyX-Code

   }
\layout LyX-Code

}
\layout LyX-Code

class AddressStep extends BasicStep
\layout LyX-Code

{
\layout LyX-Code

   public String title() { return "Address Information"; }
\layout LyX-Code

   public String description() { return "Enter Person's Physical Address";
 }
\layout LyX-Code

   public JComponent getView()
\layout LyX-Code

   {
\layout LyX-Code

      return new FormView(_address, false, false);
\layout LyX-Code

   }
\layout LyX-Code

}
\layout LyX-Code

class ContactStep extends BasicStep
\layout LyX-Code

{
\layout LyX-Code

   public String title() { return "Person's Contact Information"; }
\layout LyX-Code

   public String description() { return "Please specify person's contact
 information"; }
\layout LyX-Code

   public JComponent getView()
\layout LyX-Code

   {
\layout LyX-Code

      return new FormView(_contact, false, false);
\layout LyX-Code

   }
\layout LyX-Code

}
\layout Standard

We see here that the implementation is trivial.
 We provide a title, description, and a view for each of our steps.
 Nothing to it!
\layout Standard

In our last step, the commit step, we sew everything together and save our
 new contact person:
\layout LyX-Code

   class CommitWizardStep extends CommitStep
\layout LyX-Code

   {
\layout LyX-Code

      public void commit()
\layout LyX-Code

      {
\layout LyX-Code

         PersonContact pc = new PersonContact();
\layout LyX-Code

         pc.getName().setValue(_name);
\layout LyX-Code

         pc.getContact().setValue(_contact);
\layout LyX-Code

         pc.getContact().getAddress().setValue(_address);
\layout LyX-Code

         pc.save();
\layout LyX-Code

      }
\layout LyX-Code

      public JComponent getView()
\layout LyX-Code

      {
\layout LyX-Code

         return new JLabel(description());
\layout LyX-Code

      }
\layout LyX-Code

      public String title() { return "Final Step"; }
\layout LyX-Code

      public String description()
\layout LyX-Code

      {
\layout LyX-Code

         return "We're almost done; Person record will be " +
\layout LyX-Code

                "committed after clicking 'Next'";
\layout LyX-Code

      }
\layout LyX-Code

   }
\layout Standard

Besides providing the basic step information: title, description, and view,
 we also need to fill in the 
\emph on 
commit()
\emph default 
 method, which is quite straightforward:
\layout Enumerate

we create a new PersonContact instance
\layout Enumerate

we set the name, contact, and address values
\layout Enumerate

finally, we persist our instance
\layout Standard

JMatter does the rest! Let's take our app for a little spin.
\layout Section

Running the Application
\layout Standard

Just as a reminder, here's my complete app-config.xml file:
\layout LyX-Code

<?xml version="1.0"?>
\layout LyX-Code

<application name="Contact Manager">
\layout LyX-Code

   <view-mechanism>com.u2d.view.swing.SwingViewMechanism</view-mechanism>
\layout LyX-Code

   <look-and-feel>Metal</look-and-feel>
\layout LyX-Code

   <page-size>15</page-size>
\layout LyX-Code

   <persistence-mechanism>com.u2d.persist.HBMSingleSession</persistence-mechanism>
\layout LyX-Code

   <persist-classes>
\layout LyX-Code

      <class>com.u2d.contactmgr.PersonContact</class>
\layout LyX-Code

      <class>com.u2d.type.composite.Person</class>
\layout LyX-Code

      <class>com.u2d.type.composite.Business</class>
\layout LyX-Code

      <class>com.u2d.type.USState</class>
\layout LyX-Code

      <class>com.u2d.type.composite.ContactMethod</class>
\layout LyX-Code

      <class>com.u2d.type.composite.Folder</class>
\layout LyX-Code

      <class>com.u2d.find.CompositeQuery</class>
\layout LyX-Code

      <class>com.u2d.type.composite.LoggedEvent</class>
\layout LyX-Code

      <class>com.u2d.app.User</class>
\layout LyX-Code

      <class>com.u2d.app.Role</class>
\layout LyX-Code

      <class>com.u2d.restrict.CommandRestriction</class>
\layout LyX-Code

      <class>com.u2d.restrict.FieldRestriction</class>
\layout LyX-Code

      <class>com.u2d.restrict.Restriction</class>
\layout LyX-Code

   </persist-classes>
\layout LyX-Code

</application>
\layout Standard

And here's my 
\emph on 
class-list.xml
\emph default 
:
\layout LyX-Code

<?xml version="1.0" encoding="UTF-8"?>
\layout LyX-Code

<folder>
\layout LyX-Code

   <name>Class List</name>
\layout LyX-Code

   <items>
\layout LyX-Code

      <folder>
\layout LyX-Code

         <name>Manager</name>
\layout LyX-Code

         <items>
\layout LyX-Code

           <type>com.u2d.contactmgr.PersonContact</type>
\layout LyX-Code

           <type>com.u2d.type.composite.Business</type>
\layout LyX-Code

           <type>com.u2d.type.composite.Folder</type>
\layout LyX-Code

           <type>com.u2d.find.CompositeQuery</type>
\layout LyX-Code

         </items>
\layout LyX-Code

      </folder>
\layout LyX-Code

      <folder>
\layout LyX-Code

         <name>Administrative</name>
\layout LyX-Code

         <items>
\layout LyX-Code

           <type>com.u2d.app.User</type>
\layout LyX-Code

           <type>com.u2d.type.composite.LoggedEvent</type>
\layout LyX-Code

           <type>com.u2d.model.ComplexType</type>
\layout LyX-Code

         </items>
\layout LyX-Code

      </folder>
\layout LyX-Code

   </items>
\layout LyX-Code

</folder>
\layout Standard

Let's export our schema and run our app:
\layout LyX-Code

ant schema-export
\layout LyX-Code

ant run
\layout Standard

I have included screenshots for the various steps in our simple wizard in
 the next five figures.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/Wizard-Step0.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\end_inset 


\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/Wizard-Step1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\end_inset 


\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/Wizard-Step2.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\end_inset 


\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/Wizard-Step3.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\end_inset 


\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/Wizard-Step4.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\end_inset 


\layout Section

CSV Export
\layout Standard

If we like, we can also export our contact list to a CSV file.
 This feature is built-in to all JMatter applications.
 Simply browse your contact listing and right-click 
\emph on 
Export to CSV
\emph default 
.
 You will be prompted for a location to save the file.
 Below is a screenshot of a small CSV export opened in the spreadsheet applicati
on 
\emph on 
Gnumeric
\emph default 
.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CSVExport.png
	lyxscale 40
	scale 40
	keepAspectRatio

\end_inset 


\end_inset 


\layout Standard

Note that this feature could be improved.
 At the moment the CSV Export command simply exports the table model exposed
 by the listing.
 However, in this case, it would be nice if the address fields were flattened
 as properties for each contact.
 It'd be even nicer if there a CSV export wizard walked you through the
 process, allowing you to select which fields to export, which to skip,
 and in what order to serialize them out to file.
 We hope to extend this CSV export feature in a future version of jMatter.
\layout Section

JFreeReport Integration
\layout Standard

JFreeReport is an open source Java API for reporting; its home page is http://ww
w.jfree.org/jfreereport/
\layout Standard

This API has been around for a number of years.
 It defines an xml vocabulary for laying out reports.
 It's somewhat difficult to describe in a one or two sentences what JFreeReport
 is all about.
 Some of its characteristics are reminiscent of templating technologies
 where information from our applications can be merged with a the xml report
 specification to produce the final report.
 The report specification defines various 
\emph on 
bands
\emph default 
 such as report headers and footers, page headers and footers, and the actual
 report items themselves.
\layout Standard

JFreeReport also provides means for you to automatically display a 
\emph on 
print preview
\emph default 
 of your report from inside your Swing application.
 From that dialog, one also has the ability to produce the report in a number
 of formats, including PDF, print, and Microsoft Excel.
\layout Standard

The JMatter framework attempts to make the job of producing reports with
 JFreeReport easier.
 The JFreeReport libraries are already bundled with JMatter.
 Producing a PDF report from JMatter via JFreeReport is a relatively easy
 task.
 The task of writing the report specification using JFreeReport's XML specificat
ion however remains unchanged.
\layout Standard

The authors of this framework have used JFreeReport to produce completed
 medical forms, merging information in a medical system with a template
 defining the layout of the form[s] to be completed.
\layout Subsection

The basics
\layout Standard

JFreeReport provides two ways in which data can be passed in to its xml
 report specification:
\layout Enumerate

the implementation of a 
\emph on 
TableModel
\emph default 
 interface, which provides the majority of the tabular data to be included
 in a report, and
\layout Enumerate

a simple properties file with key-value pairs for passing any kind of informatio
n to include in the header or footer sections of the report
\layout Standard

JMatter defines the following interface:
\layout LyX-Code

public interface Reportable
\layout LyX-Code

{
\layout LyX-Code

   public String reportName();
\layout LyX-Code

   public Properties properties();
\layout LyX-Code

   public TableModel tableModel();
\layout LyX-Code

}
\layout Standard

The latter two methods provide the data to bind to the xml report specification.
 The first method provides the path to the report's xml specification.
 JMatter basically follows the convention that these xml files be placed
 alongside source code.
 The xml files are then loaded into a Java application as a resource.
\layout Standard

If in a command method, you return a Reportable instance, JMatter will take
 it from there and use JFreeReport to produce a corresponding PDF file and
 open it using a PDF reader application.
\layout Subsection

A Simple Example
\layout Standard

Let's build a very simple report for our ContactManager application.
 The point of this section is not to provide documentation for JFreeReport.
 Rather, it's only to illustrate how the integration is done.
\layout Standard

So here's a simple mechanism to expose the production of a report that will
 include all the contacts we have in our system:
\layout LyX-Code

   @CommandAt
\layout LyX-Code

   public static Reportable Report(CommandInfo cmdInfo)
\layout LyX-Code

   {
\layout LyX-Code

      return new Reportable()
\layout LyX-Code

      {
\layout LyX-Code

         public String reportName()
\layout LyX-Code

         {
\layout LyX-Code

            return "/com/u2d/contactmgr/Basic.xml";
\layout LyX-Code

         }
\layout LyX-Code

         public Properties properties()
\layout LyX-Code

         {
\layout LyX-Code

            return new Properties();
\layout LyX-Code

         }
\layout LyX-Code

         public TableModel tableModel()
\layout LyX-Code

         {
\layout LyX-Code

            return ComplexType.forClass(PersonContact.class).list().tableModel();
\layout LyX-Code

         }
\layout LyX-Code

      };
\layout LyX-Code

   }
\layout Standard

So basically what I'm doing here is exposing a static command using the
 JMatter conventions.
 This command returns a 
\emph on 
Reportable
\emph default 
 implementation that in this case passes data only via a tablemodel.
 I'm basically returning the default table model that JMatter exposes on
 lists of types.
\layout Standard

Here is a very basic sample JFreeReport XML specification:
\layout LyX-Code

<?xml version="1.0" encoding="iso-8859-1"?>
\layout LyX-Code

<!DOCTYPE report PUBLIC
\layout LyX-Code

      "-//JFreeReport//DTD report definition//EN//simple/version 0.8.5"
\layout LyX-Code

      "http://jfreereport.sourceforge.net/report-085.dtd">
\layout LyX-Code

<report name="Basic Persons Listing" 
\layout LyX-Code

   orientation="portrait" pageformat="LETTER" 
\layout LyX-Code

   topmargin="36" bottommargin="36" 
\layout LyX-Code

   leftmargin="36" rightmargin="36">
\layout LyX-Code

  <configuration>
\layout LyX-Code

     <property name="org.jfree.report.modules.gui.base.PreferredWidth">640</property>
\layout LyX-Code

     <property name="org.jfree.report.modules.gui.base.PreferredHeight">480</property>
\layout LyX-Code

  </configuration>
\layout LyX-Code

  <pageheader height="200" fontname="sansserif" fontsize="10" fsbold="true">
\layout LyX-Code

    <label x="0" y="0" 
\layout LyX-Code

           width="100%" height="12" 
\layout LyX-Code

           fonsize="12" fsbold="true"
\layout LyX-Code

           alignment="center"><![CDATA[Person Contacts Listing]]></label>
\layout LyX-Code

    <line x1="170" y1="50" x2="334" y2="50" weight="0.75" />
\layout LyX-Code

  </pageheader>
\layout LyX-Code

  <items height="18"
\layout LyX-Code

         fontname="sansserif" fontstyle="plain" fontsize="10" fsbold="false"
\layout LyX-Code

         vertical-alignment="middle">
\layout LyX-Code

    <string-field x="10" y="0" width="250" height="12" alignment="left"
 
\layout LyX-Code

       fieldname="Person Contacts" />
\layout LyX-Code

    <string-field x="270" y="0" width="100" height="12" alignment="left"
 
\layout LyX-Code

       fieldname="Name" />
\layout LyX-Code

    <string-field x="380" y="0" width="250" height="12" alignment="left"
 
\layout LyX-Code

       fieldname="Contact" />
\layout LyX-Code

  </items>
\layout LyX-Code

</report>
\layout Standard

The essential aspects of this specification are located in the items band,
 where we see that various string-based fields are specified.
 JFreeReport allows you to insert images, other data types, to control the
 font size, style, and placement of the information.
 JFreeReport also provides a number of built-in functions that can be invoked
 to calculate sums, for example.
 Developers can also write and plug in their own custom functions.
\layout Standard

The result of invoking this command from the JMatter user interface is the
 production of the report PDF, as shown below.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/JFree-1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

PDF produced with JFreeReport
\end_inset 


\layout Section

Summary
\layout Standard

In this chapter we've seen the ease with which we can integrate wizards
 (assistants) into an already powerful user interface.
\layout Standard

This wizard feature has already been used in other contexts to produce complex
 wizards, such as new patient forms at medical clinics.
 Most of us are too familiar with the amounts of information a patient or
 guarantor must enter when first visiting a medical institution (in the
 United States, at least).
\layout Standard

The JMatter framework attempts to be as open as possible.
 Wizards are not the only way to inject custom user interface features into
 JMatter applications.
 JMatter was designed to allow you to write your own custom views for objects
 and plug them into your existing JMatter applications.
\layout Standard

We've also seen the CSV Export feature, a nice though simple mechanism for
 exporting data out of your application.
 Of course, there already exist many tools to export and process your applicatio
n's data.
 It's already easily accessible in that all the information resides in an
 open database system.
\layout Standard

Finally, we also see that JMatter provides an avenue for producing PDFs
 by integrating and leveraging the open source JFreeReport API.
\layout Standard

In chapter 
\begin_inset LatexCommand \ref{cha:Deploying-your-Application}

\end_inset 

, we're going to learn how to deploy our applications to all our users.
 I hope you'll agree that here too, JMatter helps turn a difficult and complex
 job into a trivial task.
\layout Chapter

Customized Views and Editors
\layout Standard

It's nice for a framework to support the automatic generation of views for
 various objects.
 We've also seen how the base user interface can be augmented with calendaring
 features, wizards, and support for producing PDFs.
 However, it's equally important for a framework to remain flexible and
 to allow for the construction of custom views as well.
\layout Standard

jMatter's primary view mechanism at the moment is its Swing-based view mechanism.
 Other view mechanisms might be constructed in the future, including possibly
 a web-based user interface, possibly a command-line user interface.
\layout Standard

In this chapter I'd like to provide an example of how one goes about writing
 and specifying a custom view for the Swing view mechanism.
\layout Section

Complex, or Composite Views
\layout Standard

The 
\emph on 
demo-apps
\emph default 
 subdirectory contains a project, 
\emph on 
CustomUI
\emph default 
, designed specifically to illustrate how this is done.
 It is similar to our contact manager: There's a 
\emph on 
Contact
\emph default 
 class and an 
\emph on 
Address
\emph default 
 class.
 The idea is that we'd like to be able to customize the way Addresses appear
 on the screen; specifically, the way that the form view for addresses is
 laid out.
 The default form view is nice.
 Figure 
\begin_inset LatexCommand \ref{cap:Standard-Form-View}

\end_inset 

 displays the default view for the 
\emph on 
address
\emph default 
 property of the 
\emph on 
Contact
\emph default 
 class.
\layout Standard


\begin_inset Float figure
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CustomView-1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

Standard Form View the 
\emph on 
Contact.address
\emph default 
 Field
\begin_inset LatexCommand \label{cap:Standard-Form-View}

\end_inset 


\end_inset 


\layout Standard

Let's say that we'd prefer to display addresses in such a way that the field
 captions are placed above the field editors (instead of appearing to their
 left), and that we'd like to lay out the 
\emph on 
city
\emph default 
, 
\emph on 
state
\emph default 
, and 
\emph on 
zip
\emph default 
 fields all on the same line, instead of having them appear one below the
 other, as shown in Figure 
\begin_inset LatexCommand \ref{cap:Desired-view}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/CustomView-2.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption

Desired view for Addresses
\begin_inset LatexCommand \label{cap:Desired-view}

\end_inset 


\end_inset 


\layout Standard

We must do two things:
\layout Enumerate

Override the method 
\emph on 
getMainView()
\emph default 
 on the Address class, to return a new view
\layout Enumerate

Implement the custom view for addresses; this process is similar to the
 way we traditionally build views in Swing
\layout Standard

The first step is straightforward:
\layout LyX-Code

   public EView getMainView()
\layout LyX-Code

   {
\layout LyX-Code

      return new CustomAddressView(this);
\layout LyX-Code

   }
\layout Standard

Now, for the implementation.
 We could implement the UI by extending from Swing's 
\emph on 
JPanel
\emph default 
, like this:
\layout LyX-Code

public class CustomAddressView extends JPanel
\layout LyX-Code

      implements ComplexEView, Editor
\layout LyX-Code

{
\layout LyX-Code

   private Address _addr;
\layout LyX-Code

   JComponent line1View, line2View, cityView, stateView, zipView;
\layout LyX-Code

   
\layout LyX-Code

   public CustomAddressView(Address address)
\layout LyX-Code

   {
\layout LyX-Code

      _addr = address;
\layout LyX-Code

      buildUI();
\layout LyX-Code

   }
\layout LyX-Code

   private void buildUI()
\layout LyX-Code

   {
\layout LyX-Code

      line1View = (JComponent) _addr.getLine1().getView();
\layout LyX-Code

      line2View = (JComponent) _addr.getLine2().getView();
\layout LyX-Code

      cityView = (JComponent) _addr.getCity().getView();
\layout LyX-Code

      stateView = (JComponent) _addr.getStateCode().getView();
\layout LyX-Code

      zipView = (JComponent) _addr.getZipCode().getView();
\layout LyX-Code

      
\layout LyX-Code

      FormLayout layout = new FormLayout("pref, 10px, pref, 10px, pref",
 
\layout LyX-Code

                                         "pref, pref, 10px, pref, pref,
 10px, pref, pref");
\layout LyX-Code

      CellConstraints cc = new CellConstraints();
\layout LyX-Code

      DefaultFormBuilder builder = new DefaultFormBuilder(layout, this);
\layout LyX-Code

      // add caption..
\layout LyX-Code

      builder.add(new JLabel("Line 1:"), cc.xyw(1, 1, 5));
\layout LyX-Code

      builder.add(line1View, cc.xyw(1, 2, 5));
\layout LyX-Code

      
\layout LyX-Code

      builder.add(new JLabel("Line 2:"), cc.xyw(1, 4, 5));
\layout LyX-Code

      builder.add(line2View, cc.xyw(1, 5, 5));
\layout LyX-Code

      
\layout LyX-Code

      builder.add(new JLabel("City:"), cc.xy(1, 7));
\layout LyX-Code

      builder.add(new JLabel("State:"), cc.xy(3, 7));
\layout LyX-Code

      builder.add(new JLabel("Zip:"), cc.xy(5, 7));
\layout LyX-Code

      
\layout LyX-Code

      builder.add(cityView, cc.xy(1,8));
\layout LyX-Code

      builder.add(stateView, cc.xy(3, 8));
\layout LyX-Code

      builder.add(zipView, cc.xy(5, 8));
\layout LyX-Code

   }
\layout LyX-Code

   public EObject getEObject() { return _addr; }
\layout LyX-Code

   
\layout LyX-Code

   // as a composite view, this particular class may not
\layout LyX-Code

   // necessarily be interested in binding to the model
\layout LyX-Code

   // and listen to changes.
  to the extent that i use
\layout LyX-Code

   // the jmatter views for the subparts of the address,
\layout LyX-Code

   // they will be listening directly to the parts.
\layout LyX-Code

   public void detach() { }
\layout LyX-Code

   public void stateChanged(ChangeEvent e) { }
\layout LyX-Code

   public void propertyChange(PropertyChangeEvent evt) { }
\layout LyX-Code

   public boolean isMinimized() { return false; }
\layout LyX-Code

   public int transferValue()
\layout LyX-Code

   {
\layout LyX-Code

      int result = 0;
\layout LyX-Code

      result += ((Editor) line1View).transferValue();
\layout LyX-Code

      result += ((Editor) line2View).transferValue();
\layout LyX-Code

      result += ((Editor) cityView).transferValue();
\layout LyX-Code

      result += ((Editor) stateView).transferValue();
\layout LyX-Code

      result += ((Editor) zipView).transferValue();
\layout LyX-Code

      return result;
\layout LyX-Code

   }
\layout LyX-Code

   public void setEditable(boolean editable)
\layout LyX-Code

   {
\layout LyX-Code

      ((Editor) line1View).setEditable(editable);
\layout LyX-Code

      ((Editor) line2View).setEditable(editable);
\layout LyX-Code

      ((Editor) cityView).setEditable(editable);
\layout LyX-Code

      ((Editor) stateView).setEditable(editable);
\layout LyX-Code

      ((Editor) zipView).setEditable(editable);
\layout LyX-Code

   }
\layout LyX-Code

   public boolean isEditable()
\layout LyX-Code

   {
\layout LyX-Code

      return ((Editor) line1View).isEditable();
\layout LyX-Code

   }
\layout LyX-Code

}
\layout Standard

Let's review this code.
 Here I am using the excellent JGoodies Forms framework to layout a form
 
\begin_inset Quotes eld
\end_inset 

by hand,
\begin_inset Quotes erd
\end_inset 

 so to speak.
 JGoodies' DefaultFormBuilder makes this pretty easy.
 I assume that similar code could also be produced with the help of a visual
 form designer, such as the 
\emph on 
Abeille Forms Designer
\emph default 
, for example.
 Note however, that there are additional responsibilities that this class
 must fulfill:
\layout Enumerate

The class must implement the 
\emph on 
ComplexEView
\emph default 
 interface
\layout Enumerate

If the class will also participate in the editing process, it must implement
 the 
\emph on 
Editor
\emph default 
 interface
\layout Standard

In this case, the 
\emph on 
ComplexEView
\emph default 
 interface is fairly simple.
 Some of the methods have no-op implementations (
\emph on 
detach()
\emph default 
, 
\emph on 
stateChanged()
\emph default 
, 
\emph on 
propertyChange()
\emph default 
).
 Every view can, at its discretion, attach itself as a listener to the object
 model and thus receive model change notifications.
 In this case, we're dealing with a composite view, and each of the sub-views
 already listens to changes to the parts, so we don't technically need to
 listen to model changes here.
 Views must also make sure to 
\begin_inset Quotes eld
\end_inset 

detach
\begin_inset Quotes erd
\end_inset 

 themselves from the model objects where they're destroyed.
 It's very important that the detach() method properly do this.
 A careless implementation can easily introduce a memory leak into the applicati
on as views are created and their memory not reclaimed because they may
 still be attached to a model object whose lifetime is typically longer
 than its view's.
\layout Standard

The 
\emph on 
Editor
\emph default 
 interface is also fairly straightforward.
 The 
\emph on 
setEditable()
\emph default 
 method is called when the model object's state toggles from 
\emph on 
Read
\emph default 
 to 
\emph on 
Edit
\emph default 
 (and back), thus giving the user interface a chance to update itself accordingl
y (if so desired).
 Notice also that 
\emph on 
transferValue()
\emph default 
 is called before an object is saved, allowing the view a chance to bind
 the newly entered data back to the model object (or possibly raise a validation
 exception, in which case the save operation is vetoed.
 The integer value returned by this method is an indication of the number
 of validation errors, which is also displayed by the framework in such
 circumstances.
\layout Section

Atomic Views
\layout Standard

jMatter defines the notion of atomic types.
 Examples include representations for booleans, dates, text, zip codes,
 social security number, percentages, integers, floats, etc..
 They're defined in the package 
\emph on 
com.u2d.type.atom
\emph default 
.
\layout Standard

This section describes how to write a custom view and/or editor for a given
 type.
 Let's take 
\emph on 
BooleanEO
\emph default 
 as an example.
 Here is the implementation for the default renderer for boolean's:
\layout LyX-Code

public class BooleanRenderer extends JLabel implements AtomicRenderer
\layout LyX-Code

{
\layout LyX-Code

   public void render(AtomicEObject value)
\layout LyX-Code

   {
\layout LyX-Code

      BooleanEO eo = (BooleanEO) value;
\layout LyX-Code

      setText((eo.booleanValue()) ? "Yes" : "No");
\layout LyX-Code

   }
\layout LyX-Code

   public void passivate() { }
\layout LyX-Code

}
\layout Standard

jMatter defines the interface 
\emph on 
AtomicRenderer
\emph default 
, with essentially a single method.
 You can ignore the 
\emph on 
passivate()
\emph default 
 method for now (we're considering making a design revision where views
 are pooled, and then re-used for different atomic types, in which case
 this method could be used to 
\begin_inset Quotes eld
\end_inset 

clean up
\begin_inset Quotes erd
\end_inset 

 the view before it's re-used).
\layout Standard

So basically one implements the 
\emph on 
render()
\emph default 
 method.
 This method is handed a model object that it must render.
 So in this case, the renderer is given an instance of a 
\emph on 
BooleanEO
\emph default 
 which it uses to 
\begin_inset Quotes eld
\end_inset 

paint
\begin_inset Quotes erd
\end_inset 

 the text 
\emph on 
Yes
\emph default 
 or 
\emph on 
No
\emph default 
 on a JLabel.
\layout Standard

To write a custom Editor for a type, you must implement two methods: 
\emph on 
render()
\emph default 
 and 
\emph on 
bind()
\emph default 
.
 Here's the definition of the interface that one must implement:
\layout LyX-Code

public interface AtomicEditor extends AtomicRenderer
\layout LyX-Code

{
\layout LyX-Code

   public int bind(AtomicEObject value);
\layout LyX-Code

}
\layout Standard

And here's an example implementation, again for the 
\emph on 
BooleanEO
\emph default 
 type:
\layout LyX-Code

public class BooleanCheckboxEditor extends JCheckBox
\layout LyX-Code

      implements ItemListener, AtomicEditor, ActionNotifier
\layout LyX-Code

{
\layout LyX-Code

   public BooleanCheckboxEditor()
\layout LyX-Code

   {
\layout LyX-Code

      addItemListener(this);
\layout LyX-Code

   }
\layout LyX-Code

   public void itemStateChanged(ItemEvent e)
\layout LyX-Code

   {
\layout LyX-Code

      setText( (isSelected()) ? "Yes" : "No" );
\layout LyX-Code

   }
\layout LyX-Code

   public int bind(AtomicEObject value)
\layout LyX-Code

   {
\layout LyX-Code

      BooleanEO eo = (BooleanEO) value;
\layout LyX-Code

      eo.setValue(isSelected());
\layout LyX-Code

      return 0;
\layout LyX-Code

   }
\layout LyX-Code

   public void render(AtomicEObject value)
\layout LyX-Code

   {
\layout LyX-Code

      BooleanEO eo = (BooleanEO) value;
\layout LyX-Code

      setSelected(eo.booleanValue());
\layout LyX-Code

      itemStateChanged(null); // text synch with checkbox
\layout LyX-Code

   }
\layout LyX-Code

   public void passivate() { }
\layout LyX-Code

}
\layout Standard

The 
\emph on 
bind()
\emph default 
 method is responsible on setting the newly edited value back to the model
 object.
 Here's a second implementation for a 
\emph on 
BooleanEO
\emph default 
 editor that uses a group of radio buttons instead:
\layout LyX-Code

public class BooleanRadioEditor extends JPanel implements AtomicEditor
\layout LyX-Code

{
\layout LyX-Code

   private JRadioButton _yesBtn, _noBtn;
\layout LyX-Code

   public BooleanRadioEditor()
\layout LyX-Code

   {
\layout LyX-Code

      _yesBtn = new JRadioButton("Yes");
\layout LyX-Code

      _yesBtn.setOpaque(false);
\layout LyX-Code

      _noBtn = new JRadioButton("No");
\layout LyX-Code

      _noBtn.setOpaque(false);
\layout LyX-Code

      _yesBtn.addActionListener(new ActionListener()
\layout LyX-Code

      {
\layout LyX-Code

         public void actionPerformed(ActionEvent evt)
\layout LyX-Code

         {
\layout LyX-Code

            _yesBtn.setSelected(true);
\layout LyX-Code

         }
\layout LyX-Code

      });
\layout LyX-Code

      _noBtn.addActionListener(new ActionListener()
\layout LyX-Code

      {
\layout LyX-Code

         public void actionPerformed(ActionEvent evt)
\layout LyX-Code

         {
\layout LyX-Code

            _noBtn.setSelected(true);
\layout LyX-Code

         }
\layout LyX-Code

      });
\layout LyX-Code

      ButtonGroup group = new ButtonGroup();
\layout LyX-Code

      group.add(_yesBtn);
\layout LyX-Code

      group.add(_noBtn);
\layout LyX-Code

      FormLayout layout = new FormLayout("pref, 3px, pref", "pref");
\layout LyX-Code

      DefaultFormBuilder builder = new DefaultFormBuilder(layout, this);
\layout LyX-Code

      CellConstraints cc = new CellConstraints();
\layout LyX-Code

      builder.add(_yesBtn, cc.xy(1, 1));
\layout LyX-Code

      builder.add(_noBtn, cc.xy(3, 1));
\layout LyX-Code

   }
\layout LyX-Code

   public void render(AtomicEObject value)
\layout LyX-Code

   {
\layout LyX-Code

      BooleanEO eo = (BooleanEO) value;
\layout LyX-Code

      JRadioButton btn = (eo.booleanValue()) ? _yesBtn : _noBtn;
\layout LyX-Code

      btn.setSelected(true);
\layout LyX-Code

   }
\layout LyX-Code

   public int bind(AtomicEObject value)
\layout LyX-Code

   {
\layout LyX-Code

      BooleanEO eo = (BooleanEO) value;
\layout LyX-Code

      eo.setValue(_yesBtn.isSelected());
\layout LyX-Code

      return 0;
\layout LyX-Code

   }
\layout LyX-Code

   public void passivate() { }
\layout LyX-Code

}
\layout Standard

The jMatter codebase is full of examples of atomic editors and renderers.
 Use them as the basis for creating your own implementations.
\layout Subsection

Specifying the Default Editor and Renderer
\layout Standard

You control which type of renderer or editor to use as the default by revising
 the corresponding method for a given view mechanism.
 Assuming the 
\emph on 
SwingViewMechanism
\emph default 
, you'd revise the implementations of 
\emph on 
getBooleanRenderer()
\emph default 
 and getBooleanEditor() respectively for the 
\emph on 
BooleanEO
\emph default 
 type.
\layout Standard

Of course, if you're going to be implementing a custom view for a more complex
 or composite object, then you're in complete control of the rendering and
 editing process.
\layout Chapter

Validation
\layout Standard

[tbd]
\layout Chapter

Deploying your Application
\begin_inset LatexCommand \label{cha:Deploying-your-Application}

\end_inset 


\layout Standard

In this chapter we'll discuss how to setup your application for distribution
 with Sun's Java Web Start technology.
\layout Section

JMatter Applications Architecture
\layout Standard

We already know that JMatter applications rely on a database management
 system for storing information, performing queries, and more.
 The architecture of JMatter applications is simple and straightforward:
 JMatter applications are installed at end-user workstations, and communicate
 to the database that resides on the server.
 This architecture is known as a two-tier client-server architecture and
 is quite suitable for small multi-user applications (roughly up to 100
 users).
\layout Standard

The dillema is having to install and maintain JMatter applications on each
 client machine.
 This is where Java Web Start comes to the rescue.
\layout Section

Java Web Start
\layout Standard

The basic idea behind Java Web Start is to distribute your application using
 the world wide web.
 End users simply visit a web page and click on a link that triggers the
 automatic download and installation of the application to the end-user's
 computer.
 Java Web Start is bundled with every distribution of Java.
\layout Standard

It gets even better: each time the end user launches the application, Java
 Web Start verifies whether any updates are available and will automatically
 download and install the updates prior to launching the application.
 So, not only is the distribution of your application automated but also
 its maintenance.
 You can read all about Java Web Start at 
\emph on 
http://java.sun.com/products/javawebstart/
\layout Standard

In our case, we'll be deploying applications within an intranet or extranet.
 Nevertheless, we'll be using web technologies to distribute and keep our
 client installations up to date.
\layout Section

Deploying ContactMgr
\layout Standard

JMatter provides an ant target for bundling your application for distribution
 via Java Web Start.
\layout Standard

We first need to decide what web server to use to deploy our application.
 We'll need the machine's host name or ip address, and the port number (which
 typically will be 80).
 Enter these two bits of information into the file 
\emph on 
project.properties
\emph default 
 located in 
\emph on 
resources/jws/dynamic
\layout Standard

Second we need to ensure that the database connection url we specify in
 
\emph on 
hibernate.properties
\emph default 
 is not a relative url (such as 
\emph on 
jdbc:postgresql://localhost/contactmgr
\emph default 
); that url must be valid for all the end-user computers.
 We also need to ensure that no firewalls forbid communications traffic
 between the end-user machines and the database.
 Remember, JMatter was designed for workgroup applications: that is, for
 multiple users on a Local Area Network or a Virtual Private Network.
\layout Standard

Ok, here's the magic ant target:
\layout LyX-Code

ant jws-dist
\layout Standard

When the target is finished running, it will have produced a 
\emph on 
.war
\emph default 
 file in the 
\emph on 
dist
\emph default 
 folder.
\layout Standard

Create a directory with the same name as your project inside your web server's
 document root directory:
\layout LyX-Code

sudo mkdir /var/www/ContactMgr
\layout Standard

Extract the 
\emph on 
war
\emph default 
 file to that directory.
 This should do the trick:
\layout LyX-Code

sudo unzip dist/ContactMgr.war -d /var/www/ContactMgr
\layout LyX-Code

\layout Standard

We should now be ready to give our application a try.
 Sit at a client machine and visit the web page in question (perhaps http://loca
l-server/ContactMgr).
 You'll see a page that looks like figure 
\begin_inset LatexCommand \ref{cap:Java-Web-Start}

\end_inset 

.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/JWS-1.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Java-Web-Start}

\end_inset 

Java Web Start Launch Page
\end_inset 


\layout Standard

Click on the link and Java Web Start will launch and begin downloading your
 application.
 Before permitting you to proceed, you will be prompted to accept the certificat
e used to sign the code (see figure 
\begin_inset LatexCommand \ref{cap:JWS-Security}

\end_inset 

).
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/JWS-2.png
	scale 60
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:JWS-Security}

\end_inset 

Java Web Start Security Prompt
\end_inset 


\layout Standard

This requires some explanation.
 Java Web Start will not run any code that is not signed with a code certificate.
 This is not 100% true.
 It is possible to customize the Java security policy on every client machine
 to allow locally deployed code to run.
 However this is not really a viable option as it completely defeats the
 original purpose of Java Web Start being a simple and easy way to deploy
 applications without having to perform modifications on each client machine.
\layout Standard

So the code must be signed.
 By default JMatter will sign the codebase anonymously so as to allow the
 code to run.
 Java Web Start will prompt the end-user to allow the the application to
 launch.
 This is essentially the hand-off point.
 It is the place where you, the developer of the application, procure a
 valid code certificate and use it to sign the code base that you're deploying.
\layout Standard

Enough discussion, go ahead and reply 
\emph on 
Yes
\emph default 
 to the prompt and watch the application launch.
 You can proceed by logging in to the application and interacting with it
 as you always have up to now.
\layout Standard

That's basically it.
 That is, anyone in your organization can now visit the intranet web page
 for our Contact Manager and with a single click of the mouse they will
 have downloaded, installed, and run our Contact Manager application.
\layout Section

Caveats
\layout Standard

The process of accessing a database by nature is meant to be difficult as
 data security is of utmost importance.
 You need to make sure your database is configured to accept connections
 from the network, that the configuration does not leave any security holes
 (pass in an MD5 hash of the database user's password for logging in, for
 example).
 If Java Web Start fails during the launch process the first time you attempt
 to deploy your application, it is likely due to a connection timeout attempting
 to access the database.
 This would be a good time to take a moment and review your database documentati
on and your database settings.
\layout Section

More About JWS
\layout Standard

Figure 
\begin_inset LatexCommand \ref{cap:JWS-MacClient}

\end_inset 

 depicts a MacOSX client application launched via Java Web Start.
 The database server in this instance is a PostgresQL cluster running on
 a nearby Linux machine.
\layout Standard


\begin_inset Float figure
placement H
wide false
collapsed true

\layout Standard
\align center 

\begin_inset Graphics
	filename figures/JWS-3.png
	lyxscale 50
	scale 40
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:JWS-MacClient}

\end_inset 

Java Web Start - Launched Application on a MacOSX Client
\end_inset 


\layout Standard

The first time the application is launched, Java Web Start will be downloading
 and installling an entire application.
 So the first launch will be fairly slow; it might take 30 seconds.
 Subsequent launches will not require the download (only a quick check for
 updates against the server) and consequently will take considerably less
 time.
\layout Standard

The hyperlink on the ContactMgr intranet page is only one way in which end
 users can launch their application.
 Java Web Start can be configured to place a shortcut for the application
 directly on the end user's desktop, for example.
\layout Section

Summary
\layout Standard

JMatter attempts to make the Java Web Start process as easy and painless
 as possible.
 Let's review what we just did:
\layout Enumerate

We invoked the 
\emph on 
ant jws-dist
\emph default 
 target, and
\layout Enumerate

extracted the generated 
\emph on 
.war
\emph default 
 file to the web server
\layout Enumerate

Visited the web page and clicked on a link, which triggered Java Web Start
\layout Standard

Anyone who's had to configure Java Web Start the 
\emph on 
normal
\emph default 
 way will certainly appreciate this.
\layout Chapter

A Desktop within a Desktop?
\layout Standard

Unlike most of the other chapters in this book, this one is philosophical
 in nature.
\layout Standard

One cannot help making the observation that the applications we're developing
 are desktop-like in nature.
 We end up having a desktop running within a operating system's desktop.
 The features of our applications' desktops are in many ways a replication
 of the features already built into our operating systems.
 The main difference being that instead of managing files and folders, we're
 in a sense extending the desktop to allow for the management of business
 objects, in any combination we choose.
 When we wrote our contact manager, that combination happens to consist
 of persons and businesses, for example.
\layout Section

Dreaming of a Better [Virtual] World
\layout Standard

The state of operating systems today looks all charming and wonderful.
 Take for example the new MacOS reborn in v10.0.
 Beautiful graphics, colors, lots of applications we can run.
 On the surface, it all looks and feels like a virtual garden of eden.
\layout Standard

I see a much colder, harsher landscape.
 I see a landscape of islands of processes that communicate with one another
 hardly ever.
 If they do, it's via messages in a bottle.
 One of the few ways for such applications to talk to one another is via
 the clipboard.
 You copy (or drag) some text or maybe an image from one application and
 paste it (or drop it) onto another.
 That's essentially the extent to which applications can communicate in
 an ad-hoc basis.
\layout Standard

Let's go a little further though.
 Let's think about the code required to implement an email application,
 a web browser, a word processor, our finance application, etc..
 Each application must fend for itself: each one has to build its own search
 features, its own mechanism for persisting information, its own user interace,
 its own mechanism for calendaring, for validating information, etc..
\layout Standard

This is not entirely true; the operating system does provide certain services
 that any application can avail itself to: reading a file, writing a record
 to a database perhaps, opening a socket, creating a button, a text field.
 Terrific.
 It's a start.
\layout Standard

Again what we see is that the notion of orthogonal services that can be
 provided to all the applications that run in an operating system is missing.
 If the ideas embodied in JMatter were to be applied to an operating system,
 then we could create a virtual world where our software applications would
 suddenly and dramatically shrink in size.
 The reason would be simple: all you'd have to do to build your application
 is define your model objects.
 Half of them would already be defined in other applications and you wouldn't
 be writing them from scratch: you'd be composing applications.
\layout Standard

Contributors to such an operating system might add new and interesting behaviors
 on existing objects.
 Maybe the ability for an email message object to receive an image object,
 maybe the ability to submit your financial information electronically to
 your accountant.
 You'd be able to file email messages in folders that you place on your
 desktop.
 The notion of multiple separate applications would vanish.
 They'd all run under a single application, managed by the operating system.
 When you're performing a search, you'll be searching your entire virtual
 world in the same way, regardless of whether you're looking for a piece
 of text in a file or an email message, or maybe looking for a financial
 transaction in a specific electronic account.
\layout Standard

We wouldn't need such large hard drives, and for many tasks, would not require
 such a fast microprocessor.
 Each application wouldn't request of the operating system a chunk of 50
 megabytes to run in; your memory footprint would drop.
\layout Standard

When you perform a software update, you'll be inheriting new orthogonal
 services: new capabilities that all of your objects would inherit, not
 just a single application.
\layout Standard

This is my vision for operating systems.
 It turns out these ideas are indeed very old ones.
 What I'm describing, to a certain extent, is Smalltalk.
\layout Standard

Indeed the ideas behing JMatter were inspired by the NakedObjects framework,
 which in turn was inspired by Smalltalk.
\layout Section

Collapsing the desktops
\layout Standard

So, my hope is that some day a single desktop will exist and the ideas in
 JMatter will be integrated into our operating systems.
 Until then, enjoy smashing your competition to bits with JMatter.
\layout Chapter

Conventions Reference
\layout Standard


\emph on 
JMatter Conventions reference (tabviews, fieldorder, icon naming conventions)
 [tbd]
\layout Chapter

The State of JMatter
\layout Standard

We have seen that JMatter today offers a compelling number of features including
:
\layout Enumerate

A rich and full-featured graphical user interface,
\layout Enumerate

Powerful query capabilities
\layout Enumerate

Smart lists
\layout Enumerate

Authentication
\layout Enumerate

Logging
\layout Enumerate

Calendaring
\layout Enumerate

Integration with JFreeReport
\layout Enumerate

Persistence via Hibernate
\layout Enumerate

The ability to run an application in a distributed environment via Java
 Web Start,
\layout Enumerate

Support for exporting lists as Comma-Separated Values (CSV)
\layout Enumerate

XML Import/Export Features for types that define a JiBX binding (not yet
 documented)
\layout Enumerate

Support for wizards
\layout Enumerate

Polymorphic modeling support: interfaces, inheritance, etc..
\layout Enumerate

A rich set of pre-defined basic types
\layout Enumerate

The ability to extend the user interface with custom views
\layout Enumerate

Not having to deal with threading issues
\layout Enumerate

The beginnings of a promising authorization system
\layout Enumerate

Categorization via folders
\layout Enumerate

The ability to customize the class bar directly from the UI
\layout Enumerate

The ability to view meta-information (and soon the ability to edit some
 of that meta-information directly from the ui).
\layout Standard

This chapter is about conveying to you my vision for JMatter: what other
 features you're likely to see in the future.
 Here's a brief outline of my thoughts at the moment:
\layout Enumerate

A complete authorization system, one whose policy is specified directly
 from the user interface
\layout Enumerate

The ability to specify the field captions, defaults, whether a field is
 required, command captions, field ordering, even some aspects of laying
 out the user interface, directly from the user interface itself
\layout Enumerate

Per-User Class Bar
\layout Enumerate

More powerful UI widgets: an editable table to edit multiple objects together;
 a double-list widget to add items to a list more quickly; a 
\emph on 
trash can
\emph default 
 where deleted items end up, to protect against deletions
\layout Enumerate

Generally, the ability to perform operations on a list of objects at the
 same time (support for multipe-selections from lists), in batch so to speak
\layout Enumerate

A distributed real-time publish/subscribe system so that multiple users
 logged in to the system can see each other, communicate with each other,
 and so that actions performed by one user are immediately reflected in
 other users' desktops
\layout Enumerate

Improvements to the calendaring and scheduling system
\layout Enumerate

Undo/Redo capabilities
\layout Enumerate

Modularization: the ability to pick and choose the combination of features
 one wants to deploy and including only those jar files (smaller footprint);
 e.g.
 JMatter without calendaring support
\layout Enumerate

Complete reporting support: report definition, specification and production
 (PDF and other formats)
\layout Enumerate

Charting service (look into jfreechart)
\layout Standard

This shorter, though ambitious listing is contemplated tentatively at the
 moment:
\layout Enumerate

A web-based user interface: the ability to support web-based clients in
 addition to rich clients
\layout Enumerate

Possibly an extension of the architecture to support the construction of
 large enterprise applications.
 That is, a second, alternative architecture that is n-tier by nature, with
 application servers sitting between the database server and clients
\layout Enumerate

Possibly a move to Java 5 annotations for specifying metadata
\layout Standard

I hope that after reading this document, that you now have a good feel for
 the JMatter philosophy, the JMatter way of doing things.
 It is my sincere belief that the JMatter way is the way forward for the
 software development industry.
\layout Chapter

Summary
\layout Standard

[tbd] [points to make: - a review of what we did - revisiting to original
 premises - most books struggle to build one example application; this book
 gives you four.
 i hope this is one of the many ways that this book illustrates the revolutionar
y nature of jmatter.
\layout Chapter
\start_of_appendix 
Keyboard Shortcuts
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="8" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="3.5in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

ShortCut
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Description
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Alt-`
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Analogous to the alt-tab mechanism for switching between windows on your
 desktop
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Alt-1, Alt-2, etc..
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

In a window with multiple tabs, switch to the first, second, [etc..] tab
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Ctrl-w
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Closes the currently focused window
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Ctrl-n
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

When a view of a listing is in focus, a shortcut for the command 
\emph on 
New
\emph default 
 on the listing's elements type.
 For example, if viewing a listing of Persons, instead of right-clicking
 
\emph on 
New
\emph default 
 in the titlebar, just press Ctrl-n
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

F12
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Invokes 
\emph on 
JExplose
\emph default 
, a feature similar to Apple's 
\emph on 
Expose,
\emph default 
 that will automatically scale and sort all of the windows on your desktop
 in order to facilitate the selection and management of multiple windows.
 This feature can also be invoked from the Desktop's context menu (right-click
 on an empty spot on your desktop to bring up this menu).
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Ctrl-command
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

When invoking a command that generates a view window: if you find yourself
 frequently repositioning the generated window, then this shortcut is for
 you.
 By holding down the Ctrl key while invoking the command (either clicking
 on the button or right-clicking on a context menu item), then the generated
 window will be bound to your mouse: it will follow your mouse's movements.
 When you find the ideal place to position the newly-created window, just
 click with your mouse to 
\emph on 
pin
\emph default 
 it down into place.
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Ctrl-q
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Quit the application
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Chapter

Programmers Take Issue
\layout Standard

Here are a list of 
\emph on 
issues
\emph default 
 that programmers have with frameworks similar to JMatter.
\layout Section

Too Many Windows
\layout Standard

I've heard people complain that JMatter application user interfaces are
 unwieldy because they can have too many windows open at one time, leading
 to confusion.
\layout Standard

There are ways to manage a desktop, and they're pretty well-known.
 Here are some:
\layout Enumerate

Virtual Desktops: many operating systems such as Linux and the MacOS either
 come with this feature or have utilities that can be installed to provide
 this feature.
 Mutliple desktops mitigates the problem of too many windows overlapping
 one another.
 You can use one desktop for Email, the other for Web, and the third for
 desktop apps, for example.
\layout Enumerate

Alt-Tab: This simple keystroke allowing one to switch from one window to
 the next has become ubiquitous across operating systems.
 In JMatter, the equivalent is Alt-`.
\layout Enumerate

Minimizing or hiding windows: again, many operating systems provide ways
 for windows to be automatically hidden or put out of sight while one focuses
 on the specific task at hand.
 I believe the MacOS is an example to follow of how they provide ways for
 one to manage multiple windows effectively.
\layout Enumerate

A Docking Framework: docking frameworks put the end-user in control of how
 things are laid out on the screen.
 Windows can be docked to the edges of the screen, they can 
\emph on 
float
\emph default 
 on the desktop, or they can be superimposed in a tabbed pane.
\layout Standard

The JMatter Business Application Desktop has already integrated 
\emph on 
JExplose
\emph default 
, a feature similar to Apple's 
\emph on 
Expose
\emph default 
, precisely for the purpose of making it easier to manage your desktop.
 The next features we will investigate integrating include [a] an enhanced
 layout manager for the desktop that will allow users the freedom to dock
 their windows to the edges of the application's frame, and [b] features
 similar to ones sported by file managers, including the ability to navigate
 in place from one object to another without opening new windows (that is,
 reusing a single window).
\layout Section

Must Extend A Base Class
\begin_inset LatexCommand \label{sec:Must-Extend}

\end_inset 


\layout Standard

The notion of favoring interfaces over inheritance in object oriented programmin
g is well-established and undisputed today.
 And I agree with it.
 This particular gripe, which I first encountered in the context of the
 NakedObjects framework, had me at a loss for some time.
 Then it occurred to me, that no one complains about the restriction that
 every Java class they must author must inherit from the class 
\emph on 
java.lang.Object
\emph default 
.
 I've come to realize that the JMatter framework's requirement is no different
 from the notion that all objects must have a base class, whether they like
 it or not.
 The advantage of course is that they all inherit a common set of capabilities.
 In the case of java.lang.Object, they don't really get much for their money,
 so to speak.
 With JMatter, they get a little more: a user interface, persistence, logging,
 query capabilities, etc..
\layout Section


\emph on 
ValueHolder
\emph default 
 Types vs POJO's
\begin_inset LatexCommand \label{sec:ValueHolder-vs-POJO}

\end_inset 


\layout Standard

The introduction (by Sun Microsystems and its partners) of Java Enterprise
 Edition to the world in the late 1990's was a momentous event.
 Today JEE is the standard for building enterprise applications that can
 support large numbers of users, systems that are tolerant of a certain
 degree of failure, etc..
\layout Standard

But it wasn't all rosy.
 Developers had to submit to stringent conventions for writing Enterprise
 Java Beans.
 In time, developers came to rebel against the model of having to provide
 seven files for each and every Enterprise Bean.
 The term POJO was born: the yearning to go back to the days of Java Standard
 Edition, when one had to write a single file: the Java Class.
 This single file came to be known as a POJO: the Plain-Old Java Object.
\layout Standard

Along comes NakedOjbects.
 And along with it comes the notion of Value objects, which are ValueHolder
 types.
 The notion of the ValueHolder has its roots in Smalltalk.
 In Smalltalk the ValueHolder is an adapter for atomic types such as numbers
 or pieces of text (Strings).
 The need for the adapter was simple: in order for these bits of information
 to actually work in the context of an MVC (Model-View-Controller) application,
 the information had to act as a model object: it had to be able to notify
 a view when its value changed.
 This permits the view to properly reflect the current model object's value.
\layout Standard

In JMatter as well as in NakedObjects the notion of ValueHolders is actually
 integrated into these atomic types.
 They all have ValueHolder capabilities, and for obvious reasons.
\layout Standard

The developer community took issue to this.
 They didn't like having to replace their beloved java.lang.String with org.nakedoj
bects.value.TextString or with com.u2d.type.atomic.StringEO.
 They went as far as invoking the POJO clause: 
\emph on 
we want our plain old java objects back
\emph default 
!
\layout Standard

I heartily disagree.
 A POJO implies a single class file.
 TextString's and StringEO's are POJO's.
 Developing JMatter or NakedObjects applications has nothing in common with
 the old model of writing Java enterprise applications.
 If anything, they are the antithesis of that.
 Developers are not burdened by the conventions of JMatter, they are freed
 by them.
\layout Standard

So, I take issue with the statement that ValueHolders are not POJO's.
 Indeed they are.
 The term is used in error in this context.
\layout Comment

Consider writing another chapter: [Content Manager]
\layout Comment

A typical blog system editor/manager/poster [tbd]
\layout Comment

Consider writing another chapter: [Photo Album]
\layout Comment

Illustrate custom views
\layout Standard

.
\layout Comment

Address aspects of JMatter that are not discussed/covered? JiBX Integration,
 Polymorphic modeling
\the_end
