#LyX 1.5.3 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{textcomp}
\usepackage{mathpazo}
\usepackage[scaled=0.9]{helvet}
\usepackage[scaled=0.75]{beramono}
\usepackage[bookmarks, bookmarksopen=true, bookmarksopenlevel=0, bookmarksnumbered=true, colorlinks=true, linkcolor=blue, pdftitle={Building Software Applications with JMatter}, pdfauthor={Eitan Suez}]{hyperref}
\raggedbottom
\title{Building Software Applications with JMatter}
\author{Eitan Suez}
\date{ }
\end_preamble
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\float_placement H
\paperfontsize default
\spacing single
\papersize custom
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\paperwidth 7.44in
\paperheight 9.68in
\leftmargin 1.5in
\topmargin 1.1in
\rightmargin 1in
\bottommargin 1.1in
\headheight 0.3in
\headsep 0.5in
\footskip 0.8in
\secnumdepth 3
\tocdepth 1
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle empty
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
frontmatter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 1in*
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\size larger
Building Software Applications
\end_layout

\begin_layout Standard
\noindent
\align center

\size normal
with
\end_layout

\begin_layout Standard
\noindent
\align center

\series bold
\size giant
JM
\noun on
atter
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Standard
\noindent
\align center

\size larger
\begin_inset VSpace 1in*
\end_inset


\lyxline
Building Software Applications
\end_layout

\begin_layout Standard
\noindent
\align center

\size normal
with
\end_layout

\begin_layout Standard
\noindent
\align center

\series bold
\size giant
JM
\noun on
atter
\series default
\size huge
\noun default

\lyxline

\end_layout

\begin_layout Standard
\noindent
\align right

\size large
\emph on
Eitan Suez
\size huge
\emph default

\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
February 2008
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Graphics
	filename logo.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Standard


\backslash
copyright
\end_layout

\end_inset

 \InsetSpace \space{}
2008 JMatterSoft LLC.
 All rights reserved.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard

\series bold

\lyxline
On the Cover
\end_layout

\begin_layout Standard

\size footnotesize
The sport of windsurfing conveys qualities of speed and agility, qualities
 that I believe are also born by the software framework JMatter in the field
 of software development.
 A sincere thanks goes to the StarBoard company, to the rider, and to the
 photographer, for the permission to use the photograph on the cover of
 this book.
 Photo Details:
\end_layout

\begin_layout Itemize

\size footnotesize
Board: 2008 StarBoard Evo XTV
\end_layout

\begin_layout Itemize

\size footnotesize
Rider: Kevin Pritchard
\end_layout

\begin_layout Itemize

\size footnotesize
Photographer: Tiesda You
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
This book was typeset and produced using Open Source software.
 LyX was used for typesetting and layout.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize

\lyxline

\end_layout

\begin_layout Standard

\size footnotesize
Suez, Eitan
\newline
Building Software Applications with JMatter
\end_layout

\begin_layout Standard

\size footnotesize
Bibliography.
\newline
ISBN: This publication is not yet registered with an ISBN Agency
\end_layout

\begin_layout Standard

\size footnotesize
\InsetSpace ~

\end_layout

\begin_layout Standard

\size footnotesize
\InsetSpace ~

\end_layout

\begin_layout Standard

\size footnotesize

\lyxline

\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
pagestyle{plain}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
mainmatter 
\backslash
pagestyle{headings}
\end_layout

\end_inset


\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Chapter
Overview
\end_layout

\begin_layout Standard
Welcome! 
\emph on
JMatter
\emph default
 is a software application framework.
 It is designed specifically for building business software applications
 for work groups.
 Examples might include accounting software, software for legal firms, medical
 software for small practices, software for auto mechanic shops, software
 for small software development shops, and more
\begin_inset Foot
status collapsed

\begin_layout Standard
By 
\emph on
small
\emph default
 we mean organizations with up to 100 users.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The principal advantage of developing a business software application with
 JMatter is a dramatic reduction in development time.
 It is not an exaggeration to say that the difference in development time
 compared to traditional methods is roughly a factor of 10! That is, one
 order of magnitude.
\end_layout

\begin_layout Standard
Take for example, the Issue Manager demo application described in chapter
 
\begin_inset LatexCommand vref
reference "cha:Issue-Manager"

\end_inset

.
 Surprisingly, even though this application is presented as a 
\begin_inset Quotes eld
\end_inset

demo
\begin_inset Quotes erd
\end_inset

, it nevertheless is a complete and working Issue Management software applicatio
n that can be used for day-to-day tracking and management of software issues.
 The authors of the JMatter framework used this application for some time
 for tracking bugs and enhancements to JMatter.
\end_layout

\begin_layout Standard
This Issue Manager software application was implemented by a single developer
 in roughly four hours.
 Contrast this to comparable systems such as 
\begin_inset LatexCommand htmlurl
name "Bugzilla"
target "http://www.bugzilla.org/"

\end_inset

, 
\begin_inset LatexCommand htmlurl
name "JIRA"
target "http://jira.atlassian.com/"

\end_inset

, and 
\begin_inset LatexCommand htmlurl
name "trac"
target "http://www.edgewall.com/trac"

\end_inset

 which, albeit may have a few more features, have taken somewhere in the
 neighborhood of one or more man-years to develop.
\end_layout

\begin_layout Standard
Equally important is the number of lines of code necessary to implement
 such a software application.
 Using JMatter, the entire Issue Manager application consists of 300 lines
 of code at the moment, including white-space (blank lines), strewn across
 
\emph on
three
\emph default
 Java classes.
 Compare that to approximately 13,000 lines of python code
\begin_inset Foot
status collapsed

\begin_layout Standard
Measured using 
\emph on
wc -l
\emph default
 on 
\emph on
python-2.4/site-packages/trac
\end_layout

\end_inset

 in 
\emph on
trac
\emph default
 spread among roughly 170 files (I don't mean to pick on trac, which is
 a very nice issue management application; I just happen to have a copy
 installed on my computer).
\end_layout

\begin_layout Standard
This brings up another point: the JMatter framework is written in the Java
 programming language.
 This means that your software applications can run in a heterogeneous IT
 environment, on a variety of operation systems including the plethora of
 GNU/Linux OS's, Solaris, MacOSX, and the various flavors of Windows
\begin_inset Foot
status collapsed

\begin_layout Standard
This includes both the client and server portions of the solution.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Software development professionals or teams that use the JMatter framework
 therefore enjoy a significant competitive advantage over other software
 development firms that employ more traditional methods of developing software.
\end_layout

\begin_layout Standard
At this point you should be asking yourself some very important questions:
 
\emph on
Can this really be? How? Is it really possible to shave 90% or more of an
 application's code? To deliver software in so much less time?
\end_layout

\begin_layout Section
How?
\end_layout

\begin_layout Standard
Let's take a moment to reflect on how software applications are constructed.
 The reason for developers' high productivity with JMatter is simple, but
 needs some elaboration.
\end_layout

\begin_layout Standard
All applications have a great deal in common.
 Examples include, a login dialog, the need for authentication (controlling
 who can and cannot access the system), etc\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
Believe it or not though, most developers build these same features over
 and over again each time they work on a new application.
 With JMatter, things are different.
 JMatter provides those common things so that developers don't have to start
 from scratch each time.
 You won't find a single line of authentication code in a software application
 constructed using JMatter; that's all tucked away in the framework.
\end_layout

\begin_layout Standard
If it were all about login dialogs, JMatter wouldn't buy you very much.
 What sets JMatter apart is the fact that there are plenty more things that
 developers write from scratch for each new application; things that are
 common to them all.
 Here are some of them:
\end_layout

\begin_layout Description
A\InsetSpace ~
User\InsetSpace ~
Interface
\end_layout

\begin_deeper
\begin_layout Standard
A window, the ability to create new users, change their passwords, the ability
 to create a new contact, edit the address for an existing contact, delete
 an old contact.
 The basic need to Create, view (Read), Update, and Delete information is
 termed 
\emph on
CRUD
\emph default
.
 It's true that for each type of thing you're creating (a User, a Business,
 a Person, etc..), the forms will vary because each thing contains a different
 set of fields.
 However, the mechanism is the same.
 Developing a user interface from scratch is a very tedious job.
 Estimates state that approximately 60% of the time spent developing an
 application is spent constructing its user interface;
\end_layout

\end_deeper
\begin_layout Description
Query\InsetSpace ~
Services
\end_layout

\begin_deeper
\begin_layout Standard
The basic need to filter information.
 For example, the ability to ask the question: 
\emph on
Display all Persons who live in a certain city;
\end_layout

\end_deeper
\begin_layout Description
Validation 
\end_layout

\begin_deeper
\begin_layout Standard
The ability to specify which fields are required, which are optional, what
 constitutes a valid phone number, date, etc..
 when performing form entry tasks;
\end_layout

\end_deeper
\begin_layout Description
Persistence
\end_layout

\begin_deeper
\begin_layout Standard
The ability to save information, associations between objects, and more;
\end_layout

\end_deeper
\begin_layout Description
Calendaring
\end_layout

\begin_deeper
\begin_layout Standard
Many varying applications have the basic need to deal with time: scheduling
 activities, looking up and manipulating events on a calendar, etc..;
\end_layout

\end_deeper
\begin_layout Description
Basic\InsetSpace ~
knowledge\InsetSpace ~
of\InsetSpace ~
simple\InsetSpace ~
types\InsetSpace ~
of\InsetSpace ~
information
\end_layout

\begin_deeper
\begin_layout Standard
So many business applications need to process dates, phone numbers, social
 security numbers, images, passwords, percentages, currencies, names, addresses,
 notes, and more.
 Yet here again, you will discover software developers spending time [re-]writin
g code to parse, validate, and format such basic information as a phone
 number;
\end_layout

\end_deeper
\begin_layout Description
Logging
\end_layout

\begin_deeper
\begin_layout Standard
Tracking activity in the system, the fact that someone logged in at a specific
 time, that they deleted an entry, etc..;
\end_layout

\end_deeper
\begin_layout Description
Authorization
\end_layout

\begin_deeper
\begin_layout Standard
Specifying who is allowed to perform what actions in a system;
\end_layout

\end_deeper
\begin_layout Description
Reporting
\end_layout

\begin_deeper
\begin_layout Standard
The ability to produce printable (PDF) reports from the information that
 an application manages;
\end_layout

\end_deeper
\begin_layout Description
Wizards
\end_layout

\begin_deeper
\begin_layout Standard
A component of user interface construction, often used to break down complex
 tasks into a series of steps.
\end_layout

\end_deeper
\begin_layout Standard
Most of this work has nothing to do with the specific problem domain: they're
 generic services that all applications should have, but that [unfortunately]
 are constructed from scratch each time
\begin_inset Foot
status collapsed

\begin_layout Standard
or not! It's rare to find a complete application that provides all of these
 services.
\end_layout

\end_inset

.
 I like to say that these services are 
\emph on
orthogonal
\emph default
 to the problem domain.
\end_layout

\begin_layout Standard
We can see now why software projects are often delivered late and over budget:
 developers have a great deal of work to perform when building even the
 most basic of business applications.
 Before they have a chance to begin working on the problem domain, they're
 faced with building an entire software infrastructure.
 The end-result is often a combination of:
\end_layout

\begin_layout Itemize
a poorly-constructed general foundation for an application that is tightly
 and needlessly coupled to the problem domain
\end_layout

\begin_layout Itemize
a solution that compromises the end-user's feature requirements to stay
 within time and cost constraints
\end_layout

\begin_layout Standard
JMatter promises to empower developers to work on the task at hand without
 having to build a foundation.
 At the time of this writing, JMatter provides most of the listed orthogonal
 services.
 The implementation of a built-in, generic Authorization system has recently
 been completed.
\end_layout

\begin_layout Standard
The predominant architecture for software applications today is known as
 Model-View-Controller.
 You can think of JMatter as providing a complete and generic View-Controller
 implementation, leaving developers to work on the Model.
\end_layout

\begin_layout Standard
So to sum things up for now, the JMatter framework's goal is to provide
 all of these orthogonal services, 
\emph on
out of the box
\emph default
, so to speak without requiring 
\emph on
any
\emph default
 extra effort on the part of the application developer.
\end_layout

\begin_layout Section
Architecture
\end_layout

\begin_layout Standard
Before diving into JMatter, let's briefly discuss what types of applications
 JMatter produces.
 What is their architecture? What language are these applications written
 in? What operating systems can they be deployed onto, etc..
\end_layout

\begin_layout Standard
The JMatter framework and JMatter-based applications are written in the
 Java programming language.
 The implication is primarily that these applications can run on a number
 of target operating systems, from windows computers, to macs, to the variety
 of GNU/Linux operating systems out there, as well as other flavors of Unix
 such as Solaris and BSD.
\end_layout

\begin_layout Standard
JMatter applications by design produce software applications where all data
 is persisted to a back-end relational database.
 Databases provide powerful query capabilities that are the foundation for
 many business needs.
 The JMatter framework uses the Hibernate 
\begin_inset Foot
status collapsed

\begin_layout Standard
see 
\begin_inset LatexCommand url
target "http://hibernate.org/"

\end_inset


\end_layout

\end_inset

 framework to communicate to back-end databases.
 This affords the framework database independence.
 JMatter applications are compatible with a number of back-end database
 systems.
 It has been tested with PostgresQL, MySQL, and Oracle databases, as well
 as newer and more lightweight database systems such as H2 and hsqldb.
 These back-end databases are available for a large number of operating
 systems.
\end_layout

\begin_layout Standard
On the client side, JMatter leverages the Java Swing Toolkit to produce
 rich client applications.
 These user interfaces are platform-independent.
\end_layout

\begin_layout Standard
The overall architecture has two tiers: the client application communicates
 over the network to the back-end database.
 Multiple clients are installed on multiple workstations, and multiple users
 can access the system concurrently.
\end_layout

\begin_layout Standard
This type of architecture is suitable for local area network deployment,
 or the wide area network, over a VPN 
\begin_inset Foot
status collapsed

\begin_layout Standard
Virtual Private Network
\end_layout

\end_inset

 connection.
 A number of database systems today can be configured for communications
 over SSL, making it possible to deploy such solutions over a wide area
 network without requiring a VPN solution.
\end_layout

\begin_layout Standard
To automate the task of installing clients on multiple workstations, and
 of keeping these installations up to date, JMatter leverages Java WebStart.
 Chapter 
\begin_inset LatexCommand ref
reference "cha:Deploying-your-Application"

\end_inset

 is devoted to the specifics of deploying JMatter applications using this
 technology.
\end_layout

\begin_layout Standard
At the time of writing, JMatter already has early (alpha quality) implementation
s of the infrastructure necessary to deploy the very same applications over
 the world wide web, using a three-tier architecture.
 We hope to release a final implementation some time in 2008.
 This will give users the ability to deploy their applications either to
 the web or using Swing, or both (a mixed population of users).
\end_layout

\begin_layout Section
Seeing is believing
\end_layout

\begin_layout Standard
Here's what lays ahead in the upcoming chapters: we'll walk through installing
 JMatter on your system.
 Then we'll begin by studying one of the JMatter demo applications: the
 
\emph on
Contact Manager
\emph default
 (Chapter 
\begin_inset LatexCommand ref
reference "cha:A-Short-Tour"

\end_inset

).
 By the end of that chapter, you'll have a good feel for JMatter applications,
 what they look like, how to interact with them.
\end_layout

\begin_layout Standard
Part 2 of this manual focuses on teaching you how to write JMatter applications
 by example.
 We'll start by building our own contact management software.
 In each succeeding chapter we'll build a new application, each one building
 upon the notions learned in the preceding chapters.
 All of the tutorial applications documented here are included in the JMatter
 framework distribution.
\end_layout

\begin_layout Standard
The third part of this manual aims to provide a complete reference of the
 JMatter framework.
 That's where you'll find detailed information on the various features of
 the framework, options, and conventions to adhere to.
\end_layout

\begin_layout Standard
Bold claims have been made in this introduction.
 Coming from the authors of the JMatter framework, these should be regarded
 with a healthy dose of skepticism.
 It is for you, the reader, to judge the cost-benefit proposition of the
 JMatter framework for delivering software applications.
 This document arms you with the information necessary to make that judgment.
\end_layout

\begin_layout Chapter
Software Installation
\end_layout

\begin_layout Standard
In this chapter we'll focus on the steps to install JMatter on your system.
 Let's begin with the prerequisites.
\end_layout

\begin_layout Section
Prerequisites
\end_layout

\begin_layout Subsection
Java Standard Edition, version 5 (JSE 5) or later
\begin_inset OptArg
status open

\begin_layout Standard
Java SE v5 or later
\end_layout

\end_inset


\end_layout

\begin_layout Standard
JMatter is a Java-based framework and thus requires Java Standard Edition
 from Sun Microsystems.
 Download a copy from 
\begin_inset LatexCommand htmlurl
target "http://java.sun.com"

\end_inset

.
\end_layout

\begin_layout Subsection
Ant
\end_layout

\begin_layout Standard
Ant is a Java build tool which JMatter heavily relies upon.
 You can obtain 
\emph on
ant
\emph default
 from 
\begin_inset LatexCommand htmlurl
target "http://ant.apache.org/"

\end_inset

.
\end_layout

\begin_layout Standard
After installing 
\emph on
ant
\emph default
, verify that it is properly installed by typing:
\end_layout

\begin_layout LyX-Code
ant -version
\end_layout

\begin_layout Standard
at the command prompt.
 Here is what the output of the above command looks like on my screen:
\end_layout

\begin_layout LyX-Code
Apache Ant version 1.6.5 compiled on July 5 2006
\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
Visit the JMatter web site at 
\begin_inset LatexCommand url
target "http://jmatter.org/"

\end_inset

 and click on the Download link in the sidebar.
 You have the option of downloading the software either as a zip file or
 as a tgz archive (a compressed tar file).
 Both files are otherwise identical.
\end_layout

\begin_layout Standard
Go ahead and download the version you prefer and unpack it.
\end_layout

\begin_layout LyX-Code
unzip jmatter-<date>.zip
\end_layout

\begin_layout Standard
You should now have a folder named 
\emph on
jmatter
\emph default
-<date>, containing these folders:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Folder Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
demo-apps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where JMatter tutorial applications reside
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
jmatter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The core of the JMatter framework
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
modules
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Various modules which the framework relies upon
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
AppBrowser
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The JMatter Application Browser 
\begin_inset Foot
status collapsed

\begin_layout Standard
(See chapter 
\begin_inset LatexCommand ref
reference "cha:Deployment,-Take-II:"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
If applicable, place a copy of the JDBC driver 
\emph on
.jar file
\emph default
 for your database in JMatter's 
\emph on
lib/runtime/jdbc
\emph default
 subdirectory (see Appendix 
\begin_inset LatexCommand ref
reference "cha:Database-Setup"

\end_inset

).
\end_layout

\begin_layout Standard
That's it.
\end_layout

\begin_layout Chapter
A Short Tour
\begin_inset LatexCommand label
name "cha:A-Short-Tour"

\end_inset


\end_layout

\begin_layout Standard
Let's take a first look at a software application developed using JMatter.
 We're going to setup and launch, and then study the 
\emph on
Contact Manager
\emph default
 demo application that is bundled with JMatter.
 You will find it in 
\emph on
demo-apps/ContactMgr
\emph default
.
\end_layout

\begin_layout Section
Launching ContactMgr
\end_layout

\begin_layout Standard
Follow these steps
\begin_inset Foot
status collapsed

\begin_layout Standard
The '$' symbol prefixing each command serves to indicate the command line
 and is not part of the command
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
$ cd demo-apps/ContactMgr
\end_layout

\begin_layout LyX-Code
$ ant schema-export
\end_layout

\begin_layout Standard
From the tutorial application's base directory, issuing the 
\emph on
schema-export
\emph default
 command (an ant target) for the first time will:
\end_layout

\begin_layout Enumerate
compile the framework,
\end_layout

\begin_layout Enumerate
compile the tutorial application's code,
\end_layout

\begin_layout Enumerate
create an H2 database (in subdirectory 
\emph on
db/
\emph default
 ),
\end_layout

\begin_layout Enumerate
generate the necessary o/r mapping files for the application, and 
\end_layout

\begin_layout Enumerate
subsequently generates the actual database schema.
\end_layout

\begin_layout Standard
Next, let's launch our application:
\end_layout

\begin_layout LyX-Code
$ ant run
\end_layout

\begin_layout Standard
This command is simply a convenient way of launching the application during
 development.
\end_layout

\begin_layout Standard
JMatter applications are designed to be multi-user applications, running
 in client-server mode.
 The framework supports the task of deploying applications using Sun's Java
 WebStart technology.
 Please refer to chapter 
\begin_inset LatexCommand ref
reference "cha:Deploying-your-Application"

\end_inset

 for complete documentation pertaining to deploying applications.
\end_layout

\begin_layout Standard
If you prefer to configure your own MySQL or PostgresQL database, please
 refer to appendix 
\begin_inset LatexCommand ref
reference "cha:Database-Setup"

\end_inset

.
\end_layout

\begin_layout Section
The Tour
\end_layout

\begin_layout Standard
OK, we've just launched our first JMatter application.
 We should be greeted with the login screen shown in figure 
\begin_inset LatexCommand ref
reference "cap:Contact-Manager-Login"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CM-1.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Contact-Manager-Login"

\end_inset

Contact Manager Login Screen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When an application is first created, a single user will exist in the system.
 The user name and password values are 
\emph on
admin
\emph default
.
 Later on, we'll show you how to change the admin password.
\end_layout

\begin_layout Standard
Go ahead and login.
 You are now presented to your application's 
\emph on
desktop
\emph default
 (see figure 
\begin_inset LatexCommand ref
reference "cap:Contact-Manager-Desktop"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CM-2.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Contact-Manager-Desktop"

\end_inset

Contact Manager Application Desktop
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
A Quick Orientation to the User Interface
\end_layout

\begin_layout Standard
On the left hand side you see a toolbar.
 This toolbar is a little different from most application toolbars.
 Instead of containing various actions (such as 
\emph on
copy
\emph default
, 
\emph on
paste
\emph default
, and others typically found in a word processing application, for example),
 this toolbar contains types of things: Persons, Businesses, Users, Folders,
 etc..
 I'm going to call this toolbar the 
\emph on
Class Bar
\emph default
 from here on.
 Furthermore, I will often reference the term as a single, lower-cased word:
 classbar.
\end_layout

\begin_layout Standard
The JMatter user interface was designed to be simple and easy to understand.
 The mechanism for communicating various activities to the application mirrors
 the way we naturally tend to think about how to perform actions.
 We first identify the object in question, and then specify the action to
 perform.
\end_layout

\begin_layout Standard
In JMatter applications, when an object is displayed in a minimized form
 (which is the case with the various objects we see in the classbar), the
 various actions to invoke are accessible via a context menu, summoned by
 right-clicking on the object in question.
\end_layout

\begin_layout Standard
This gesture should be a familiar one.
 For example, on the windows desktop, right-clicking on a file or folder
 will 
\begin_inset Quotes eld
\end_inset

bring up
\begin_inset Quotes erd
\end_inset

 its context menu.
 On the MacOS with a two-button mouse, it's the same gesture (simulated
 as a ctrl-click on a 1-button mouse).
 GNU/Linux-based desktops have the same metaphor.
 The mechanism of first selecting an object, and then selecting an action
 is known as a 
\emph on
noun-verb user interface metaphor
\emph default

\begin_inset Foot
status collapsed

\begin_layout Standard
It's worthwhile noting that many applications' user interfaces today don't
 abide by this metaphor.
 Typical applications' toolbars contain actions and it's not entirely clear
 what objects they relate to.
 When working with menus, you'll pick an action first and an object second
 (think about how we usually open files in software applications: we pick
 the open action first and select the file second).
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
So for example, to browse the list of users defined in the system, you can
 move your mouse to the 
\emph on
Users
\emph default
 icon, right-click on it and a menu of actions will appear.
 One of these actions is the 
\emph on
Browse
\emph default
 action.
 Go ahead and browse 
\emph on
Users
\emph default
.
 You should see something similar to figure 
\begin_inset LatexCommand ref
reference "cap:Users"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CM-3.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Users"

\end_inset

Users
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I promised I'd show you how to change the 
\emph on
admin
\emph default
 user's password.
 Let's do this now:
\end_layout

\begin_layout Enumerate
Right-click on the 
\emph on
admin
\emph default
 user in the list
\end_layout

\begin_layout Enumerate
Select the action 
\emph on
Change Password
\end_layout

\begin_layout Enumerate
You will be presented with a dialog and prompted to enter the new password
 (twice, to guard against typos)
\end_layout

\begin_layout Standard
The next time you log in to the application, you'll have to enter the new
 password.
 JMatter stores an md5 hash of the password in the database and so passwords
 are not vulnerable to prying eyes.
\end_layout

\begin_layout Standard
Close the window containing the listing of users for now.
 Let's go ahead and add a person to our contact manager.
 You've probably already guessed how to do it: right-click on the 
\emph on
Persons
\emph default
 icon in the 
\emph on
Class Bar
\emph default
.
 Sure enough there's an action on its context menu called 
\emph on
New
\emph default
.
 That's the one.
\end_layout

\begin_layout Standard
Your screen should now look like figure 
\begin_inset LatexCommand ref
reference "cap:New-Person"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CM-4.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:New-Person"

\end_inset

Creating a new Person
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Go ahead and complete the form.
 Note that there are two tabs' worth of information to enter: the person's
 name 
\emph on
and
\emph default
 their contact information.
 Furthermore, the second tab contains a collapsible element: the address
 portion of the contact information can be expanded to reveal the address
 fields (street, city, state, zip, etc..).
 After you've finished entering the information, go ahead and click the
 
\emph on
Save
\emph default
 button.
 Your view of the information you just entered will change to a read-only
 mode.
 To edit the information further, click the 
\emph on
Edit
\emph default
 button.
 Don't worry if you closed the window.
 Your information has been saved and you can retrieve this new person's
 information at any time.
 Note that other users logged in to the system can also view the contact
 information for this new person.
\end_layout

\begin_layout Standard
Right-click 
\emph on
Browse
\emph default
 on 
\emph on
Persons
\emph default
 to view a listing of all the persons in your system.
 If you have a system with 300 persons in them, JMatter will make sure to
 page the listing 15 entries at a time
\begin_inset Foot
status collapsed

\begin_layout Standard
The page size can be customized.
\end_layout

\end_inset

.
 Also, notice that if you modify the 
\emph on
Preferred Contact Method
\emph default
 for a person from, say, 
\emph on
Home Phone
\emph default
 to 
\emph on
Email
\emph default
, then when you're viewing that person in a minimized context (say browsing
 through a list of persons), the title for that person will automatically
 change.
 In the former case, it might say 
\emph on
Joe Burns, (512) 333-444
\emph default
 and in the latter case it will change to 
\emph on
Joe Burns, jb@yahoo.com
\emph default
.
\end_layout

\begin_layout Standard
You can also create objects of type 
\emph on
Business
\emph default
, for example, if you need to keep track of contact information for various
 businesses that you interact with.
 The mechanism for performing 
\emph on
CRUD
\begin_inset Foot
status collapsed

\begin_layout Standard
CRUD: Create, Read, Update, Delete
\end_layout

\end_inset


\emph default
 operations on any type (Person, Business, User, etc..) is the same.
\end_layout

\begin_layout Standard
Lastly, notice that you can delete persons, though we want to prevent the
 possibility of accidental deletion of important information.
 JMatter does this by protecting the 
\emph on
Delete
\emph default
 action with a lock.
 Just click on the lock first to unlock the action and then click on the
 button to perform the deletion.
\end_layout

\begin_layout Standard
It's important to note that JMatter applications' user interfaces are very
 simple: they boil down to the implementation of a single concept: the noun-verb
 user interface metaphor.
 That is, we're in a world of objects and we manipulate them through actions
\begin_inset Foot
status collapsed

\begin_layout Standard

\emph on
Aside
\emph default
: Not only do I contend that such user interfaces are simple and natural,
 but a beautiful thing happens in addition: these concepts map naturally
 onto an object-oriented implementation.
 To build your own such applications, very little else is needed other than
 defining an object model (classes and methods).
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Folders
\end_layout

\begin_layout Standard
Notice the 
\emph on
Folders
\emph default
 icon in the classbar.
 Right-click the 
\emph on
New with name
\emph default
 action, and specify a name for the new folder you're creating.
 Let's say that you want to keep track of important contacts, in which case
 you might want to name the folder 
\emph on
Important Contacts
\emph default
.
 After entering the folder name, click 
\emph on
OK
\emph default
.
 The folder is created and displayed on the screen.
\end_layout

\begin_layout Standard
From a listing of Persons, you can simply drag and drop an entry onto the
 folder to add that person.
 You can put pretty much anything you want in a folder.
 The concept is completely analogous to the notion of folders on Operating
 System desktops.
 The difference of course is that you are not putting folders and files
 into a folder, but any type of object that is defined by the application,
 including Folders, Persons, Businesses, Queries, and more.
\end_layout

\begin_layout Standard
Drag and Drop is only one mechanism to add items to a folder.
 I'll be showing you other ways of doing the same thing later on.
\end_layout

\begin_layout Subsection
Queries
\end_layout

\begin_layout Standard
Assume you have plenty of contacts in your contact management system.
 This is not a problem of course since the application is backed by a database
 management system, designed to hold thousands of records, gigabytes of
 information.
 The primary advantage of a database of course is its ability to mine informatio
n.
\end_layout

\begin_layout Standard
I'd like to look up all members of the Suez family in my contact manager.
 Here's one way to do this using JMatter: right-click on 
\emph on
Persons
\emph default
 in the 
\emph on
Class Bar
\emph default
 and pick the corresponding action, which this time will be 
\emph on
Find
\emph default
.
\end_layout

\begin_layout Standard
When invoking 
\emph on
Find
\emph default
 on 
\emph on
Person
\emph default
s, a window will appear containing a way for us to specify a query.
 This one will be fairly easy:
\end_layout

\begin_layout Enumerate
From the pull-down menu on the left, select 
\emph on
Person Name's Last; 
\end_layout

\begin_layout Enumerate
From the second pull-down menu, select the appropriate comparison operation;
 in this case it does not really matter, let's pick 
\emph on
contains
\end_layout

\begin_layout Enumerate
In the text field on the right hand side, enter 
\emph on
Suez
\emph default
 (or whatever last name you're searching for);
\end_layout

\begin_layout Enumerate
Finally go ahead and click on the 
\emph on
Find
\emph default
 button to perform the query.
\end_layout

\begin_layout Standard
The search results will appear in the listing below the query you just performed.
\end_layout

\begin_layout Standard
Let's take this example one step further: click on 
\emph on
Save Query.

\emph default
 At this point your screen should look something similar to figure 
\begin_inset LatexCommand ref
reference "cap:Query-1"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CM-5.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Query-1"

\end_inset

Performing and Saving a Query
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Give your query a name (I called it 
\emph on
The Suez's)
\emph default
 and click 
\emph on
Save
\emph default
.
 We've just defined and executed a query, then named it and finally saved
 it.
\end_layout

\begin_layout Standard
It turns out that in JMatter, a query is nothing more than yet another type
 of thing, like a Person or a Business.
 That's why there exists an entry in the Class Bar called queries.
 Go ahead and browse queries (right-click 
\emph on
Browse
\emph default
 on 
\emph on
Queries
\emph default
 in the Class Bar) and you'll see your new query show up in the list (see
 figure 
\begin_inset LatexCommand ref
reference "cap:Browsing-Queries"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CM-6.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Browsing-Queries"

\end_inset

Browsing Queries
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you like, you can even query queries.
 This may sound far-fetched but after a while, after you've defined lots
 of queries, the ability to search for a query (by name) might come in handy.
\end_layout

\begin_layout Standard
Now that your query is defined and saved, you can execute it at any time.
 You guessed it, just right-click the 
\emph on
Execute
\emph default
 action on any query listed and you'll get the search results.
 If another matching entry is entered into the system after a query is created,
 the search results will include the new entry as well, of course.
 JMatter calls this feature a 
\emph on
Smart List
\emph default
.
\end_layout

\begin_layout Standard
Finally, since the query we just saved was a query on Persons, JMatter went
 ahead and established an association between the Persons 
\emph on
type
\emph default
 and this new query.
 It took the liberty to add a new action to the 
\emph on
Persons
\emph default
 context menu.
 That is, you can now right-click 
\emph on
The Suez's
\emph default
 on 
\emph on
Persons
\emph default
.
\end_layout

\begin_layout Subsubsection
Quick Recap
\end_layout

\begin_layout Standard
I know we haven't yet reached the chapter about actually writing applications
 in JMatter.
 Still, it's important to note even at this early stage that the query facilitie
s baked into this application are provided by the framework.
 You will not find a single line of code in the Contact Manager application
 to support these capabilities.
\end_layout

\begin_layout Standard
Something should be 
\emph on
clicking
\emph default
 at this point.
 Attempt to quantify how many lines of code exist in a 
\begin_inset Quotes eld
\end_inset

traditional
\begin_inset Quotes erd
\end_inset

 software application to support searches; especially for a category of
 application such as an issue manager.
 Issue managers are all about entering and updating and searching issues.
 Since entering and updating and searching things is built-in in JMatter,
 then very little work actually remains: the need to define that there exists
 such as thing as an issue.
 That's about it.
\end_layout

\begin_layout Standard
Also, notice how both developers and end users are empowered by this model
 of building applications:
\end_layout

\begin_layout Enumerate
end users do not have to go to a developer in order to define a new query
 in the system, they can do it themselves
\end_layout

\begin_layout Enumerate
developers' time is freed to work on higher business-value tasks
\end_layout

\begin_layout Subsection
Logs
\end_layout

\begin_layout Standard
To really drive the notion that all kinds of objects can play in the JMatter
 
\emph on
sandbox,
\emph default
 so to speak, have a look at the type called 
\emph on
Log
\emph default
 in the Class Bar.
 Browse the list of log entries and you'll see a screen that looks like
 figure 
\begin_inset LatexCommand ref
reference "cap:Log-Listing"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Standard
Consider revising Log title to include User (who) property and rebuild screensho
t, so it shows 
\begin_inset Quotes eld
\end_inset

admin
\begin_inset Quotes erd
\end_inset

 logged in, 
\begin_inset Quotes eld
\end_inset

eitan
\begin_inset Quotes erd
\end_inset

 logged out, etc..
 Same goes for 
\begin_inset Quotes eld
\end_inset

Object
\begin_inset Quotes erd
\end_inset

 updated, which becomes 
\begin_inset Quotes eld
\end_inset

Eitan Suez
\begin_inset Quotes erd
\end_inset

 updated.
 Lastly, finish implementing delete as a move to the deleted table rather
 than a real delete to prevent integrity constraint issues in the db when
 an object cannot be deleted because another object still references it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CM-7.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Log-Listing"

\end_inset

Log Listing
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
What we discover is that the framework keeps track of specific events such
 as when a user logs in or out of the system or when a specific piece of
 information is created or updated
\begin_inset Foot
status collapsed

\begin_layout Standard
Tapping into this log system to log additional activities is trivial
\end_layout

\end_inset

.
 The system creates a log entry: a message, possibly a longer description
 of the event that took place, who performed the specific action, and what
 object this action was performed on.
 Since log objects are proper JMatter objects (like 
\emph on
Person
\emph default
 and 
\emph on
Business
\emph default
) they inherit the same benefits: the ability to search through logs, to
 view and even edit logs (though technically that last bit should be forbidden,
 and can be made so
\begin_inset Foot
status open

\begin_layout Standard
See section 
\begin_inset LatexCommand ref
reference "sec:Authorization"

\end_inset

 on authorization
\end_layout

\end_inset

).
 You can also see in figure 
\begin_inset LatexCommand ref
reference "cap:Log-Listing"

\end_inset

 that the listing is currently showing you the first of two pages of logs,
 with a page navigation arrow at the bottom.
\end_layout

\begin_layout Subsection
Multiple Views
\end_layout

\begin_layout Standard
Before we end our tour, there's one last major aspect of the user interface
 that we need to discuss: the notion of multiple views.
\end_layout

\begin_layout Standard
You might have noticed four little icons on the top right-hand-side of listings
 windows.
 Bring up a listing of persons (right-click 
\emph on
Browse
\emph default
 on 
\emph on
Person
\emph default
s) and click on the icon with the yellow star in it.
 You should see something similar to figure 
\begin_inset LatexCommand ref
reference "cap:Icon-Alternate-View"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CM-8.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Icon-Alternate-View"

\end_inset

Icon Alternate List View
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The user interface for the Contact Manager application basically provides
 multiple alternative ways of viewing information.
 You can view a listing of Persons (or Queries or Logs) as a simple listing
 or as a list of Icons, or as a table, with the Person's fields (name, contact
 information) laid out in separate columns, or as a composite view: a listing
 on the left-hand-side combined with a form view of the currently selected
 item on the right hand side.
 This notion of multiple views should feel familiar, as it's akin to the
 way file managers on our desktops behave: we can view a listing of files
 and directories in 
\emph on
detail
\emph default
 view or 
\emph on
iconized
\emph default
 view and so on.
\end_layout

\begin_layout Standard
For single objects, say a single contact, you will likewise find alternate
 views.
 You can use a tree view for a contact where the tree is arranged in such
 a way that associations between objects can be traversed.
 So for example, we can lookup a log entry about someone logging in to the
 system and view that entry in a composite tree view, as shown in figure
 
\begin_inset LatexCommand ref
reference "cap:Composite-Tree-View"

\end_inset

.
 By expanding the tree nodes we can discover some of the associations between
 log objects and other objects.
 In this case, the person who logged in was the administrator.
 We also discover that users can be assigned to roles.
 The admin user belongs to the Administrators role, which in turn also keeps
 a list of all the users in the system that have the same role.
 Finally we see that roles maintain lists of field and command restriction
 objects.
 It is by adding such restrictions to roles that we can begin to specify
 an authorization policy for our system: who is allowed to view what fields,
 who is allowed to invoke what actions, etc..
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CM-8b.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Composite-Tree-View"

\end_inset

Composite Tree View for a Log Object
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
So this composite tree view is actually a wonderful way to explore and quickly
 learn the way information is modeled in a system, the various associations
 between types of objects, and how to traverse them.
 In chapters 
\begin_inset LatexCommand ref
reference "cha:MyTunes-Under-200"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "cha:A-Conference-Manager"

\end_inset

 we'll have a chance to explore such relationships.
\end_layout

\begin_layout Subsubsection
Custom Views
\begin_inset LatexCommand label
name "sub:Custom-Views"

\end_inset


\end_layout

\begin_layout Standard
Going back to the notion that we can have multiple different and complementary
 views for objects or lists of objects: certain types of objects have additional
 custom views, specific to that type.
 For example the Class Bar is nothing but a custom view of a folder of folders.
 Although I won't show you how to do this until section 
\begin_inset LatexCommand ref
reference "sec:Custom-Views-Revisited"

\end_inset

, you can look for a special folder named 
\emph on
Class List
\emph default
 whose contents are reflected in the 
\emph on
Class Bar
\emph default
.
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "cap:Three-Views"

\end_inset

 shows a composite tree view of the class bar.
 You can right-click 
\emph on
Browse
\emph default
 or 
\emph on
New
\emph default
 on any of the three views of the 
\emph on
Persons
\emph default
 type, for example.
 Furthermore, it is possible to customize the class bar by placing other
 types into that folder (for example the 
\emph on
Role
\emph default
 type, which would be useful for system administrators who sometimes need
 to define a new role, or add new users to an existing role).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CM-9.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Three-Views"

\end_inset

Three Views of the 
\emph on
Class List
\emph default
 Folder: A tree, an icon list, and the class bar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This brings up an important point about the philosophy behind the design
 of the JMatter framework: to the greatest extent possible, the JMatter
 framework strives to give the end user more control of the application,
 more independence from the developer.
 How often have you been in a position where you really wanted to make a
 simple change to the way an application is configured only to find out
 that the change could not be performed from its user interface (i.e.
 it required programming)?
\end_layout

\begin_layout Subsection
Tour Summary
\end_layout

\begin_layout Standard
Let's review what we've accomplished so far.
\end_layout

\begin_layout Standard
We've seen how to launch the Contact Manager application, log in, and create
 a new user if we wish to.
 We learned how to browse and create contacts, and once our contact list
 becomes very large, how to make practical use of the query feature to find
 the information we're looking for.
 We also know how to switch between alternate views of the same information,
 and have a good grasp of what JMatter applications are all about, from
 the end user's perspective.
\end_layout

\begin_layout Standard
Finally, we have a general understanding of the noun-verb metaphor that
 JMatter application user interfaces model.
 That is, the notion that one first selects a target object on which to
 perform an action, and then looks for and invokes a specific action on
 that object.
 This knowledge should enable us to quickly learn the user interfaces of
 other applications written with JMatter, even ones we're encountering for
 the first time.
\end_layout

\begin_layout Standard
In the next chapter, we'll start exploring how to write JMatter applications.
 We'll build our own contact manager.
 You may or may not be surprised by now if I were to tell you that the task
 will take us only a few minutes.
\end_layout

\begin_layout Part
Tutorial Applications
\end_layout

\begin_layout Chapter
A Zero-Code Contact Manager
\begin_inset LatexCommand label
name "cha:tut_contactmgr"

\end_inset


\end_layout

\begin_layout Standard
Let's write our own version of the contact manager.
 The point of this chapter is to lay the foundation for writing JMatter
 applications.
 You will learn how to create and setup a project, what information goes
 where, some of the configuration files and their role in a JMatter application.
 As the title of this chapter indicates, we will not have to write a single
 line of code to implement our first application!
\end_layout

\begin_layout Section
Creating a New Project
\end_layout

\begin_layout Standard
To create a new project in JMatter, invoke the 
\emph on
new-project-ui
\emph default
 ant target:
\end_layout

\begin_layout LyX-Code
$ cd jmatter
\end_layout

\begin_layout LyX-Code
$ ant new-project-ui
\end_layout

\begin_layout Standard
We need to decide on a name for our new project.
 Let's call it 
\emph on
CM
\emph default
 (short for ContactMgr), so as not to conflict with the existing demo version
 of the contact manager application.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/new-project-ui.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
New Project User Interface
\begin_inset LatexCommand label
name "fig:newprojectui"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have the option of creating a standalone or dependent project.
 It doesn't really matter at this point.
 Let's go with 
\emph on
dependent
\emph default

\begin_inset Foot
status collapsed

\begin_layout Standard
The distinction between standalone and dependent projects is discussed in
 chapter 
\begin_inset LatexCommand vref
reference "cha:Child-Projects"

\end_inset


\end_layout

\end_inset

.
 Go ahead and click on the 
\emph on
Create Project
\emph default
 button.
 This action will launch an ant target that takes our input and creates
 a complete directory structure for us.
 If you didn't specify a base directory, the new project is created by default
 in the jmatter directory's parent directory.
\end_layout

\begin_layout Standard
Go ahead and quit the new-project-ui 
\begin_inset Quotes eld
\end_inset

applet.
\begin_inset Quotes erd
\end_inset

 Let's navigate to our new project's base directory:
\end_layout

\begin_layout LyX-Code
$ cd ../CM
\end_layout

\begin_layout LyX-Code
$ ls
\end_layout

\begin_layout LyX-Code
build.xml   doc/   resources/   src/   test/
\end_layout

\begin_layout Standard
JMatter creates the directory structure for your project, along with its
 own ant build file.
\end_layout

\begin_layout Section
The Schema
\end_layout

\begin_layout Standard
We would normally proceed by modeling our application: identifying the entities,
 and implementing them as Java classes.
 With JMatter however, things are a little different.
 JMatter was designed to be a framework for building business applications.
 As such, JMatter predefines a number of common types of business objects,
 including persons, their contact information, addresses, and businesses.
 In this chapter we'll reuse the predefined implementations of Person and
 Business, whose fully-qualified class names are 
\emph on
com.u2d.type.composite.Person
\emph default
 and 
\emph on
com.u2d.type.composite.Business
\emph default
, respectively.
\end_layout

\begin_layout Standard
Before we generate our schema, we need a way to communicate to JMatter the
 various types of objects we would like to persist.
 We typically do this by adding an annotation (
\emph on
@Persist
\emph default
) directly on the model classes that we define.
 However in this case, since we're using pre-existing model classes, we
 do this by editing the underlying template, 
\emph on
src/persistClasses.st
\emph default
, directly:
\end_layout

\begin_layout LyX-Code
..
\end_layout

\begin_layout LyX-Code
<value>com.u2d.type.composite.Person</value>
\end_layout

\begin_layout LyX-Code
<value>com.u2d.type.composite.Business</value>
\end_layout

\begin_layout LyX-Code
..
\end_layout

\begin_layout Standard
We simply add the fully qualified names of the two classes 
\emph on
Person
\emph default
 and 
\emph on
Business
\emph default
 to the listing.
 We're now ready to generate the database schema:
\end_layout

\begin_layout LyX-Code
$ ant schema-export
\end_layout

\begin_layout Standard
Behind the scenes, JMatter introspects the classes in question and for each
 it generates a Hibernate database mapping file, and finally asks hibernate
 to generate the DDL (data definition language) instructions and send them
 to the database.
\end_layout

\begin_layout Standard
We should now be able to inspect the contents of our database and verify
 that it contains these tables.
 By default, JMatter uses the H2 database, which is lightweight and requires
 no work on your part 
\begin_inset Foot
status collapsed

\begin_layout Standard
You may of course create your own, say, PostgresQL or MySQL database and
 configure your application to work with it.
 Appendix 
\begin_inset LatexCommand ref
reference "cha:Database-Setup"

\end_inset

 provides the necessary information.
\end_layout

\end_inset

.
 By default, JMatter created the database CMh2db in the 
\emph on
db/
\emph default
 subdirectory of your project.
 To view its contents, you can use the H2 web-based console.
 First you must start the H2 server, with this command:
\end_layout

\begin_layout LyX-Code
$ java -cp ../jmatter/lib/runtime/jdbc/h2.jar org.h2.tools.Server
\end_layout

\begin_layout Standard
Then point your web browser to 
\emph on
http://localhost:8082/
\emph default
 and login to the database (default username is 
\emph on
sa
\emph default
, and the password is blank).
 These details are much better documented by H2's own documentation, of
 course.
\end_layout

\begin_layout Section
The Class Bar
\end_layout

\begin_layout Standard
Similar to the task of specifying which types to persist to the database,
 we also need to specify which types to expose to the user interface via
 the Class Bar.
 This step is not really necessary, because we can edit (in this case, add
 types to) the classbar directly from the user interface.
 Feel free to skip this section if you wish.
\end_layout

\begin_layout Standard
The way to predefine the default classbar items is to edit 
\emph on
src/class-list.xml
\emph default
:
\end_layout

\begin_layout LyX-Code
<folder>
\end_layout

\begin_layout LyX-Code
  <name>Class List</name>
\end_layout

\begin_layout LyX-Code
  <items>
\end_layout

\begin_layout LyX-Code
    <folder>
\end_layout

\begin_layout LyX-Code
      <name>Model</name>
\end_layout

\begin_layout LyX-Code
        <items>
\end_layout

\begin_layout LyX-Code
          <type>com.u2d.type.composite.Person</type>
\end_layout

\begin_layout LyX-Code
          <type>com.u2d.type.composite.Business</type>
\end_layout

\begin_layout LyX-Code
          <type>com.u2d.type.composite.Folder</type>
\end_layout

\begin_layout LyX-Code
          ...
\end_layout

\begin_layout Standard
This xml file is nothing but a marshalled Folder object.
 When the application starts up, the file will be unmarshalled back as a
 Folder object.
 JMatter will detect that our database is empty (it contains no classbar)
 and will automatically persist the folder.
 Each user has his or her own class list.
 The xml file serves as a template.
 This is useful since many applications have multiple users, with different
 roles.
 So different classbars can be defined for each role.
\end_layout

\begin_layout Section
Running Your Contact Manager
\end_layout

\begin_layout Standard
Let's do one more thing before we run our application: let's give it a splash
 screen.
 Do this by dropping a file named 
\emph on
splash.png
\emph default
 (or 
\emph on
splash.jpg
\emph default
 or 
\emph on
splash.gif
\emph default
) into the 
\emph on
resources/images
\emph default
 folder.
 If you like, just copy the one from the demo application.
\end_layout

\begin_layout Standard
Ok, let's run our app:
\end_layout

\begin_layout LyX-Code
$ ant run
\end_layout

\begin_layout Standard
That's it.
 We now have a working contact manager application.
 Go ahead and exercise it: create new person objects, etc..
 (see figure 
\begin_inset LatexCommand ref
reference "cap:Classlist-organized"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CH4-1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Classlist-organized"

\end_inset

Classes organized into two subfolders: 
\emph on
Manager
\emph default
 and 
\emph on
Administrative
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Custom Views Revisited
\begin_inset LatexCommand label
name "sec:Custom-Views-Revisited"

\end_inset


\end_layout

\begin_layout Standard
In subsection 
\begin_inset LatexCommand ref
reference "sub:Custom-Views"

\end_inset

 I had mentioned that the Class Bar can be customized directly from the
 User Interface.
 We're at a good place to show you how this works.
 Follow these instructions:
\end_layout

\begin_layout Enumerate
Launch the application and log in
\end_layout

\begin_layout Enumerate
Click on the 
\begin_inset Quotes eld
\end_inset

Administrative
\begin_inset Quotes erd
\end_inset

 folder in the Class Bar
\end_layout

\begin_layout Enumerate
Browse 
\emph on
Types
\emph default
 (right-click Types, select 
\emph on
Browse
\emph default
)
\end_layout

\begin_layout Standard
We've just asked our application to show us all the types defined in our
 system (Note that 
\emph on
Contact Methods
\emph default
 is among the list of defined types, though it doesn't have an icon, and
 thus shows up with a 
\emph on
question mark
\emph default
 icon).
\end_layout

\begin_layout Enumerate
Click on the 
\emph on
Manager
\emph default
 folder in the Class Bar
\end_layout

\begin_layout Enumerate
Drag 
\emph on
Contact Methods
\emph default
 to the empty area inside the 
\emph on
Manager
\emph default
 folder in the class bar
\end_layout

\begin_layout Standard
We have just added a type to the class list.
 Our class bar should now resemble figure 
\begin_inset LatexCommand ref
reference "cap:Class-Bar-Customized"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ClassBar-1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Class-Bar-Customized"

\end_inset

Class Bar Customized with an Additional Type: Contact Methods
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Project Structure
\end_layout

\begin_layout Standard
Let's take a closer look at the files in our project.
\end_layout

\begin_layout Subsection
Files
\end_layout

\begin_layout Standard
JMatter defines certain conventions for where to place files.
 These conventions are probably very similar to your existing project convention
s.
 Here is a summary of these conventions:
\end_layout

\begin_layout Enumerate
Source code resides in the 
\emph on
src/
\emph default
 directory
\end_layout

\begin_layout Enumerate
You will find certain resources, such as images, in the 
\emph on
resources
\emph default
 directory
\end_layout

\begin_layout Enumerate
The 
\emph on
ant
\emph default
 build file for your project uses the default name 
\emph on
build.xml
\emph default
 and resides in your project's base directory
\end_layout

\begin_layout Enumerate
Your source code is compiled to the target directory 
\emph on
build/classes
\end_layout

\begin_layout Enumerate
JMatter generates 
\emph on
Hibernate
\emph default
 mapping files for persisting your domain objects; these files by convention
 bear the suffix 
\begin_inset Quotes eld
\end_inset


\emph on
.hbm.xml
\emph default

\begin_inset Quotes erd
\end_inset

 and also are written to the 
\emph on
build/classes
\emph default
 directory
\end_layout

\begin_layout Enumerate
When deploying your application with Java Web Start (see chapter 
\begin_inset LatexCommand ref
reference "cha:Deploying-your-Application"

\end_inset

), the distribution file is placed in the 
\emph on
dist
\emph default
 directory
\end_layout

\begin_layout Enumerate
The 
\emph on
doc
\emph default
 directory contains a simple 
\emph on
README
\emph default
 file, serving as a quick reference or as simple setup instructions to help
 you get started on a new project.
 You are also urged to use this folder to place any relevant documentation
 for your project.
\end_layout

\begin_layout Enumerate
The 
\emph on
test
\emph default
 directory is created for you to place JUnit tests you write to ensure that
 your code and business logic is correct and bug-free
\end_layout

\begin_layout Subsection
Ant Targets
\end_layout

\begin_layout Standard
You don't need to memorize the names of the ant targets that we invoke (e.g.
 
\emph on
ant run
\emph default
, 
\emph on
ant schema-export
\emph default
); simply type:
\end_layout

\begin_layout LyX-Code
ant -projecthelp
\end_layout

\begin_layout Standard
to view a list of all the defined targets: their name and description (Of
 course, if you're running GNU/Linux and have bash smart completion turned
 on, simply pressing the tab key will display a list of valid ant targets).
\end_layout

\begin_layout Subsection
A Peek at the Source Code
\end_layout

\begin_layout Standard
Open the file 
\emph on
Person.java
\emph default
 in a text editor or IDE
\begin_inset Foot
status collapsed

\begin_layout Standard
IDE: Integrated Development Environment
\end_layout

\end_inset

 (it is located in 
\emph on
jmatter/src/com/u2d/type/composite
\emph default
).
 We're not going to attempt to understand every line of code just yet.
\end_layout

\begin_layout Standard
What I want you to notice is that a Person defines two fields: 
\emph on
name
\emph default
, and 
\emph on
contact
\emph default
:
\end_layout

\begin_layout LyX-Code
protected final Name _name = new Name();
\end_layout

\begin_layout LyX-Code
protected final Contact _contact = new Contact();
\end_layout

\begin_layout Standard
The Java classes 
\emph on
Name
\emph default
 and 
\emph on
Contact
\emph default
 are also defined in the framework.
 The 
\emph on
Name
\emph default
 class is composed of the parts that make up a name: prefix, first, middle,
 last, and suffix.
\end_layout

\begin_layout Standard
If you dig a little deeper, you will see that 
\emph on
Contact.java
\emph default
 defines these fields:
\end_layout

\begin_layout LyX-Code
private final USPhone _workPhone = new USPhone();
\end_layout

\begin_layout LyX-Code
private final USPhone _mobilePhone = new USPhone();
\end_layout

\begin_layout LyX-Code
private final USPhone _fax = new USPhone();
\end_layout

\begin_layout LyX-Code
private final Email _email = new Email();
\end_layout

\begin_layout LyX-Code
private final USAddress _address = new USAddress();
\end_layout

\begin_layout LyX-Code
private ContactMethod _preferredContactMethod = new ContactMethod();
\end_layout

\begin_layout Standard
Here we see that JMatter has a built-in understanding of types such as a
 US Phone number, an Email address, a US Address and a Contact Method.
\end_layout

\begin_layout Standard
If you inspect the generated database schema for our application, you will
 not find a database table to hold contact information or addresses.
\end_layout

\begin_layout Standard
The reason is that with JMatter, you have the choice of modeling a field
 either as an association or as an aggregation.
 In the context of the class 
\emph on
Person
\emph default
, 
\emph on
Contact
\emph default
 and 
\emph on
USAddress
\emph default
 are modeled as aggregates, and so are treated in a manner similar to value
 fields such as the work phone or email address.
 The fields that make up the contact information and address are aggregated
 into the parent type's table.
 Hibernate calls these 
\emph on
Components
\emph default
.
 If you're familiar with the concepts in the book 
\emph on
Domain-Driven Design 
\begin_inset LatexCommand cite
key "Evans"

\end_inset


\emph default
, then you're already familiar with both Aggregates and Value Objects.
\end_layout

\begin_layout Standard
We'll learn more about ways of modeling relationships between objects in
 the next chapter.
 Chapter 
\begin_inset LatexCommand ref
reference "cha:model-objs-ref"

\end_inset

 provides a more complete reference.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
Here's a quick recap of what we learned in this chapter:
\end_layout

\begin_layout Enumerate
We learned how to create a new project skeleton with the 
\emph on
ant new-project-ui
\emph default
 command;
\end_layout

\begin_layout Enumerate
We are aware of two configuration files 
\emph on
src/persistClasses.st
\emph default
 and 
\emph on
src/class-list.xml
\emph default
 and know a little about how to configure them;
\end_layout

\begin_layout Enumerate
Also, we learned that images go in the 
\emph on
resources/images
\emph default
 folder;
\end_layout

\begin_layout Enumerate
We learned the basic commands for creating our schema and running our applicatio
n: 
\emph on
ant schema-export
\emph default
 and 
\emph on
ant run
\end_layout

\begin_layout Enumerate
We studied the structure of a JMatter child project
\end_layout

\begin_layout Standard
With the basics for setting up, configuring, and running projects under
 our belt, we're now ready to do some real work.
 In the next chapter, we're finally going to get a chance to write some
 code in the 
\emph on
MyTunes
\emph default
 music application.
\end_layout

\begin_layout Chapter

\emph on
MyTunes
\emph default
 in under 200 Lines
\begin_inset LatexCommand label
name "cha:MyTunes-Under-200"

\end_inset


\end_layout

\begin_layout Standard
Tunes have become a popular topic.
 Let's build a music player! Before we get started, bear in mind that we
 won't have to build features such as Smart Lists for songs; JMatter will
 give us those things for free.
 We'll be able to concentrate on the task at hand: modeling our application
 and implementing the behaviours of our music player, such as importing
 songs into our song database, and playing songs, of course.
 Let's get started.
\end_layout

\begin_layout Section
Creating the Project
\end_layout

\begin_layout Standard
We know how to create our project.
 I'll name my project 
\emph on
MyTunes
\emph default
 and make it a dependent project.
 A finished copy of this project is already bundled with JMatter.
 If you wish, you can simply follow along using the existing demo application.
\end_layout

\begin_layout LyX-Code
$ cd jmatter/
\end_layout

\begin_layout LyX-Code
$ ant new-project-ui
\end_layout

\begin_layout LyX-Code
$ cd ../MyTunes
\end_layout

\begin_layout LyX-Code
$ ant -projecthelp
\end_layout

\begin_layout Standard
So far so good.
 Next, let's setup our project in our favorite IDE because we're finally
 going to be writing code.
\end_layout

\begin_layout Section
Setup your Project in an IDE
\begin_inset LatexCommand label
name "sec:Setup-your-IDE"

\end_inset


\end_layout

\begin_layout Standard
Technically, this step is optional.
 These days, the state of Integrated Development Environments (IDEs) for
 writing software in Java is so advanced that it is compelling to use one.
 These IDEs sport command completion features, intelligent assisted editing,
 automatic code formatting, useful hints, refactoring support, etc..
\end_layout

\begin_layout Standard
At the time of this writing, the three major IDEs for Java are 
\begin_inset LatexCommand htmlurl
name "Eclipse"
target "http://www.eclipse.org/"

\end_inset

, 
\begin_inset LatexCommand htmlurl
name "IntelliJ IDEA"
target "http://www.jetbrains.com/idea/"

\end_inset

, and 
\begin_inset LatexCommand htmlurl
name "NetBeans"
target "http://www.netbeans.org/"

\end_inset

.
 It doesn't really matter which you use, or whether you use one at all,
 as long as you're comfortable in your development environment.
\end_layout

\begin_layout Standard
Below is a description of the steps that I take as I setup my project in
 IntelliJ IDEA:
\end_layout

\begin_layout Enumerate
Launch the IDE program
\end_layout

\begin_layout Enumerate
Create New Project (launches a wizard)
\end_layout

\begin_deeper
\begin_layout Enumerate
specify the project name as 
\emph on
MyTunes
\emph default
, and 
\end_layout

\begin_layout Enumerate
the base directory path
\end_layout

\end_deeper
\begin_layout Enumerate
Pick the version of Java that I wish to use (Java 5)
\end_layout

\begin_layout Enumerate
Specify that we'll be using a single module project
\end_layout

\begin_layout Enumerate
Select the module type: Java module
\end_layout

\begin_layout Enumerate
Specify the module name as 
\emph on
MyTunes
\emph default
 (accept the defaults)
\end_layout

\begin_layout Enumerate
Make sure the source directory name is 
\emph on
src
\end_layout

\begin_layout Enumerate
Make sure the build directory path (where the compiled classes are placed)
 is 
\emph on
build/classes
\end_layout

\begin_layout Enumerate
Click 
\emph on
Finish
\end_layout

\begin_layout Standard
Nothing special here.
 Actually, most of the defaults were already correct; that is, I mostly
 clicked 
\emph on
Next > Next > Next
\emph default
, with one or two deviations from the defaults.
 My project is almost completely setup.
 The last thing I need to do is add the jar files in 
\emph on
../jmatter/lib/runtime
\emph default
 to my project classpath so that the classes we reference can be resolved.
 If you created a dependent project as I did, add the directory
\emph on
 ../jmatter/build/classes
\emph default
 to your classpath as well.
 Since the specific instructions vary from IDE to IDE, and since this is
 such a basic operation, I won't hold your hand through this task.
 :-)
\end_layout

\begin_layout Standard
Before getting started with coding in the next section, you might want take
 a quick peek at section 
\begin_inset LatexCommand vref
reference "sec:IDEA-Productivity-Templates"

\end_inset

 to setup some JMatter-specific file templates and live templates which
 will make keying the code much simpler.
\end_layout

\begin_layout Section
Getting Started
\end_layout

\begin_layout Standard
Ok, checking out my 
\emph on
iTunes
\emph default
 application on a nearby powerbook, I see that the main entities in a music
 player system appear to be 
\emph on
Songs
\emph default
, 
\emph on
Albums
\emph default
, 
\emph on
Artists
\emph default
, and 
\emph on
Genres
\emph default
.
 Pretty straightforward.
 Let's get started by modeling each of these:
\end_layout

\begin_layout Enumerate
Create a package to hold your classes; mine will be 
\emph on
com.u2d.mytunes
\end_layout

\begin_layout Enumerate
Create four classes: Song, Album, Artist, and Genre
\end_layout

\begin_layout Standard
Let's take a look at a basic template for implementing the 
\emph on
Artist
\emph default
 JMatter class:
\end_layout

\begin_layout LyX-Code
package com.u2d.mytunes;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import com.u2d.model.AbstractComplexEObject;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.Title;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.StringEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.TextEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.persist.Persist;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Artist extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO _name = new StringEO();
\end_layout

\begin_layout LyX-Code
   private final TextEO _bio = new TextEO();
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public static final String[] fieldOrder = {"name", "bio"};
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Artist() {}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public StringEO getName() { return _name; }
\end_layout

\begin_layout LyX-Code
   public TextEO getBio() { return _bio; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Title title() { return _name.title(); }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Let's analyze the above:
\end_layout

\begin_layout Enumerate
The 
\emph on
@Persist
\emph default
 Annotation: automates having to manually edit 
\emph on
src/persistClasses.st
\emph default
 as we had to do in the last chapter
\end_layout

\begin_layout Enumerate

\emph on
Artist extends AbstractComplexEObject
\emph default

\newline
In Java all the classes we write extend Object.
 When building JMatter applications, the base class for complex entities
 (ones that have more than a single field) is AbstractComplexEObject.
 Just like 
\emph on
Object
\emph default
 gives us 
\emph on
toString()
\emph default
 for free, 
\emph on
AbstractComplexEObject
\emph default
 also gives us a few things for free.
\end_layout

\begin_layout Enumerate

\emph on
Artist
\emph default
 has two fields: 
\emph on
name
\emph default
, and 
\emph on
bio
\emph default

\newline
It happens to be a personal style choice of the author to name instance
 variables with the underscore prefix.
 This, of course, is not necessary.
\end_layout

\begin_layout Enumerate
Funky types: name is a StringEO, bio is a TextEO
\newline
That's right.
 JMatter gives you a whole slew of atomic types to choose from, including
 types for phone numbers, social security numbers, time durations, images,
 email addresses, colors, and much more.
 It's quite easy to adapt a String as a StringEO and vice versa.
 There are two differences between a StringEO and a TextEO: 
\end_layout

\begin_deeper
\begin_layout Enumerate
StringEO's are saved to the database as 
\emph on
varchar
\emph default
 types (limit is typically 255) whereas TextEO's are saved as 
\emph on
text
\emph default
 types or some other similar large text object
\begin_inset Foot
status open

\begin_layout Standard
depending on the rdbms you use
\end_layout

\end_inset

; and
\end_layout

\begin_layout Enumerate
StringEO editors in the GUI are text fields whereas TextEO editors are text
 areas.
\newline
Think of the 
\emph on
EO
\emph default
 part of the type name as being an acronym for 
\emph on
Enhanced Object.
\end_layout

\end_deeper
\begin_layout Enumerate
Name and Bio are marked final!
\newline
Yep.
 That's part of the 
\emph on
ValueHolder
\emph default
 contract, these are never 
\emph on
null
\emph default
.
 To set a value on an atomic or aggregate type, call the 
\emph on
setValue()
\emph default
 method.
 Consequently, atomic fields and aggregates in JMatter classes have only
 getters.
\end_layout

\begin_layout Enumerate

\emph on
public static final String[] fieldOrder = {
\begin_inset Quotes erd
\end_inset

name
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes erd
\end_inset

bio
\begin_inset Quotes erd
\end_inset

}
\newline

\emph default
This is essentially metadata.
 You're giving JMatter a hint as to the order that you'd like these fields
 displayed when viewed using a form view.
 Name should come first, bio second.
 Notice that the field names are those derived from the accessor methods
 according to the JavaBeans convention, not the underlying variable names.
\end_layout

\begin_layout Enumerate

\emph on
public Title title() { return _name.title(); }
\newline

\emph default
Every JMatter class you define must specify a title.
 In this case, the title for an artist object will simply be the artist's
 name.
 For the Person class in the previous chapter it was a concatenation of
 the person's name and the value of their preferred contact method (phone
 number or email address).
 The idea for the 
\emph on
Title
\emph default
 class was shamelessly taken from the 
\emph on
NakedObjects
\emph default
 framework 
\begin_inset LatexCommand cite
key "Mat&Paw"

\end_inset

, though you'll find in it a few additional features, such as the 
\emph on
appendParens()
\emph default
 method which allows you to perform concatenation by wrapping the argument
 in parentheses.
\end_layout

\begin_layout Standard
That's it.
 The code is not very lengthy, but this first-time explanation certainly
 is.
\end_layout

\begin_layout Standard
One last note: If you're thinking right now that metadata such as the fieldOrder
 field above might be better modeled using Java 5 annotations, I would agree
 with you; I may do just that in the next version of JMatter.
 But this design decision has no bearing on your productivity as a software
 developer.
\end_layout

\begin_layout Section
The Album Class
\end_layout

\begin_layout Standard
In a fashion similar to the way we wrote 
\emph on
Artist
\emph default
, let's now write a simple implementation for an Album:
\end_layout

\begin_layout LyX-Code
package com.u2d.mytunes;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.StringEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.ImgEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.AbstractComplexEObject;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.Title;
\end_layout

\begin_layout LyX-Code
import com.u2d.list.RelationalList;
\end_layout

\begin_layout LyX-Code
import com.u2d.persist.Persist;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Album extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO _name = new StringEO();
\end_layout

\begin_layout LyX-Code
   private final ImgEO _cover = new ImgEO();
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public static final String[] fieldOrder = {"name", "cover"};
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Album() {}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public StringEO getName() { return _name; }
\end_layout

\begin_layout LyX-Code
   public ImgEO getCover() { return _cover; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Title title() { return _name.title(); }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
There's really very little new here.
 It's worth mentioning that we're defining a field of type 
\emph on
ImgEO
\emph default
 for the album's cover illustration.
 This basic type represents an image (gif, jpg, or png) that will be saved
 to database as some kind of binary large object (blob).
\end_layout

\begin_layout Section
The Genre Class
\end_layout

\begin_layout Standard
Let's take a look at 
\emph on
Genre
\emph default
 next.
 
\emph on
Genre
\emph default
 is a little more interesting.
 I decided to consider this type more like an enumeration.
 That is, that there should exist a fairly small, finite list of genres.
 However, unlike enumerations, we don't want to hard-code the list of genres
 in Java.
 We would like the end-user to be able to add entries to the list directly
 from the user interface.
 This is the template that JMatter defines for such database-backed enumerations
:
\end_layout

\begin_layout LyX-Code
package com.u2d.mytunes;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import com.u2d.type.AbstractChoiceEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.StringEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.ComplexType;
\end_layout

\begin_layout LyX-Code
import com.u2d.persist.Persist;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Genre extends AbstractChoiceEO
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO _code = new StringEO();
\end_layout

\begin_layout LyX-Code
   private final StringEO _caption = new StringEO();
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public static String[] identities = {"code"};
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public Genre() {}
\end_layout

\begin_layout LyX-Code
   public Genre(String code, String caption)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      _code.setValue(code);
\end_layout

\begin_layout LyX-Code
      _caption.setValue(caption);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public StringEO getCode() { return _code; }
\end_layout

\begin_layout LyX-Code
   public StringEO getCaption() { return _caption; }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
JMatter will make sure to give us a database table to hold genres.
 Notice that we've extended a different class: 
\emph on
AbstractChoiceEO
\emph default
.
 In the GUI, when we want to specify a genre for a song, we'll be picking
 the genre from a ComboBox (also called a 
\emph on
select
\emph default
 or 
\emph on
pull-down
\emph default
 menu).
 For each Genre object we'll specify both a code and a caption.
 The line
\end_layout

\begin_layout LyX-Code
public static String[] identities = {"code"};
\end_layout

\begin_layout Standard
is metadata telling JMatter that the code column in the table should be
 unique for all Genres (that is, you can't have two genres with the same
 code, 'rock' for example).
\end_layout

\begin_layout Section
The Song Class
\end_layout

\begin_layout Standard
Here's a first stab at the Song class:
\end_layout

\begin_layout LyX-Code
package com.u2d.mytunes;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
[imports collapsed]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Song extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO _title = new StringEO();
\end_layout

\begin_layout LyX-Code
   private final TimeEO _duration = new TimeEO();
\end_layout

\begin_layout LyX-Code
   private Album _album;
\end_layout

\begin_layout LyX-Code
   private final Genre _genre = new Genre();
\end_layout

\begin_layout LyX-Code
   private Artist _artist;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public static String[] fieldOrder = 
\end_layout

\begin_layout LyX-Code
                    {"title", "duration", "artist", "album", "genre"};
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Song() {}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public StringEO getTitle() { return _title; }
\end_layout

\begin_layout LyX-Code
   @Fld(format="m:ss")
\end_layout

\begin_layout LyX-Code
   public TimeEO getDuration() { return _duration; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Album getAlbum() { return _album; }
\end_layout

\begin_layout LyX-Code
   public void setAlbum(Album album)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      Album oldAlbum = _album;
\end_layout

\begin_layout LyX-Code
      _album = album;
\end_layout

\begin_layout LyX-Code
      firePropertyChange("album", oldAlbum, _album);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Genre getGenre() { return _genre; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Artist getArtist() { return _artist; }
\end_layout

\begin_layout LyX-Code
   public void setArtist(Artist artist)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      Artist oldValue = _artist;
\end_layout

\begin_layout LyX-Code
      _artist = artist;
\end_layout

\begin_layout LyX-Code
      firePropertyChange("artist", oldValue, _artist);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Title title() { return _title.title().appendBracket(_duration);
 }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
So far, this is more of the same, with a few new concepts.
 Let's review this class:
\end_layout

\begin_layout Enumerate
The song class defines the fields: 
\emph on
title, duration, album, genre, and artist
\emph default
.
 As usual, we define the 
\emph on
fieldOrder
\emph default
 String array as a means of specifying the order in which these fields are
 to be displayed.
\end_layout

\begin_layout Enumerate
The 
\emph on
duration
\emph default
 field is of a type we haven't seen before: 
\emph on
TimeEO
\emph default
.
 This type can be used to specify a certain length of time.
\end_layout

\begin_layout Enumerate
@Fld
\emph on
(format="m:ss")
\emph default

\newline
We're specifying through a field annotation parameter that in this application
 we're going to want to format durations using minutes and seconds.
 The format string complies with the contract specified by 
\emph on
java.text.SimpleDateFormat
\emph default
.
\end_layout

\begin_layout Enumerate
Accessors and Mutators
\newline
Finally we see that not all fields are 
\emph on
owned
\emph default
 by the Song class.
 The fields album and artist are 
\emph on
associations
\emph default
 to other entities.
 The convention for defining and specifying the accessors and mutators for
 association fields is different.
 It complies with the JavaBeans convention for bound properties.
 Notice we:
\end_layout

\begin_deeper
\begin_layout Enumerate
provide both a getter and a setter, and
\end_layout

\begin_layout Enumerate
fire a 
\emph on
PropertyChangeEvent
\emph default
 after the assignment.
\end_layout

\end_deeper
\begin_layout Enumerate
Here we have a better example of a 
\emph on
title()
\emph default
 method.
 First, don't confuse the song title with the song type's 
\emph on
title()
\emph default
 method.
 They're two different things.
 We want songs to display their titles and durations and so we concatenate
 the two.
 I use the utility method 
\emph on
appendBracket
\emph default
 to display the song duration in square brackets.
\end_layout

\begin_layout Section
Running our Application
\end_layout

\begin_layout Standard
We've been a little zealous here and defined all four classes 
\emph on
Artist
\emph default
, 
\emph on
Album
\emph default
, 
\emph on
Genre
\emph default
, and 
\emph on
Song
\emph default
 at once.
 This is not an example of good incremental coding practice.
 However, we made sure to keep these classes really simple.
 We didn't implement any behavior, we simply defined four types along with
 some pretty basic properties on each, such as the 
\emph on
Artist
\emph default
's name, a 
\emph on
Song
\emph default
's title.
 If you like, feel free to keep the 
\emph on
Song
\emph default
 class even more simple by just giving it a title for now.
\end_layout

\begin_layout Subsection
Configuration
\end_layout

\begin_layout Standard
Technically there is no configuration left to do.
 However, it might be simpler for us to specify the contents of the classbar
 for our application in xml form.
 Again, this is optional.
 The file to edit is 
\emph on
src/class-list.xml
\emph default
.
 Here's a sample that'll do nicely:
\end_layout

\begin_layout LyX-Code
<?xml version="1.0" encoding="UTF-8"?>
\end_layout

\begin_layout LyX-Code
<folder>
\end_layout

\begin_layout LyX-Code
   <name>Class List</name>
\end_layout

\begin_layout LyX-Code
   <items>
\end_layout

\begin_layout LyX-Code
      <folder>
\end_layout

\begin_layout LyX-Code
         <name>Model</name>
\end_layout

\begin_layout LyX-Code
         <items>
\end_layout

\begin_layout LyX-Code
           <type>com.u2d.mytunes.Song</type>
\end_layout

\begin_layout LyX-Code
           <type>com.u2d.mytunes.Album</type>
\end_layout

\begin_layout LyX-Code
           <type>com.u2d.mytunes.Artist</type>
\end_layout

\begin_layout LyX-Code
           <type>com.u2d.mytunes.Genre</type>
\end_layout

\begin_layout LyX-Code
           <type>com.u2d.app.User</type>
\end_layout

\begin_layout LyX-Code
           <type>com.u2d.type.composite.Folder</type>
\end_layout

\begin_layout LyX-Code
           <type>com.u2d.find.CompositeQuery</type>
\end_layout

\begin_layout LyX-Code
           <type>com.u2d.type.composite.LoggedEvent</type>
\end_layout

\begin_layout LyX-Code
         </items>
\end_layout

\begin_layout LyX-Code
      </folder>
\end_layout

\begin_layout LyX-Code
   </items>
\end_layout

\begin_layout LyX-Code
</folder>
\end_layout

\begin_layout Subsection
Finally Running the Application
\end_layout

\begin_layout Standard
Nothing new here.
 Let's run our app:
\end_layout

\begin_layout LyX-Code
ant schema-export
\end_layout

\begin_layout LyX-Code
ant run
\end_layout

\begin_layout Standard
After logging in we should see something that looks like figure 
\begin_inset LatexCommand ref
reference "cap:MyTunes-FirstLook"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/MyTunes-1.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:MyTunes-FirstLook"

\end_inset

A first look at MyTunes
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is problematic: we haven't specified any icons for our types.
 Let me tell you (and I speak from experience) that the choice and quality
 of your icons is as important to the success of your application than the
 quality of the code itself.
 I strongly believe that all aspects of our application must be of high
 quality, regardless of whether it's the code under the hood or perhaps
 cosmetic items that many developers often perceive as being outside their
 jurisdiction, or outside their realm of expertise.
\end_layout

\begin_layout Standard
Here's how to specify icons for each type: in the 
\emph on
resources/images
\emph default
 directory, place 16x16 and 32x32 pixel versions of an icon for each type.
 The naming of these image files is important.
 It is via a file naming convention that JMatter knows to associate an image
 with a type.
 This idea again was shamelessly taken from the NakedObjects framework.
 If you haven't guessed it by now, NakedObjects 
\begin_inset LatexCommand cite
key "Mat&Paw"

\end_inset

 had a strong influence on my thinking.
\end_layout

\begin_layout Standard
Ok, images can be of type jpg, png, or gif, or anything that Java Standard
 Edition supports.
 Here is a listing of my 
\emph on
resources/images
\emph default
 folder:
\end_layout

\begin_layout LyX-Code
eitan@ubuntu:~/projects/ds/MyTunes$ ls -lF resources/images/
\end_layout

\begin_layout LyX-Code
total 40
\end_layout

\begin_layout LyX-Code
-rwxr-xr-x  1 eitan eitan  855 2005-11-28 21:38 Album16.png*
\end_layout

\begin_layout LyX-Code
-rwxr-xr-x  1 eitan eitan 1961 2005-11-28 21:39 Album32.png*
\end_layout

\begin_layout LyX-Code
-rwxr-xr-x  1 eitan eitan 1961 2005-11-29 07:56 App32.png*
\end_layout

\begin_layout LyX-Code
-rwxr-xr-x  1 eitan eitan  859 2005-11-28 21:39 Artist16.png*
\end_layout

\begin_layout LyX-Code
-rwxr-xr-x  1 eitan eitan 2170 2005-11-28 21:40 Artist32.png*
\end_layout

\begin_layout LyX-Code
-rwxr-xr-x  1 eitan eitan  925 2005-11-28 21:39 Genre16.png*
\end_layout

\begin_layout LyX-Code
-rwxr-xr-x  1 eitan eitan 2596 2005-11-28 21:39 Genre32.png*
\end_layout

\begin_layout LyX-Code
-rw-r--r--  1 eitan eitan  753 2005-11-28 21:13 README
\end_layout

\begin_layout LyX-Code
-rwxr-xr-x  1 eitan eitan  696 2005-11-28 21:38 Song16.png*
\end_layout

\begin_layout LyX-Code
-rwxr-xr-x  1 eitan eitan 1720 2005-11-28 21:38 Song32.png*
\end_layout

\begin_layout LyX-Code
eitan@ubuntu:~/projects/ds/MyTunes$
\end_layout

\begin_layout Standard
The basic convention is quite simple: [
\emph on
ClassName
\emph default
]16.png and [
\emph on
ClassName
\emph default
]32.png for each class.
 But that's not the whole story on icons.
 For a complete description of the icon conventions, see section 
\begin_inset LatexCommand ref
reference "sub:Icons"

\end_inset

.
\end_layout

\begin_layout Standard
If, like me, producing icons is not your forte, then I highly recommend
 
\begin_inset LatexCommand htmlurl
name "the incors professional icons collection"
target "http://www.iconexperience.com/"

\end_inset

.
 Ok, now things should look a little bit nicer (see figure 
\begin_inset LatexCommand ref
reference "cap:MyTunes-with-Icons"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/MyTunes-2.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:MyTunes-with-Icons"

\end_inset

MyTunes with Icons
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's much better, don't you agree?
\begin_inset Note Comment
status collapsed

\begin_layout Standard
TODO: Need to setup Genres first before creating songs.
 Address this (later).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can play with the user interface some more and create genres, songs,
 and so on, but we're not quite finished with our application.
\end_layout

\begin_layout Section
Back To the Code
\end_layout

\begin_layout Standard
Our application's foundation is laid; we have a basic object model.
 But we're missing something: an album should define and maintain a list
 of songs.
 We already have the other side of that association in 
\emph on
Song.album
\emph default
.
 Let's add that one-to-many relationship right now.
 In 
\emph on
Album.java
\emph default
, add these:
\end_layout

\begin_layout LyX-Code
private final RelationalList _songs = new RelationalList(Song.class);
\end_layout

\begin_layout LyX-Code
public static final Class songsType = Song.class;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public RelationalList getSongs() { return _songs; }
\end_layout

\begin_layout Standard
If you're thinking that the above might be better modeled using Java 5 generics,
 I would agree with you; I may do just that in the next version of JMatter.
\end_layout

\begin_layout Standard
We defined a relational list of type song.
 The reason for the static Class 
\emph on
songsType
\emph default
 is to allow JMatter to introspect the list type statically.
 It's not pretty but it will do for now.
\end_layout

\begin_layout Standard
One last thing: we have a bidirectional one-to-many relationship between
 a song and an album.
 We need to add two more lines of metadata to tell JMatter about it.
 In Album:
\end_layout

\begin_layout LyX-Code
public static String songsInverseFieldName = "album";
\end_layout

\begin_layout Standard
And in Song:
\end_layout

\begin_layout LyX-Code
public static final String albumInverseFieldName = "songs";
\end_layout

\begin_layout Standard
Our model might quickly get of sync with the database tables we generated
 when we add new fields to types.
 There are two ways to bring them back in sync.
 The easy way:
\end_layout

\begin_layout LyX-Code
ant schema-update
\end_layout

\begin_layout Standard
The harder, possibly more correct way:
\end_layout

\begin_layout Enumerate
Dump your data out of the database
\end_layout

\begin_layout Enumerate
ant schema-export (wipes out the data)
\end_layout

\begin_layout Enumerate
restore the data
\end_layout

\begin_layout Standard
The restoration of data usually needs to be broken down into at least these
 steps:
\end_layout

\begin_layout Enumerate
drop constraints on your schema
\end_layout

\begin_layout Enumerate
restore the data
\end_layout

\begin_layout Enumerate
add the constraints back in
\end_layout

\begin_layout Standard
Anyhow, in our case, we don't have any precious data to save and restore
 yet so we'll go the easy route of either using 
\emph on
schema-update
\emph default
 or 
\emph on
schema-export
\emph default
.
\end_layout

\begin_layout Section
Validation
\end_layout

\begin_layout Standard
You might have also noticed that you can now create albums or songs with
 no name or title.
 This is a little disconcerting.
 There are two ways to address this issue.
 The first might be to specify that a song's title or album's name should
 be unique.
 We've seen this already with 
\emph on
Genre
\emph default
: you can specify the field metadata 
\emph on
identities
\emph default
 to enforce this.
 So in Album, you can add this:
\end_layout

\begin_layout LyX-Code
public static String[] identities = {"name"};
\end_layout

\begin_layout Standard
Like 
\emph on
fieldOrder
\emph default
, you can specify multiple identity fields if necessary.
 The field is flagged with the 'unique' database constraint and in addition,
 JMatter treats identity fields as required.
\end_layout

\begin_layout Standard
In this case, it happens to be a coincidence that the fields we wanted to
 mark as required also happened to be unique (i.e.
 you should definitely not go about marking fields unique for the purpose
 of making the user interface treat them as required fields).
\end_layout

\begin_layout Standard
To mark fields as required, edit the file 
\emph on
resources/model-metadata.properties
\emph default
 like so:
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
Song.title.required=true
\end_layout

\begin_layout LyX-Code
Album.name.required=true
\end_layout

\begin_layout LyX-Code
Artist.name.required=true
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout Standard
Now JMatter will give you built-in validation support in the user interface:
\end_layout

\begin_layout Enumerate
Required fields' captions are automatically styled in blue; (you can change
 the styling of required fields by modifying the rule 
\emph on

\begin_inset Quotes eld
\end_inset

.required
\emph default

\begin_inset Quotes erd
\end_inset

 in the file 
\emph on
resources/styles.css
\emph default

\begin_inset Foot
status collapsed

\begin_layout Standard
See chapter 
\begin_inset LatexCommand ref
reference "cha:Styling-the-UI"

\end_inset

 for more about styling the user interface using CSS
\end_layout

\end_inset

)
\end_layout

\begin_layout Enumerate
Validation checks will automatically be performed when attempting to create
 or save instances;
\end_layout

\begin_layout Enumerate
The user interface will automatically display validation error messages
 in the proper locations on the form
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "cap:Validation"

\end_inset

 shows the behavior of the JMatter user interface after the change.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/MyTunes-3.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Validation"

\end_inset

Validation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I attempted to create a new Artist, leaving the name blank.
 So JMatter is pre-wired to support validation.
 This mechanism we just specified is the simple way, for required fields.
 There's an additional method 
\emph on
validate()
\emph default
 that we can override in any of our types to specify more complex validation
 rules that have dependencies on multiple fields.
 For a more complete treatment of validation in JMatter, see chapter 
\begin_inset LatexCommand ref
reference "cha:Validation"

\end_inset

.
\end_layout

\begin_layout Subsection
A word about the 
\emph on
model-metadata.properties
\emph default
 File
\end_layout

\begin_layout Standard
Although the mechanism of specifying model metadata in a text file may continue
 to exist in the future, it is the goal of the JMatter framework to move
 all of that work directly into the GUI.
 Whether a field is required, a field's default value, its caption and more
 will all be entered in the same way one enters the username for a new User.
 The intent is for Field types (and meta-types in general) to become full-fledge
d JMatter objects, with a GUI, editability, and so on.
\end_layout

\begin_layout Standard
One can definitely imagine a new role for a JMatter user: the configuration
 manager, who uses a JMatter application to configure a JMatter application
 before releasing it to its user population.
 In fact, I recall reading early versions of the J2EE specification years
 ago where they outlined a number of roles in application development.
\end_layout

\begin_layout Section
Behaviour
\end_layout

\begin_layout Standard
So far, we seem to have nice, working model for a music application: we
 can create songs, albums, associate them.
 We can define artists like the famous 
\emph on
Shlomo Artzi
\emph default
 for example.
\end_layout

\begin_layout Standard
This modeling is important, don't get me wrong.
 After we've defined a thousand songs, we'll have powerful search features
 at our disposal to find that one special song.
 What's missing is behaviour: the ability to play songs! Also, it would
 be awfully tedious to enter all that information by hand.
 Can't we just import that stuff from our iTunes library?
\end_layout

\begin_layout Standard
So, we've just defined some additional work for ourselves: we'd like to
 be able to play songs and we'd like to be able to import songs listings.
\end_layout

\begin_layout Standard
A short glance at the Java sound API javadocs tells us that we can attempt
 to play an mp3 file with this bit of code:
\end_layout

\begin_layout LyX-Code
try
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   AudioClip clip = Applet.newAudioClip(_path.fileValue().toURL());
\end_layout

\begin_layout LyX-Code
   clip.play();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
catch (MalformedURLException ex)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   System.err.println(ex);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Ok, so we need to keep track of the path where our song file is located.
 So we'll need to add a new field to Song:
\end_layout

\begin_layout LyX-Code
private final FileEO _path = new FileEO();
\end_layout

\begin_layout Standard
And add the new field to our fieldOrder array:
\end_layout

\begin_layout LyX-Code
public static String[] fieldOrder = 
\end_layout

\begin_layout LyX-Code
          {"title", "duration", "artist", "album", "genre", "path"};
\end_layout

\begin_layout Standard
It sure would be nice to construct a song in a single line, so let's add
 this constructor:
\end_layout

\begin_layout LyX-Code
public Song(File path)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   _title.setValue(path.getName());
\end_layout

\begin_layout LyX-Code
   _path.setValue(path);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Don't forget the accessor method for 
\emph on
_path
\emph default
:
\end_layout

\begin_layout LyX-Code
public FileEO getPath() { return _path; }
\end_layout

\begin_layout Standard
Finally we need to expose a 
\emph on
play
\emph default
 command to our user interface.
 Since we're already there, why not also add a pause command?
\end_layout

\begin_layout LyX-Code
private AudioClip _clip;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Cmd(mnemonic='p')
\end_layout

\begin_layout LyX-Code
public Object Play(CommandInfo cmdInfo)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   try
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      _clip = Applet.newAudioClip(_path.fileValue().toURL());
\end_layout

\begin_layout LyX-Code
      vmech().message("Playing song.."+this);
\end_layout

\begin_layout LyX-Code
      _clip.play();
\end_layout

\begin_layout LyX-Code
      return null;
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   catch (MalformedURLException ex)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      System.err.println(ex);
\end_layout

\begin_layout LyX-Code
      return ex.getMessage();
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
@Cmd
\end_layout

\begin_layout LyX-Code
public void Pause(CommandInfo cmdInfo)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   if (_clip != null) _clip.stop();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
It turns out this will work for certain audio files but not for MP3's.
 A quick google and we discover a nice little utility that gives us an MP3
 Service Provider Interface (SPI) for the Java Sound API.
 We download it.
 Its 
\emph on
README.txt
\emph default
 file tells us we just need to add three jar files to our classpath:
\end_layout

\begin_layout LyX-Code
cp mp3spi1.9.3.jar ~/jmatter-complet/demo-apps/MyTunes/lib/src
\end_layout

\begin_layout LyX-Code
cp lib/*.jar ~/jmatter-complet/demo-apps/MyTunes/lib/src
\end_layout

\begin_layout Standard
Now we're in business
\begin_inset Foot
status collapsed

\begin_layout Standard
And you thought that the part in the movie 
\emph on
The Matrix
\emph default
 where a helicopter manual is summoned a few seconds prior to flying one
 was pure science fiction.
 :-)
\end_layout

\end_inset

.
 Let's give it a shot:
\end_layout

\begin_layout LyX-Code
$ ant schema-export
\end_layout

\begin_layout LyX-Code
$ ant run
\end_layout

\begin_layout LyX-Code
[create a song, specify a path to an mp3 file, save, and click Play]
\end_layout

\begin_layout Standard
On my machine, Ubuntu took perhaps 2-3 seconds to load the mp3 song and
 then started playing 
\emph on
Amour Perdu
\emph default
, by 
\emph on
Adamo
\emph default
 (see figure 
\begin_inset LatexCommand ref
reference "cap:Playing-Amour-Perdu"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/MyTunes-amoutperdu.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Playing-Amour-Perdu"

\end_inset

Playing 
\emph on
Amour Perdu
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Time to slow down and explain some of what we just did..
\end_layout

\begin_layout Section
Analysis
\end_layout

\begin_layout Subsection
FileEO
\end_layout

\begin_layout Standard
JMatter provides editors for all kinds of basic types including Files.
 Our path was of type 
\emph on
FileEO
\emph default
.
 This implies to the user interface to use the designated editor for the
 type FileEO when selecting a song: a File Chooser.
 Simple enough.
\end_layout

\begin_layout Subsection
Commands
\end_layout

\begin_layout Standard
Exposing commands on types in JMatter is as simple as exposing types.
 A command in the user interface maps to a method implementation on my class,
 just as a type in the UI is implemented via a Java class.
 The convention to follow for commands is to decorate the method with the
 
\emph on
@Cmd
\emph default
 annotation.
 This annotation accepts a number of options, including the mnemonic character
 that the user interface will use to make the command keyboard-accessible.
 There's one additional requirement, that these methods take a 
\emph on
CommandInfo
\emph default
 argument.
 We don't actually need that information in this particular case but there
 exist situations when we do.
 Anyhow, it's part of the current convention established by JMatter.
\end_layout

\begin_layout Standard
The caption that JMatter uses in menu items and buttons representing a command
 method is derived from the method name.
 For an annotated method named 
\emph on
ProduceHCFA_WithForm
\emph default
, for example, the caption will be 
\emph on
Produce HCFA With Form
\emph default
.
\end_layout

\begin_layout Standard
Notice that we did not have to worry about launching the song in a separate
 thread.
 JMatter does all this for us.
 Our user interface remains responsive the entire time.
 Although the UI replaces the mouse cursor with a WAIT_CURSOR (which these
 days seems to be some kind of spinning wheel on Ubuntu Linux anyway) to
 indicate that the song has not finished playing, we have full control over
 the UI and can close our window, open new ones, perform queries, etc..
 all while our Song plays in the background.
\end_layout

\begin_layout Subsection
message()
\end_layout

\begin_layout Standard
There's a curious line of code in the middle of the command implementation:
\end_layout

\begin_layout LyX-Code
vmech().message("Playing song.."+this);
\end_layout

\begin_layout Standard

\emph on
vmech()
\emph default
 returns a reference to the view mechanism.
 
\emph on
message()
\emph default
 signals to the view mechanism to display a message.
 The Swing view mechanism displays the message in a large font in a semitranspar
ent window that automatically dismisses itself after two second.
\end_layout

\begin_layout Subsection
Return Type
\end_layout

\begin_layout Standard
Our command method returns an Object.
 Here is yet another simple convention established by JMatter that if for
 some reason your command returns a bit of text, that bit of text will be
 displayed to the GUI.
 Notice that if for some reason we get an exception attempting to play our
 song, we're returning an error message, which will be displayed to the
 user.
\end_layout

\begin_layout Standard
JMatter tries to do this in good taste.
 Rather than display some kind of dialog box that one is forced to dismiss,
 JMatter displays a timed, semi-transparent, borderless dialog with the
 message which automatically disappears after a few seconds or when clicked
 on.
\end_layout

\begin_layout Standard
Let's proceed and implement our second task: a mechanism for importing songs
 from our iTunes library.
\end_layout

\begin_layout Section
Importing Songs
\end_layout

\begin_layout Standard
So here's the issue: sitting in my 
\emph on
~/music/iTunes Music/
\emph default
 folder are a bunch of mp3 files.
 I don't want to add them to my system one by one.
 I'd like to basically right-click on 
\emph on
Songs
\emph default
 and request that MyTunes scan for songs on my disk, from a specific base
 path.
 I decided to call my command 
\emph on
Scan From Base Path
\emph default
 and so will name my command method accordingly:
\end_layout

\begin_layout LyX-Code
@Cmd
\end_layout

\begin_layout LyX-Code
public static Object ScanFromBasePath(CommandInfo cmdInfo,
\end_layout

\begin_layout LyX-Code
                                      @Arg("Base Path") FileEO basePath)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   if (!basePath.fileValue().isDirectory())
\end_layout

\begin_layout LyX-Code
      return "You must specify a directory as the base path";
\end_layout

\begin_layout LyX-Code
   List songFiles = basePath.listRecursive(mp3Filter);
\end_layout

\begin_layout LyX-Code
   Set songs = new HashSet();
\end_layout

\begin_layout LyX-Code
   for (int i=0; i<songFiles.size(); i++)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      songs.add(new Song((File) songFiles.get(i)));
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   HBMSingleSession pmech = (HBMSingleSession)
\end_layout

\begin_layout LyX-Code
         Context.getInstance().getPersistenceMechanism();
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   pmech.saveMany(songs);
\end_layout

\begin_layout LyX-Code
   return "Finished importing MP3s";
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
private static FileFilter mp3Filter = new FileFilter()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public boolean accept(File file)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return file.getName().toLowerCase().endsWith(".mp3");
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Let's study this bit of code:
\end_layout

\begin_layout Enumerate
Our method is defined as static to ensure that our command is added to the
 Song type, and not to song instances.
 The command will be accessible from the Class Bar (right-click on Song).
\end_layout

\begin_layout Enumerate
Next, we see that we use the same little trick of returning a string if
 the specified path is not a directory.
 So the user will get an error message when they pick a base path that is
 invalid.
\newline

\newline
Wait a minute.
 Where or when did we tell JMatter to give us a base path? Notice that the
 command method takes an additional argument of type 
\emph on
FileEO
\emph default
.
 When this command is invoked, JMatter will see that this method needs a
 path and will prompt the user for it.
\end_layout

\begin_layout Enumerate
Look towards the bottom of the listing: we're defining a plain old Java
 file filter (POJFF) to let through only files with a .mp3 suffix.
 Then we invoke a method 
\emph on
listRecursive()
\emph default
 on 
\emph on
FileEO
\emph default
, passing in the file filter.
 Now we have a listing of all the mp3 files nested inside the user's specified
 base directory.
\end_layout

\begin_layout Enumerate
Now all we need to do is create a Song object for each file and save all
 these songs.
 Not bad for ~ 10 lines of code, if I may say so.
\end_layout

\begin_layout Standard
Let's try this out.
 No persistence-related changes have taken place so we can just re-run our
 app:
\end_layout

\begin_layout LyX-Code
$ ant run
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "cap:Songs-after-import"

\end_inset

 shows the song listing of the base directory after invoking 
\emph on
Scan From Base Path
\emph default
 on Song.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/MyTunes-SongListing.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Songs-after-import"

\end_inset

Song Listing after Import
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The operation created 159 Song objects or eleven pages' worth.
 The durations are not correct of course.
 A better way to solve this problem would be to interpret the iTunes xml
 file, which contains all sorts of song metadata besides the basic song
 file information.
\end_layout

\begin_layout Section
Not Completely Finished
\end_layout

\begin_layout Standard
If we take a moment to think about our implementation, we'll realize that
 our work is not exactly done.
 Although our songs actually play, our implementation is naive.
 Is the song actually streamed? Are resources disposed of properly?
\end_layout

\begin_layout Standard
A little more research into Java sound shows us that the API we're using
 is really outdated.
 There is a newer Java sound API in the 
\emph on
javax.sound
\emph default
 package.
 Furthermore, even that API has been somewhat deprecated by the Java Media
 Framework, which is an add-on to the standard Java distribution.
 Finally, we discover that JMF itself has been in maintenance mode for a
 number of years now.
 Some advocate using Apple's QuickTime for Java API (QTJ).
 I personally have an issue with using QTJ: it doesn't run on my computer.
 That is, Apple does not write their APIs or software applications to run
 on GNU/Linux, even though they had no qualms about pillaging open source
 code for their operating system kernel, or for their Safari web browser,
 just to name a few situations.
 I suppose giving is a one-way street.
\end_layout

\begin_layout Standard
Here is a list of enhancements we can think of for our MyTunes player:
\end_layout

\begin_layout Enumerate
Replace our audio playing implementation with one that is based on the Java
 Media Framework
\end_layout

\begin_layout Enumerate
Write a second, alternative import implementation that interprets iTunes'
 XML metafile
\end_layout

\begin_layout Enumerate
Revise our model to define the notion of a current playlist, add a command
 to Song to add it to the playlist, and finally, move the play and pause
 commands from Song to the new PlayList.
 This revised model seems to make a little more sense.
\end_layout

\begin_layout Standard
It turns out that if we discard the Java Sound API and the MP3 provider
 interface we downloaded, and instead use the 
\emph on
JLayer
\emph default
 library and its API, we get beautiful mp3 streaming for free in Java.
 The MyTunes demo application in the JMatter distribution was revised to
 use JLayer directly and mp3 files of all sizes play immediately without
 consuming gobs of memory.
 I leave the study of the final application to you as an exercise.
\end_layout

\begin_layout Standard
The point here is that JMatter frees you to work on the important things,
 like properly importing or playing a song.
 You don't have to worry about infrastructure services such as persistence,
 queries, or a user interface.
\end_layout

\begin_layout Standard
In very little time, we created a basic music player with Smart Lists.
 Figure 
\begin_inset LatexCommand ref
reference "cap:That-Special-Song"

\end_inset

 shows the 
\emph on
quick search
\emph default
 feature built into JMatter where you can just type in a song title in a
 listing's searchbar to filter the list accordingly.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/MyTunes-search.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:That-Special-Song"

\end_inset

That One Special Song..
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
To say that we covered a lot of ground in this chapter would be an understatemen
t.
 And yet, if we go through the due diligence of measuring how much code
 we actually produced:
\end_layout

\begin_layout LyX-Code
eitan@ubuntu:~/projects/ds/MyTunes/src/com/u2d/mytunes$ wc -l *.java
\end_layout

\begin_layout LyX-Code
  28 Album.java
\end_layout

\begin_layout LyX-Code
  21 Artist.java
\end_layout

\begin_layout LyX-Code
  24 Genre.java
\end_layout

\begin_layout LyX-Code
 119 Song.java
\end_layout

\begin_layout LyX-Code
 192 total
\end_layout

\begin_layout LyX-Code
eitan@ubuntu:~/projects/ds/MyTunes/src/com/u2d/mytunes$
\end_layout

\begin_layout Standard
We discover that we wrote our music player in under 200 lines of code! That's
 readable.
 That's workable.
 But not just 200 lines of code: a full-fledged music player in under an
 hour? 
\series bold
That's a paradigm shift.
\end_layout

\begin_layout Standard
Let's quickly review what we learned in this chapter:
\end_layout

\begin_layout Enumerate
We learned how to setup our project in an IDE.
\end_layout

\begin_layout Enumerate
We've learned the basic class template for our business objects in JMatter:
 our classes extend 
\emph on
AbstractComplexEObject
\emph default
, they have aggregate properties that adhere to the ValueHolder pattern,
 and they have associations to other objects that follow the JavaBeans accessor-
mutator pattern.
\end_layout

\begin_layout Enumerate
We learned how to control the field order in the GUI with the 
\emph on
fieldOrder
\emph default
 static member; we can specify that a property is unique by including it
 in the 
\emph on
identities
\emph default
 static member.
\end_layout

\begin_layout Enumerate
We learned how to associate icons with types by placing our icons in the
 
\emph on
resources/images
\emph default
 folder, and following a specific naming convention.
\end_layout

\begin_layout Enumerate
We learned how to expose both instance and class (static) actions to the
 UI.
 We've also seen how to write actions that take arguments.
\end_layout

\begin_layout Enumerate
We've been exposed to some of the atomic types that JMatter provides out
 of the box, including: StringEO, TextEO, ImgEO, TimeEO, and FileEO.
\end_layout

\begin_layout Enumerate
We've also been exposed to a simple mechanism for specifying field metadata,
 such as whether a field is required or not.
\end_layout

\begin_layout Standard
Although we have begun to dig deeper into this framework, there are many
 more features that we have yet to discuss and uncover.
\end_layout

\begin_layout Standard
A small but useful additional feature that we're going to use in the next
 chapter is the ability to customize icons on a per-instance basis.
 That is, we can use the artist's photo as the basis for its icon in the
 MyTunes user interface; though we'll introduce this feature in the context
 of a new application, the Conference Manager 
\emph on
Sympster
\emph default
.
\end_layout

\begin_layout Standard
Some other, more serious features in JMatter include
\end_layout

\begin_layout Enumerate
Integration with JFreeReport for producing PDFs
\end_layout

\begin_layout Enumerate
Calendaring (we'll see this in the next chapter)
\end_layout

\begin_layout Enumerate
Wizards
\end_layout

\begin_layout Enumerate
Polymorphic modeling support including interface-based modeling
\end_layout

\begin_layout Chapter
A Conference Manager
\begin_inset LatexCommand label
name "cha:A-Conference-Manager"

\end_inset


\end_layout

\begin_layout Standard
In this chapter we're going to build a conference management application.
 The idea for this application came to me while a speaker in a real series
 of conferences: The 
\emph on
No Fluff Just Stuff
\emph default
 Java and Open Source symposia.
\end_layout

\begin_layout Standard
Here are some of the features of JMatter that I will be introducing in this
 chapter:
\end_layout

\begin_layout Enumerate
Reinforcing our understanding of modeling a domain according to the conventions
 of the JMatter framework
\end_layout

\begin_layout Enumerate
More metadata
\end_layout

\begin_layout Enumerate
How to use an object's image field as its icon representation
\end_layout

\begin_layout Enumerate
How to add Calendaring support to your application
\end_layout

\begin_layout Enumerate
Polymorphic modeling
\end_layout

\begin_layout Section
Analysis
\end_layout

\begin_layout Standard
Let's begin by reviewing the 
\emph on
nofluffjuststuff.com
\emph default
 web site to get a feel for the business domain we're going to be working
 with.
\end_layout

\begin_layout Standard
From the home page:
\end_layout

\begin_layout Enumerate
click on 
\emph on
Speakers
\emph default
 in the toolbar
\end_layout

\begin_layout Enumerate
Browse through the list of speakers
\end_layout

\begin_layout Enumerate
Drill down to a specific speaker
\end_layout

\begin_layout Enumerate
We note that a speaker has a name and a biography, as well as a list of
 presentations
\end_layout

\begin_layout Enumerate
A presentation appears to have a title, an abstract, and an association
 back to the speaker
\end_layout

\begin_layout Standard
Let's now take a look at upcoming or past symposia.
 Looking at the list of past symposia, I see that the Rocky Mountain Software
 Symposium took place during the weekend of November 11 2005.
 Click on a specific symposium and you'll see a list of speakers, and a
 list of sessions.
 If you click on the link for the agenda, you'll see another view of the
 sessions for this particular symposium.
 Note that conferences will often have multiple sessions taking place at
 the same time, but at different presentation rooms.
\end_layout

\begin_layout Standard
So we can derive from this little stroll through the 
\emph on
NFJS
\emph default
 web site that some of the basic entities in a conference management system
 include a 
\emph on
Speaker
\emph default
, a 
\emph on
Talk
\emph default
 (or Presentation), a 
\emph on
Session
\emph default
, a 
\emph on
Symposium
\emph default
, and probably a 
\emph on
Room
\emph default
.
 We also have a fairly good understanding of how these types interrelate.
 We can say that:
\end_layout

\begin_layout Enumerate
A conference management system is essentially a list of symposia
\end_layout

\begin_layout Enumerate
Each symposium consists of a list of sessions
\end_layout

\begin_layout Enumerate
A session is essentially a talk given at a specific location, at a specific
 time, with a specified duration
\end_layout

\begin_layout Enumerate
A Talk is given by a Speaker, who might have an entire portfolio of talks
\end_layout

\begin_layout Standard
We could also think about how such a software application might assist in
 the task of planning a new symposium, perhaps with scheduling sessions,
 printing agenda and other materials needed for the conference.
\end_layout

\begin_layout Section
Setting up the Project
\end_layout

\begin_layout Standard
Setting up our project should be a familiar task by now.
 The demo application in JMatter that corresponds to this chapter is called
 
\emph on
Sympster
\emph default
.
\end_layout

\begin_layout LyX-Code
$ cd jmatter
\end_layout

\begin_layout LyX-Code
$ ant new-project-ui
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
$ cd ../Sympster
\end_layout

\begin_layout Standard
Go ahead and setup your project in your favorite IDE (see section 
\begin_inset LatexCommand ref
reference "sec:Setup-your-IDE"

\end_inset

).
 We proceed by writing our model classes.
\end_layout

\begin_layout Section
The Model
\end_layout

\begin_layout Standard
In our analysis, we came up with a list of the primary types we wanted in
 our system: 
\emph on
Symposium
\emph default
, 
\emph on
Speaker
\emph default
, 
\emph on
Talk
\emph default
, 
\emph on
Session
\emph default
, and 
\emph on
Room
\emph default
.
 Let's create a Java package where our classes will reside; proceed by creating
 a class for each of these types.
\end_layout

\begin_layout Subsection
Type Icons and Config File Setup
\end_layout

\begin_layout Standard
For each type, we need to:
\end_layout

\begin_layout Enumerate
provide a pair of icons, name them <typename>16.png and <typename>32.png,
 and place them in 
\emph on
resources/images
\end_layout

\begin_layout Enumerate
for startup ease, specify the fully-qualified type name in 
\emph on
src/class-list.xml
\end_layout

\begin_layout Subsection
The Symposium Class
\end_layout

\begin_layout Standard
Here's a simple implementation for a Symposium:
\end_layout

\begin_layout LyX-Code
package com.u2d.sympster;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import com.u2d.model.AbstractComplexEObject;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.Title;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.StringEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.persist.Persist;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Symposium extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO name = new StringEO();
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public Symposium() {}
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public StringEO getName() { return name; }
\end_layout

\begin_layout LyX-Code
   public Title title() { return name.title(); }
\end_layout

\begin_layout LyX-Code
   public static String pluralName() { return "Symposia"; }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We're extending the base class 
\emph on
AbstractComplexEObject
\emph default
.
 We defined a single field so far: the symposium's name.
 We have a getter method for the 
\emph on
name
\emph default
 field, and our 
\emph on
title()
\emph default
 method.
 The new bit is the optional implementation of the static method 
\emph on
pluralName()
\emph default
.
 The default derivation of the plural name for Symposium is not intelligent
 enough in this case so we provide it.
 We've already seen how a type's plural name is used in JMatter's user interface
: each entry in the classbar displays it; the titlebar for listings also
 displays the list item type's plural name.
\end_layout

\begin_layout Subsection
The Speaker Class
\end_layout

\begin_layout Standard
Again, the code here is fairly 
\begin_inset Quotes eld
\end_inset

bare bones:
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
package com.u2d.sympster;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import com.u2d.model.AbstractComplexEObject;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.Title;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.StringEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.TextEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.ImgEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.list.RelationalList;
\end_layout

\begin_layout LyX-Code
import com.u2d.persist.Persist;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Speaker extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO name = new StringEO();
\end_layout

\begin_layout LyX-Code
   private final StringEO title = new StringEO();
\end_layout

\begin_layout LyX-Code
   private final TextEO bio = new TextEO();
\end_layout

\begin_layout LyX-Code
   private final ImgEO photo = new ImgEO();
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   private final RelationalList talks = new RelationalList(Talk.class);
\end_layout

\begin_layout LyX-Code
   public static Class talksType = Talk.class;
\end_layout

\begin_layout LyX-Code
   public static String talksInverseFieldName = "speaker";
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public static String[] fieldOrder = {"name", "title", "photo", "bio",
 "talks"};
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public Speaker() {}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public StringEO getName() { return name; }
\end_layout

\begin_layout LyX-Code
   public StringEO getTitle() { return title; }
\end_layout

\begin_layout LyX-Code
   public TextEO getBio() { return bio; }
\end_layout

\begin_layout LyX-Code
   public ImgEO getPhoto() { return photo; }
\end_layout

\begin_layout LyX-Code
   public RelationalList getTalks() { return talks; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Title title() { return name.title(); }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We see that speakers have a name, title, short biography, and a photo.
 Speakers also have a portfolio of talks, modeled as a list, or one-many
 relationship.
 Since I plan to make this relationship bidirectional (a talk will have
 a reference to its speaker), I also specified the inverse field's name.
 We also see the 
\emph on
fieldOrder
\emph default
 metafield used to specify the display order of a speaker's fields.
\end_layout

\begin_layout Standard
Notice that I could have chosen to use a 
\emph on
Name
\emph default
 type to represent the speaker's name.
 In this instance I chose to keep the name simple as a single atomic field.
\end_layout

\begin_layout Subsection
The Talk Class
\end_layout

\begin_layout Standard
We're still in the process of laying the foundation for our application.
 Here's the code for our first pass implementation for a Talk:
\end_layout

\begin_layout LyX-Code
package com.u2d.sympster;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import com.u2d.model.AbstractComplexEObject;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.Title;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.StringEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.TextEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.persist.Persist;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Talk extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO title = new StringEO();
\end_layout

\begin_layout LyX-Code
   private final TextEO talkAbstract = new TextEO();
\end_layout

\begin_layout LyX-Code
   private Speaker speaker;
\end_layout

\begin_layout LyX-Code
   public static String speakerInverseFieldName = "talks";
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public static String[] fieldOrder = {"title", "talkAbstract", "speaker"};
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Talk() {}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public StringEO getTitle() { return title; }
\end_layout

\begin_layout LyX-Code
   public TextEO getTalkAbstract() { return talkAbstract; }
\end_layout

\begin_layout LyX-Code
   public Speaker getSpeaker() { return speaker; }
\end_layout

\begin_layout LyX-Code
   public void setSpeaker(Speaker speaker)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      Speaker oldSpeaker = this.speaker;
\end_layout

\begin_layout LyX-Code
      this.speaker = speaker;
\end_layout

\begin_layout LyX-Code
      firePropertyChange("speaker", oldSpeaker, this.speaker);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Title title() { return title.title(); }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
A talk has a title, an abstract, and a reference to its speaker.
 We see again that to-one associations use the JavaBeans bound property
 conventions and fire an event when they're set.
\end_layout

\begin_layout Subsection
The Room Class
\end_layout

\begin_layout Standard
Here is the implementation:
\end_layout

\begin_layout LyX-Code
package com.u2d.sympster;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import com.u2d.model.AbstractComplexEObject;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.Title;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.StringEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.persist.Persist;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Room extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO name = new StringEO();
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Room() {}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public StringEO getName() { return name; }
\end_layout

\begin_layout LyX-Code
   public Title title() { return name.title(); }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Nothing new here.
\end_layout

\begin_layout Subsection
The Session Class
\end_layout

\begin_layout Standard

\emph on
Session
\emph default
 is a little more interesting, as it relates Talk and Room entities.
\end_layout

\begin_layout LyX-Code
package com.u2d.sympster;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import com.u2d.model.AbstractComplexEObject;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.Title;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.TimeSpan;
\end_layout

\begin_layout LyX-Code
import com.u2d.persist.Persist;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Session extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final TimeSpan time = new TimeSpan();
\end_layout

\begin_layout LyX-Code
   private Talk talk;
\end_layout

\begin_layout LyX-Code
   private Room location;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public static String[] fieldOrder = {"talk", "time", "location"};
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Session() {}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public TimeSpan getTime() { return time; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Talk getTalk() { return talk; }
\end_layout

\begin_layout LyX-Code
   public void setTalk(Talk talk)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      Talk oldTalk = this.talk;
\end_layout

\begin_layout LyX-Code
      this.talk = talk;
\end_layout

\begin_layout LyX-Code
      firePropertyChange("talk", oldTalk, this.talk);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Room getLocation() { return location; }
\end_layout

\begin_layout LyX-Code
   public void setLocation(Room location)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      Room oldLocation = this.location;
\end_layout

\begin_layout LyX-Code
      this.location = location;
\end_layout

\begin_layout LyX-Code
      firePropertyChange("location", oldLocation, this.location);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Title title()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return time.title().append(":", talk).append(" in", location);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Again, very little new here.
 We have three fields: the talk, the location, and the time span.
 
\emph on
TimeSpan
\emph default
 is yet another basic type provided by the framework.
 It's a combination of a date-time field and a duration.
 You can also think of a time span as having both a start time and end time
 fields.
 Actually, this is how its default renderer and editor depict it.
\end_layout

\begin_layout Standard
The 
\emph on
title()
\emph default
 method is also somewhat interesting as it attempts to concatenate the time
 span along with the talk's title and location title.
\end_layout

\begin_layout Subsection
A First Look
\end_layout

\begin_layout Standard
I realize that I've been rushing through this a little.
 We could have easily written one class at a time and each time ran our
 application, thus building our application more incrementally.
 This in fact is a very good practice and a highly recommended one.
 Feel free not to follow me to the letter here.
\end_layout

\begin_layout Standard
Let's take our first-draft for a spin:
\end_layout

\begin_layout LyX-Code
$ ant schema-export
\end_layout

\begin_layout LyX-Code
$ ant run
\end_layout

\begin_layout Standard
Log in using the 
\emph on
admin
\emph default
/
\emph on
admin
\emph default
 credentials and you should see a screen similar to figure 
\begin_inset LatexCommand ref
reference "cap:Conf-Mgr-Firstlook"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/NFJS-1.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
First Look at our Conference Manager
\begin_inset LatexCommand label
name "cap:Conf-Mgr-Firstlook"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's go ahead and exercise our objects a little.
 Go ahead and create a Symposium, give it a name and save it.
 Similarly, create a room.
 Then go ahead and create a speaker and assign him or her a photo.
 Since a speaker has a list of talks, you can create and associate a talk
 to your speaker very simply by clicking the plus (+) icon, which is a popup
 menu, and selecting the 
\emph on
New
\emph default
 action, and then entering the information about the talk.
 The association will be made for you automatically.
 Alternatively, you can create a talk separately and then drag and drop
 the talk onto the speaker's talks listing.
 Figure 
\begin_inset LatexCommand ref
reference "cap:Speaker-Talk"

\end_inset

 is a snapshot of my screen after creating a speaker and a talk.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/NFJS-2.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A Speaker and Associated Talk
\begin_inset LatexCommand label
name "cap:Speaker-Talk"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now that we have created a talk and a room, go ahead and create a session
 object.
 The timespan can be edited by specifying the date and start and end times.
 Notice that the date editor provides a date picker to facilitate entry.
 The time editors likewise attempt to facilitate entry by providing small
 spinner arrows for incrementing and decrementing the hour and minute fields.
 To associate a talk and a room, again you have two choices:
\end_layout

\begin_layout Enumerate
Drop a talk onto the talk field of the session object (and similarly for
 the location field, drop a room object), or
\end_layout

\begin_layout Enumerate
Right-click 
\emph on
Browse
\emph default
, 
\emph on
Find
\emph default
, or 
\emph on
New
\emph default
 to browse and select an existing talk to associate to this session, to
 query for and select a talk, or to create a new talk and then associate
 it to the session in question
\end_layout

\begin_layout Standard
Here is a snapshot of my screen after creating and setting a session:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/NFJS-3.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Creating and associating a Session
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Enhancements
\end_layout

\begin_layout Standard
Let's get back to our code and make a few additions, enhancements.
\end_layout

\begin_layout Subsection
Type Color Coding
\end_layout

\begin_layout Standard
Here's a useful piece of metadata to help distinguish between different
 types of objects in our system: color-coding.
 Here's an example of how to specify this metadata:
\end_layout

\begin_layout LyX-Code
public static Color colorCode = new Color(0xffff00);
\end_layout

\begin_layout Standard
Just add the above line to any of your model classes (Room, Talk, Speaker,
 and so on) using a different color value for each, of course.
 The titlebar for each object will automatically be painted with a gradient
 background that starts with the specified color.
 Also, type listings paint the background color of alternating lines using
 that color code combined with a semi-transparent alpha value.
 This should help users quickly distinguish various listings or types of
 objects in your user interface.
\end_layout

\begin_layout Subsection
Speaker's Photo for Speaker Icon
\end_layout

\begin_layout Standard
We have a nice little icon representing a speaker.
 However, we have an even nicer one, and one that could help distinguish
 between speakers: their photo.
 Can't we simply use the speaker's photo as the basis for that instance's
 icon? Certainly.
 Here's the magic bit of code:
\end_layout

\begin_layout LyX-Code
private transient PhotoIconAssistant assistant = 
\end_layout

\begin_layout LyX-Code
                        new PhotoIconAssistant(this, photo);
\end_layout

\begin_layout LyX-Code
public Icon iconLg() { return assistant.iconLg(); }
\end_layout

\begin_layout LyX-Code
public Icon iconSm() { return assistant.iconSm(); }
\end_layout

\begin_layout Standard
JMatter provides a class named 
\emph on
PhotoIconAssistant
\emph default
 that you simply instantiate, passing in a reference to the containing object,
 and to the photo field in question.
 Then simply override the superclass's 
\emph on
iconLg()
\emph default
 and 
\emph on
iconSm()
\emph default
 methods and delegate the work to your assistant.
 Pretty simple.
\end_layout

\begin_layout Subsection
A Second Look
\end_layout

\begin_layout Standard
Let's check out our application with the changes in place.
\end_layout

\begin_layout LyX-Code
$ ant run
\end_layout

\begin_layout Standard
I went ahead and created a few 
\emph on
Speaker
\emph default
 instances so we'd have something to look at.
 Figure 
\begin_inset LatexCommand ref
reference "cap:Speaker-Icon-using"

\end_inset

 shows two views of the speakers' listing along with a maximized view of
 Jason Hunter, a long-time NFJS speaker.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/NFJS-4.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Speaker Icon using Photo Property
\begin_inset LatexCommand label
name "cap:Speaker-Icon-using"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
By opening other listings and other types of instances we can also quickly
 see the color-coding in effect.
 These are small, nice, and valued enhancements to our user interface.
\end_layout

\begin_layout Section
Calendaring
\begin_inset LatexCommand label
name "sec:Calendaring"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
One of the main tasks of managing conferences (or symposia, as they're called
 here) is scheduling them, determining what sessions will be offered: where
 and when talks are to be given.
\end_layout

\begin_layout Standard
What will it take to build these features into our application? Let's begin
 by studying the way JMatter models calendaring.
\end_layout

\begin_layout Subsection
How JMatter Models Calendaring
\end_layout

\begin_layout Standard
The JMatter framework defines three main types of objects that work together
 to provide calendaring features:
\end_layout

\begin_layout Enumerate
Calendar Events
\newline
These are basically items that one puts on a calendar.
 A meeting is a calendar event, for example.
 A visit between a physician and a patient is another example.
 Here's a third example: a session at a conference.
\end_layout

\begin_layout Enumerate
Resources, or Schedulables
\newline
As its name implies, a Resource is something that
 can be occupied or consumed for a span of time.
 In our example, a room where a presentation is given is a resource.
 In the code, JMatter calls them schedulables.
 In a physician's clinic, the physician becomes the resource.
\end_layout

\begin_layout Enumerate
Grouping of Resources, or Calendarables
\newline
Finally, it's important to get a
 view of how multiple resources are utilized in time.
 We'd like to be able to see what sessions are going on at the same time
 in six different rooms, so we can pick which presentation we want to attend,
 for example.
 A nurse would like to see which physicians are available during a specific
 block of time, and so on.
\end_layout

\begin_layout Standard
So in our system, the Calendar Events are our Sessions, the resource is
 the Room, and finally our Calendarable is the Symposium.
 We can have many symposia and so each one will have its own calendar.
 Each room will have its own schedule.
\end_layout

\begin_layout Standard
Technically, we need to extend our model to make this work in the field:
 symposia can take place in different venues.
 One could take place at a hotel in New York City, another at a convention
 center in San Francisco, and a third could be taking place at a university
 campus in Austin.
 Each venue would then have its own list of rooms where presentations are
 held.
\end_layout

\begin_layout Standard
For now we're going to keep the venue constant.
 We'll extend the model to support multiple types of venues in section 
\begin_inset LatexCommand ref
reference "sec:Polymorphism"

\end_inset

.
\end_layout

\begin_layout Standard
JMatter's calendaring model can be found in the package 
\emph on
com.u2d.calendar
\end_layout

\begin_layout Subsection
Enhancing Sympster to Support Calendaring
\end_layout

\begin_layout Standard
Ok, let's get to the code.
 Here is the simplest way to introduce calendaring to our application.
 Now that we've identified the relative roles of Session, Room, and Symposium
 and how they map to JMatter's model for calendaring, we can proceed to
 enhance our code base.
 Let's start with 
\emph on
Session
\emph default
.
\end_layout

\begin_layout Subsubsection
Enhancing Session
\end_layout

\begin_layout Standard
We need to:
\end_layout

\begin_layout Enumerate
make session a subclass of 
\emph on
CalEvent;
\end_layout

\begin_layout Enumerate
implement the contract for 
\emph on
CalEvent.
\end_layout

\begin_layout Standard
The first revision is easy:
\end_layout

\begin_layout LyX-Code
public class Session extends CalEvent
\end_layout

\begin_layout Standard
The second is pretty easy too:
\end_layout

\begin_layout LyX-Code
public static String timespanFieldname = "time";
\end_layout

\begin_layout LyX-Code
public static String schedulableFieldname = "location";
\end_layout

\begin_layout LyX-Code
public Title calTitle()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   if (talk == null)
\end_layout

\begin_layout LyX-Code
      return new Title("--");
\end_layout

\begin_layout LyX-Code
   else
\end_layout

\begin_layout LyX-Code
      return talk.title();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We're required to provide the name of the field in the class 
\emph on
Session
\emph default
 that corresponds to its timespan, so that JMatter knows how to display
 sessions in a calendar or a schedule widget.
 The name of this field happens to be 
\emph on
time
\emph default
.
 Likewise, our calendar will display calendar events for different resources,
 so we also need to provide the name of the schedulable field on Session:
 
\emph on
location
\emph default
.
\end_layout

\begin_layout Standard
The third requirement, the 
\emph on
calTitle()
\emph default
 method could have been made optional but it is required by JMatter at the
 moment.
 It gives you a chance to specify a title for a Session object that is more
 appropriate in the context of a calendar.
 For example, the calendar will make obvious the time and duration and location
 of the session, so you might not want to repeat that information in the
 title.
 In this case, we specify the talk's title as the calendar-context title
 for 
\emph on
Session
\emph default
.
\end_layout

\begin_layout Standard
That's it for 
\emph on
Session
\emph default
.
 Let's look at 
\emph on
Room
\emph default
 next.
\end_layout

\begin_layout Subsubsection
Enhancing Room
\end_layout

\begin_layout Standard
We need to:
\end_layout

\begin_layout Enumerate
make Room a subclass of 
\emph on
ScheduleEO;
\end_layout

\begin_layout Enumerate
implement the contract for 
\emph on
ScheduleEO.
\end_layout

\begin_layout Standard
Here they are:
\end_layout

\begin_layout LyX-Code
public class Room extends ScheduleEO
\end_layout

\begin_layout Standard
And:
\end_layout

\begin_layout LyX-Code
public Class eventType() { return Session.class; }
\end_layout

\begin_layout Standard
Pretty easy? We specify that events in Rooms are of type 
\emph on
Session
\emph default
.
\end_layout

\begin_layout Subsubsection
Enhancing Symposium
\end_layout

\begin_layout Standard
Here again, we need to:
\end_layout

\begin_layout Enumerate
make Symposium a subclass of CalendarEO;
\end_layout

\begin_layout Enumerate
implement the contract for CalendarEO.
\end_layout

\begin_layout Standard
The first change:
\end_layout

\begin_layout LyX-Code
public class Symposium extends CalendarEO
\end_layout

\begin_layout Standard
And for the second, add this code:
\end_layout

\begin_layout LyX-Code
public AbstractListEO schedulables()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   return ComplexType.forClass(Room.class).list();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
public Class defaultCalEventType() { return Session.class; }
\end_layout

\begin_layout Standard
We implement the method schedulables(), which returns a list of all the
 resources that this calendar maintains.
 If each symposium had its own venue, the implementation would simply have
 been:
\end_layout

\begin_layout LyX-Code
return getVenue().getRooms();
\end_layout

\begin_layout Standard
In our case, we decided to keep our venue constant so we return the entire
 list of rooms.
\end_layout

\begin_layout Standard
The second requirement is to provide the default calendar event type, which
 again is Session.
\end_layout

\begin_layout Standard
That's it.
 We're done.
\end_layout

\begin_layout Subsection
A Third Look
\end_layout

\begin_layout Standard
Let's look at what we get in return for our efforts.
\end_layout

\begin_layout LyX-Code
$ ant run
\end_layout

\begin_layout Standard
Browse the list of symposia you created and right-click the command 
\emph on
Show Calendar
\emph default
.
 This command was inherited by 
\emph on
CalendarEO
\emph default
.
 We see a calendar widget, similar to the one shown in figure 
\begin_inset LatexCommand ref
reference "cap:Symposium-Calendar"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/NFJS-5.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Symposium Calendar, along with a few Sessions
\begin_inset LatexCommand label
name "cap:Symposium-Calendar"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Feel free to explore this widget.
 It has a few useful features:
\end_layout

\begin_layout Enumerate
A week view and a day view
\end_layout

\begin_layout Enumerate
The ability to view the calendar using a time resolution of 15 minutes,
 30 minutes, or 60 minutes per row
\end_layout

\begin_layout Enumerate
The ability to navigate to the next day or week by clicking on the navigation
 arrows (in day view, you'll be navigating to the next or previous day,
 in week view, you'll be navigating to the next or previous week)
\end_layout

\begin_layout Enumerate
A mini month calendar, for quickly navigating to a specific date in another
 month or year
\end_layout

\begin_layout Enumerate
A date navigation text field, to quickly navigate to a specific date by
 simply entering it and pressing enter (e.g.
 10212004 will take you to Oct 21 2004)
\end_layout

\begin_layout Enumerate
The ability to toggle any schedule on or off the calendar
\end_layout

\begin_layout Enumerate
You can create a new session at a specific time and location by double-clicking
 on a cell in day view
\end_layout

\begin_layout Enumerate
You can create a new session at a specific time and location, with a specific
 talk by simply dropping a talk onto a cell in day view
\end_layout

\begin_layout Enumerate
You can alter the default session duration by right-clicking on the Session
 class's (in the class bar) 
\emph on
Set Default Duration Hrs
\emph default
 command.
\end_layout

\begin_layout Enumerate
You can alter the time or location of a session by simply dragging it onto
 another cell
\end_layout

\begin_layout Enumerate
You can open an existing session by double clicking on its representation's
 titlebar in the calendar
\end_layout

\begin_layout Enumerate
You can invoke any commands on a session displayed in the calendar by right-clic
king on its titlebar
\end_layout

\begin_layout Standard
I think you'll agree that here again, JMatter provides tremendous leverage.
 The designers of the JMatter framework are reusing this calendar across
 different applications that span entirely different business domains.
 As the features of this calendar improve, all JMatter applications will
 inherit these improvements.
 One more time we ask you to compare the effort required to build such a
 feature traditionally into an existing software application and what it
 took to integrate scheduling into Sympster here.
\end_layout

\begin_layout Subsection
Inheritance vs Interfaces
\end_layout

\begin_layout Standard
In order to gain the benefits of calendaring, we had to extend existing
 classes in our system.
 Luckily, our Session, Room, and Symposium did not already extend another
 base class.
 Designing by inheritance has its problems in a world where multiple inheritance
 is not supported.
 But you don't have to be locked in to it.
\end_layout

\begin_layout Standard
It turns out that JMatter does not require that you extend ScheduleEO or
 CalendarEO to obtain these benefits.
 You can implement the 
\emph on
Calendarable
\emph default
 and 
\emph on
Schedulable
\emph default
 interfaces directly yourself and they really don't require that much effort.
 Have a look at the source code for 
\emph on
CalendarEO
\emph default
 and 
\emph on
ScheduleEO
\emph default
.
 They do very little indeed.
 All they do is instantiate a 
\emph on
Calendar
\emph default
 and 
\emph on
Schedule
\emph default
 object respectively, and expose an accessor method on it.
 That's basically it.
\end_layout

\begin_layout Standard
At the moment, the same cannot be said about a 
\emph on
CalEvent
\emph default
.
 We are required to subclass 
\emph on
CalEvent
\emph default
.
 As we refine JMatter's calendaring feature further, we expect this requirement
 to be removed
\begin_inset Foot
status collapsed

\begin_layout Standard
One area worth researching JVM-compatible programming languages which support
 features such as mixins or traits
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Inheritance-Based Polymorphism
\begin_inset LatexCommand label
name "sec:Polymorphism"

\end_inset


\end_layout

\begin_layout Standard
Let's discuss how we would revise our application to accommodate symposia
 with different venues:
\end_layout

\begin_layout Enumerate
Define a new field on Symposium called 
\emph on
venue
\newline

\emph default
The goal is for a venue to be a base type for multiple specializations,
 such as a Hotel, a Conference Center, or a Campus (each of these three
 would be concrete implementations of a 
\emph on
Venue
\emph default
)
\end_layout

\begin_layout Enumerate
Define the base type Venue
\newline
At the very least, a venue should have a name
 and a list of rooms.
 So 
\emph on
Venue
\emph default
 would likely include two methods: 
\emph on
getName()
\emph default
 and 
\emph on
getRooms()
\end_layout

\begin_layout Enumerate
Revise the implementation of 
\emph on
Symposium.schedulables()
\emph default
 to return 
\emph on
venue.getRooms()
\end_layout

\begin_layout Enumerate
Update our schema
\end_layout

\begin_layout Enumerate
Possibly add one or more of these new types to one of our Class Bar subfolders
 (or edit the Class Bar directly from the GUI)
\end_layout

\begin_layout Standard
This particular situation lends itself nicely to implementing polymorphism
 via inheritance.
 Here's what 
\emph on
Venue
\emph default
 might look like:
\end_layout

\begin_layout LyX-Code
public abstract class Venue extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   protected final StringEO name = new StringEO();
\end_layout

\begin_layout LyX-Code
   protected final RelationalList rooms = new RelationalList(Room.class);
\end_layout

\begin_layout LyX-Code
   public static Class roomsType = Room.class;
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public StringEO getName() { return name; }
\end_layout

\begin_layout LyX-Code
   public RelationalList getRooms() { return rooms; }
\end_layout

\begin_layout LyX-Code
   public Title title() { return name.title(); }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Pretty simple really.
 We can now extend Venue for 
\emph on
Hotel
\emph default
, 
\emph on
Campus
\emph default
, and 
\emph on
ConferenceCenter
\emph default
.
 Here is 
\emph on
Hotel
\emph default
:
\end_layout

\begin_layout LyX-Code
public class Hotel extends Venue
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public Hotel() {}
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard

\emph on
Hotel
\emph default
 is ready to be extended with specialized behaviours.
 We can similarly define 
\emph on
Campus
\emph default
 and 
\emph on
ConferenceCenter
\emph default
.
 We can distinguish these three types by the icon we choose to represent
 each type.
\end_layout

\begin_layout Standard
Finally, here are the changes I've made to 
\emph on
Symposium
\emph default
:
\end_layout

\begin_layout LyX-Code
private Venue venue;
\end_layout

\begin_layout LyX-Code
public Venue getVenue() { return venue; }
\end_layout

\begin_layout LyX-Code
public void setVenue(Venue venue)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   Venue oldVenue = this.venue;
\end_layout

\begin_layout LyX-Code
   this.venue = venue;
\end_layout

\begin_layout LyX-Code
   firePropertyChange("venue", oldVenue, this.venue);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
public AbstractListEO schedulables()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   // return ComplexType.forClass(Room.class).list();
\end_layout

\begin_layout LyX-Code
   return venue.getRooms();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We need to synchronize our database to the model changes we've made:
\end_layout

\begin_layout LyX-Code
ant schema-update
\end_layout

\begin_layout Standard
In this particular case, JMatter generates hibernate mapping files using
 the joined subclass inheritance mapping strategy.
\end_layout

\begin_layout Standard
And we should be ready to check out our application:
\end_layout

\begin_layout LyX-Code
$ ant run
\end_layout

\begin_layout Standard
I added 
\emph on
Venue
\emph default
 to the class list.
 Remember that 
\emph on
Venue
\emph default
 is an abstract base type.
 Figure 
\begin_inset LatexCommand ref
reference "cap:Sympster-Polymorphic"

\end_inset

 shows two things:
\end_layout

\begin_layout Enumerate
Right-clicking 
\emph on
Browse
\emph default
 on 
\emph on
Venues
\emph default
 in the Class Bar will perform a polymorphic query and return a listing
 including hotels, campuses, and conference centers.
\end_layout

\begin_layout Enumerate
Right-clicking 
\emph on
New
\emph default
 on Venues will prompt the user to select which concrete type they would
 like to instantiate.
 This is baked in to the user interface.
 When associating a venue to a symposium, right-clicking 
\emph on
New
\emph default
, 
\emph on
Browse
\emph default
, or 
\emph on
Find
\emph default
 on the symposium's venue association field will do the right thing.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/NFJS-6.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Sympster Extended with Venues
\begin_inset LatexCommand label
name "cap:Sympster-Polymorphic"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
JMatter supports both inheritance-based polymorphism (as shown in this example)
 and interface-based polymorphism.
\end_layout

\begin_layout Section
Interface-Based Polymorphism
\end_layout

\begin_layout Standard
We are taught that interface-based modeling is preferred over models that
 do not employ interfaces.
 I concur.
 I'd like to demonstrate how to do interface-based modeling in JMatter.
\end_layout

\begin_layout Standard
As an illustration, let's extend our Sympster application further.
 Right now, we can define a symposium, speakers, their talks, and we can
 schedule sessions.
 A session is defined as a talk given at a specific date and time, and with
 a specific duration, at a specific location.
\end_layout

\begin_layout Standard
I'd like to broaden the definition of a session to include events other
 than speakers' presentations.
 What about BOF's (Birds of a Feature session) for example? Or maybe a panel
 discussion including a number of participants.
 At NFJS symposia, we actually hold informal BOFs with 2-3 participants
 where we discuss a particular topic.
\end_layout

\begin_layout Standard
Let's walk through the code.
\end_layout

\begin_layout Standard
The first thing I do is define the interface `Event`:
\end_layout

\begin_layout LyX-Code
public interface Event extends ComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public StringEO getTitle();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We're basically going to require that each event provide a title.
 Talk already does and BOFs will too.
 I still want to define this interface as it serves as a mechanism for qualifyin
g event types.
\end_layout

\begin_layout Standard
Next, let's go ahead and define a new object to model a BOF:
\end_layout

\begin_layout LyX-Code
public class BOF extends AbstractComplexEObject implements Event
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  private final StringEO title = new StringEO();
\end_layout

\begin_layout LyX-Code
  private final RelationalList participants = new RelationalList(Speaker.class);
\end_layout

\begin_layout LyX-Code
  public static Class participantsType = Speaker.class;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  public static String[] fieldOrder = {"title", "participants"};
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  public BOF() { }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  public StringEO getTitle() { return title; }
\end_layout

\begin_layout LyX-Code
  public RelationalList getParticipants() { return participants; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  public Title title()
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
    return title.title().append(" with", participants);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Finally, let's retrofit our existing class `Talk`:
\end_layout

\begin_layout LyX-Code
$ svn diff -r83:84 Talk.java
\end_layout

\begin_layout LyX-Code
Index: Talk.java
\end_layout

\begin_layout LyX-Code
===================================================================
\end_layout

\begin_layout LyX-Code
--- Talk.java (revision 83)
\end_layout

\begin_layout LyX-Code
+++ Talk.java (revision 84)
\end_layout

\begin_layout LyX-Code
@@ -7,7 +7,7 @@ 
\end_layout

\begin_layout LyX-Code
import com.u2d.reflection.FieldAt; 
\end_layout

\begin_layout LyX-Code
import java.awt.Color;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
-public class Talk extends AbstractComplexEObject 
\end_layout

\begin_layout LyX-Code
+public class Talk extends AbstractComplexEObject implements Event
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  private final StringEO title = new StringEO();
\end_layout

\begin_layout LyX-Code
  private final TextEO talkAbstract = new TextEO();
\end_layout

\begin_layout Standard
As you can see from the above diff, all I had to do was specify that Talk
 implement Event.
\end_layout

\begin_layout Standard
Finally, remaining is broadening Session's definition.
 Rather than define an association to a 
\emph on
Talk
\emph default
, we'll revise that to be be an association to an 
\emph on
Event
\emph default
.
 I won't show you all the edits.
 Here's the gist of the change:
\end_layout

\begin_layout LyX-Code
- public Talk getTalk() { return talk; } 
\end_layout

\begin_layout LyX-Code
- public void setTalk(Talk talk) 
\end_layout

\begin_layout LyX-Code
+ public Event getEvent() { return event; } 
\end_layout

\begin_layout LyX-Code
+ public void setEvent(Event event)
\end_layout

\begin_layout Standard
And that's it.
 Now let's take a look at how these changes manifest themselves in our applicati
on:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/listing_events.png
	lyxscale 30
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Polymorphic Queries: Listing Events
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
JMatter models the polymorphic association using Hibernate's implicit polymorphi
sm mechanism, otherwise known as *any* associations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/creating_events.png
	lyxscale 30
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Polymorphic Instantiation: Creating a new Event
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
JMatter will prompt the user whether they wish to create a talk or a BOF.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/events_calendar.png
	lyxscale 30
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Events Calendar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We see two events on this calendar.
 The first is a talk on JMatter, and the second is a BOF on Programming.
 :-) 
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
I hope you enjoyed this chapter.
 We didn't have to work too hard and yet we developed a fully-functional
 conference manager.
\end_layout

\begin_layout Standard
In summary, new features of JMatter covered in this chapter include:
\end_layout

\begin_layout Enumerate
type color coding, 
\end_layout

\begin_layout Enumerate
using an image field as the basis for an instance's icon, 
\end_layout

\begin_layout Enumerate
calendaring, and 
\end_layout

\begin_layout Enumerate
polymorphism, using either inheritance or interface-based modeling
\end_layout

\begin_layout Standard
Let's do our due diligence once again and get a feel for the amount of leverage
 we derived from JMatter in this application:
\end_layout

\begin_layout LyX-Code
~/work/jmatter-complet/demo-apps/Sympster/src/com/u2d/sympster$ wc -l *.java
\end_layout

\begin_layout LyX-Code
  29 BOF.java
\end_layout

\begin_layout LyX-Code
   9 Campus.java
\end_layout

\begin_layout LyX-Code
   9 ConferenceCenter.java
\end_layout

\begin_layout LyX-Code
  17 Event.java
\end_layout

\begin_layout LyX-Code
   9 Hotel.java
\end_layout

\begin_layout LyX-Code
  28 Room.java
\end_layout

\begin_layout LyX-Code
  54 Session.java
\end_layout

\begin_layout LyX-Code
  64 Speaker.java
\end_layout

\begin_layout LyX-Code
  56 Symposium.java
\end_layout

\begin_layout LyX-Code
  38 Talk.java
\end_layout

\begin_layout LyX-Code
  21 Venue.java
\end_layout

\begin_layout LyX-Code
 334 total
\end_layout

\begin_layout Standard
Not bad.
 If you're not convinced by now of the implications of this new mode of
 developing software, this might be a good time to pick up another book
 :-).
\end_layout

\begin_layout Standard
In the next chapter we're finally going to take a look at the Issue Manager
 demo application, the one referenced in the introduction.
 We'll be focusing on JMatter's support for objects with lifecycles.
\end_layout

\begin_layout Chapter
Issue Manager
\begin_inset LatexCommand label
name "cha:Issue-Manager"

\end_inset


\end_layout

\begin_layout Standard
In this chapter, we're going to discuss JMatter's support for business objects
 with lifecycles.
 We're going to write an Issue Manager, a familiar application for software
 developers who use such systems to help manage the development of software.
 Examples of issue managers include Bugzilla, Trac, and JIRA.
\end_layout

\begin_layout Section
Analysis
\end_layout

\begin_layout Standard
The central type in this application is the 
\emph on
Issue
\emph default
.
 The interesting aspect of issues is that they have a life cycle.
 An Issue is created and assigned to a developer.
 The developer accepts the issue and begins working on a fix.
 After resolving the issue, the person who opened the issue verifies that
 the resolution is indeed satisfactory, and proceeds to close the issue.
 If the issue is not resolved to satisfaction, the issue can be reopened.
\end_layout

\begin_layout Standard
It's also important to keep some kind of trail of activity: who opened the
 issue? Who resolved it and when? An end user should have the ability to
 attach notes to an issue, to specify a description of the issue, steps
 to reproduce the problem (if applicable).
\end_layout

\begin_layout Standard
The main trait of objects with life cycles is that their behaviour depends
 on their state.
 For example, one cannot attempt to 
\emph on
accept
\emph default
 an issue if it's already been closed.
 We can identify the various states for an 
\emph on
Issue
\emph default
, and define its lifecycle with the aid of state diagrams, transition tables,
 etc..
 Software developers will typically model such objects using the 
\emph on
State Design Pattern
\emph default

\begin_inset Foot
status collapsed

\begin_layout Standard
The State Pattern is documented by the 
\emph on
Gang of Four
\emph default
 in their book, 
\emph on
Design Patterns
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
I have decided to model an Issue with five states:
\end_layout

\begin_layout Enumerate
New
\end_layout

\begin_layout Enumerate
Assigned
\end_layout

\begin_layout Enumerate
Accepted
\end_layout

\begin_layout Enumerate
Fixed
\end_layout

\begin_layout Enumerate
Closed
\end_layout

\begin_layout Standard
In a normal flow, an issue moves sequentially through these states.
 An issue is created (
\emph on
New
\emph default
 state), then assigned to a developer (
\emph on
Assigned
\emph default
 state), and accepted by the developer (
\emph on
Accepted
\emph default
 state).
 The person who opened the issue has the option of rejecting the fix (in
 which case its state reverts to 
\emph on
Accepted
\emph default
) or approving it, moving 
\emph on
Issue
\emph default
 to the 
\emph on
Closed
\emph default
 state.
 An issue can also be reassigned to a different developer.
\end_layout

\begin_layout Subsection
Modeling States in Java
\end_layout

\begin_layout Standard
In Java, the State pattern is often and conveniently modeled using inner
 classes.
 Each state is implemented as an inner class which controls the behaviour
 of the 
\emph on
Context
\emph default
 object (in this case, 
\emph on
Issue
\emph default
) when in that state.
 Also, many texts encourage the design to use static inner classes for improving
 the performance of the system.
 That is, rather than create an instance of each inner class per Issue,
 a single instance of each inner class exists for all issues.
 The issue that is to be operated upon is passed in as an argument to that
 inner class's methods.
\end_layout

\begin_layout Standard
Although there's no denying the improvement in memory requirements, I personally
 find this design less than ideal, from an object-oriented point of view.
 I find it akin to removing the implicit 
\emph on
this
\emph default
 keyword in instances and passing a reference to 
\emph on
self
\emph default
 with each method.
\end_layout

\begin_layout Section
Getting Started
\end_layout

\begin_layout Standard
We're about to start building our fourth application.
 Since we've done this together three times already, I'm not going to walk
 you through the steps of creating a new project and configuring it Please
 refer to previous chapters for specific instructions.
 I named my application 
\emph on
IssueMgr
\emph default
.
\end_layout

\begin_layout Standard
Ok, we need to model 
\emph on
Issue
\emph default
.
 As a first pass, let's not worry right away about the various states we
 identified in the previous section.
 Let's instead start be defining the various properties we want an issue
 to have.
 Here are the properties I've come up with:
\end_layout

\begin_layout LyX-Code
private final StringEO _title = new StringEO();
\end_layout

\begin_layout LyX-Code
private final TextEO _description = new TextEO();
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
// a loose definition (using a numeric value instead of an enumeration)
\end_layout

\begin_layout LyX-Code
private final IntEO _priority = new IntEO();
\end_layout

\begin_layout LyX-Code
private final IntEO _severity = new IntEO();
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
private Issue _dependsOn;
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
private final RelationalList _notes = new RelationalList(Note.class);
\end_layout

\begin_layout LyX-Code
public static Class notesType = Note.class;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
private User _openedBy;
\end_layout

\begin_layout LyX-Code
private User _assignedTo;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
private final RelationalList _history = 
\end_layout

\begin_layout LyX-Code
                           new RelationalList(LoggedEvent.class);
\end_layout

\begin_layout LyX-Code
public static Class historyType = LoggedEvent.class;
\end_layout

\begin_layout Standard
An issue then will have a title and a detailed description.
 Note how the description field is defined as a TextEO which causes it to
 be rendered using a text area, and saved as in the database as a large
 text type.
 I've decided for a first-pass to keep severity and priority really simple,
 as numeric values.
 The next one: 
\emph on
dependsOn
\emph default
 is interesting and fairly self-explanatory.
 It will give us the knowledge that Issue A will not be resolved before
 the issue it depends on (say Issue B) is resolved, for example.
\end_layout

\begin_layout Standard
The next field, 
\emph on
notes
\emph default
, will allow us to tack on notes to an issue (as many notes as we want in
 fact).
 A 
\emph on
Note
\emph default
 is yet another predefined type in JMatter.
 It has a subject, a time stamp, an author, and the note text itself.
 When creating a note, the author is automatically assigned to the user
 who is currently logged in.
\end_layout

\begin_layout Standard
The next two fields, 
\emph on
openedBy
\emph default
 and 
\emph on
assignedTo
\emph default
 are self-explanatory.
 The last field is an interesting one.
 The idea is that I'd like to keep track of the history of an issue: when
 was it opened, assigned, accepted, fixed, etc..
 Furthermore, when an issue is fixed, i want to require the developer to
 enter both a summary description of the fix and a lengthier one.
 I want to capture that information.
\end_layout

\begin_layout Standard
After thinking about this for a little while, I realized that JMatter's
 built-in 
\emph on
LoggedEvent
\emph default
 type would be a perfect candidate for recording this information.
 It's already designed to hold precisely this type of information.
 It has a timestamp, a message, long message, it records the user who performed
 the action, it can even record what action was performed, and finally,
 has an association back to the object upon which the operation was performed.
 In the context of the issue manager, we'll be able to navigate from a log
 entry (with message 
\emph on
Issue fixed at 4:30 pm
\emph default
) back to the issue it is associated to.
\end_layout

\begin_layout Standard
Ok, it looks like we have a fairly complete list of fields to start with.
 Of course, it's not enough to just define these fields, the JMatter conventions
 must be followed: define accessor methods for aggregate types and both
 accessors and mutators for association types, following the JavaBeans bound
 property convention.
\end_layout

\begin_layout LyX-Code
public StringEO getTitle() { return _title; }
\end_layout

\begin_layout LyX-Code
public TextEO getDescription() { return _description; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public IntEO getPriority() { return _priority; }
\end_layout

\begin_layout LyX-Code
public IntEO getSeverity() { return _severity; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public Issue getDependsOn() { return _dependsOn; }
\end_layout

\begin_layout LyX-Code
public void setDependsOn(Issue issue)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   Issue oldValue = _dependsOn;
\end_layout

\begin_layout LyX-Code
   _dependsOn = issue;
\end_layout

\begin_layout LyX-Code
   firePropertyChange("dependsOn", oldValue, _dependsOn);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public RelationalList getNotes() { return _notes; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public User getOpenedBy() { return _openedBy; }
\end_layout

\begin_layout LyX-Code
public void setOpenedBy(User user)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   User oldValue = _openedBy;
\end_layout

\begin_layout LyX-Code
   _openedBy = user;
\end_layout

\begin_layout LyX-Code
   firePropertyChange("openedBy", oldValue, _openedBy);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public User getAssignedTo() { return _assignedTo; }
\end_layout

\begin_layout LyX-Code
public void setAssignedTo(User user)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   User oldValue = _assignedTo;
\end_layout

\begin_layout LyX-Code
   _assignedTo = user;
\end_layout

\begin_layout LyX-Code
   firePropertyChange("assignedTo", oldValue, _assignedTo);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public RelationalList getHistory() { return _history; }
\end_layout

\begin_layout Standard
Here is the context within which all this code is written:
\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Issue extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public static String[] fieldOrder = {"title", "description", "notes",
\end_layout

\begin_layout LyX-Code
         "openedBy", "assignedTo", "history", "severity", "priority"};
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Issue() {}
\end_layout

\begin_layout LyX-Code
   ...
\end_layout

\begin_layout LyX-Code
   public Title title()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return _title.title().appendParens(""+getID());
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We added the familiar 
\emph on
fieldOrder
\emph default
 metadata and the required 
\emph on
title()
\emph default
 method.
 Since it is customary to refer to issues by some unique numeric ID, I'm
 exposing the issue's ID property in its title.
 This property is inherited from 
\emph on
AbstractComplexEObject
\emph default
.
\end_layout

\begin_layout Standard
We normally do not edit 
\emph on
src/persistClasses.st
\emph default
 by hand: the 
\emph on
@Persist
\emph default
 annotation takes care to add Issue to the list automatically.
 However here we're using a predefined entity 
\emph on
Note
\emph default
 and for it we do need to manually add an entry to our 
\emph on
persistClasses.st
\emph default
 file, like so:
\end_layout

\begin_layout LyX-Code
..
\end_layout

\begin_layout LyX-Code
<value>com.u2d.type.composite.Note</value>
\end_layout

\begin_layout LyX-Code
..
\end_layout

\begin_layout Standard
We can now generate and export our schema, run the application and create
 a few issues.
\end_layout

\begin_layout Section
Modeling Issues' Lifecycle
\end_layout

\begin_layout Standard
The time has come to model issues' lifecycle.
\end_layout

\begin_layout Standard
There are a number of concerns here.
 The first is keeping track of the state of our issue.
 And more specifically, to ensure that when an issue is persisted to the
 database, that its state is remembered and properly restored at a later
 point in time.
\end_layout

\begin_layout Standard
A simple way to do this is to define yet another field to hold the name
 of the state.
 This field will be persisted to the database just like 
\emph on
Issue
\emph default
's other fields, and can be the basis for restoring Issues' state when reloading
 issues from the database.
\end_layout

\begin_layout LyX-Code
private final IssueState _status = new IssueState(NEW);
\end_layout

\begin_layout Standard
Where 
\emph on
NEW
\emph default
 is one of a number of static string-based constants:
\end_layout

\begin_layout LyX-Code
static final String NEW = "New";
\end_layout

\begin_layout LyX-Code
static final String ASSIGNED = "Assigned";
\end_layout

\begin_layout LyX-Code
static final String ACCEPTED = "Accepted";
\end_layout

\begin_layout LyX-Code
static final String FIXED = "Fixed";
\end_layout

\begin_layout LyX-Code
static final String CLOSED = "Closed";
\end_layout

\begin_layout Standard
We have identified five states and they're not likely to change.
 JMatter provides a mechanism for modeling enumerations by extending the
 JMatter type 
\emph on
ChoiceEO
\emph default
.
 Here is the implementation of the contract to define the 
\emph on
IssueState
\emph default
 enumeration:
\end_layout

\begin_layout LyX-Code
public class IssueState extends ChoiceEO
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public IssueState() {}
\end_layout

\begin_layout LyX-Code
   public IssueState(String value) { setValue(value); }
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   private static Set STATUS_OPTIONS = new HashSet();
\end_layout

\begin_layout LyX-Code
   static
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      STATUS_OPTIONS.add(Issue.NEW);
\end_layout

\begin_layout LyX-Code
      STATUS_OPTIONS.add(Issue.ASSIGNED);
\end_layout

\begin_layout LyX-Code
      STATUS_OPTIONS.add(Issue.ACCEPTED);
\end_layout

\begin_layout LyX-Code
      STATUS_OPTIONS.add(Issue.FIXED);
\end_layout

\begin_layout LyX-Code
      STATUS_OPTIONS.add(Issue.CLOSED);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public Collection entries() { return STATUS_OPTIONS; }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Nothing too interesting really.
 We also must remember to add an accessor method for 
\emph on
status
\emph default
:
\end_layout

\begin_layout LyX-Code
public IssueState getStatus() { return _status; }
\end_layout

\begin_layout Subsection
Defining the State Inner Classes
\end_layout

\begin_layout Standard
Below I've defined five inner classes, one for each of the states that Issue
 can be in.
\end_layout

\begin_layout LyX-Code
public class NewState extends ReadState {}
\end_layout

\begin_layout LyX-Code
public class AssignedState extends ReadState
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   @Cmd(mnemonic='a')
\end_layout

\begin_layout LyX-Code
   public void Accept(CommandInfo cmdInfo)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      transition(_acceptedState, makeLog("Issue accepted by developer"));
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
public class AcceptedState extends ReadState
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   @Cmd
\end_layout

\begin_layout LyX-Code
   public void Fix(CommandInfo cmdInfo,
\end_layout

\begin_layout LyX-Code
                   @Arg("Fix") StringEO fix,
\end_layout

\begin_layout LyX-Code
                   @Arg("Description") TextEO description)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      transition(_fixedState, 
\end_layout

\begin_layout LyX-Code
                 makeLog("Fix: "+fix.stringValue(), description));
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
public class FixedState extends ReadState
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   @Cmd
\end_layout

\begin_layout LyX-Code
   public void RejectFix(CommandInfo cmdInfo,
\end_layout

\begin_layout LyX-Code
                         @Arg("Explanation") TextEO explanation)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      transition(_acceptedState, makeLog("Fix rejected", explanation));
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   @Cmd
\end_layout

\begin_layout LyX-Code
   public void Close(CommandInfo cmdInfo,
\end_layout

\begin_layout LyX-Code
                     @Arg("Explanation") TextEO explanation)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      transition(_closedState, makeLog("Issue Closed", explanation));
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public class ClosedState extends ReadState {}
\end_layout

\begin_layout Standard
Notice that the convention for defining commands on these states is the
 same as the mechanism used for defining commands in general.
 The difference is that JMatter will ensure that these commands are accessible
 in a valid state.
 The 
\emph on
@Arg
\emph default
 annotations' values are a means of specifying the captions used to prompt
 the end user for each of the method parameters.
\end_layout

\begin_layout Standard
Although we've defined the classes, we must also create an instance for
 each:
\end_layout

\begin_layout LyX-Code
private transient final State _newState, _assignedState, 
\end_layout

\begin_layout LyX-Code
                _acceptedState, _fixedState, _closedState;
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   _newState = new NewState();
\end_layout

\begin_layout LyX-Code
   _assignedState = new AssignedState();
\end_layout

\begin_layout LyX-Code
   _acceptedState = new AcceptedState();
\end_layout

\begin_layout LyX-Code
   _fixedState = new FixedState();
\end_layout

\begin_layout LyX-Code
   _closedState = new ClosedState();
\end_layout

\begin_layout LyX-Code
   _stateMap.put(_newState.getName(), _newState);
\end_layout

\begin_layout LyX-Code
   _stateMap.put(_assignedState.getName(), _assignedState);
\end_layout

\begin_layout LyX-Code
   _stateMap.put(_acceptedState.getName(), _acceptedState);
\end_layout

\begin_layout LyX-Code
   _stateMap.put(_fixedState.getName(), _fixedState);
\end_layout

\begin_layout LyX-Code
   _stateMap.put(_closedState.getName(), _closedState);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In addition to instantiation, I've also added each state to a map, defined
 in Issue's superclass.
 At the moment, this is a requirement of the framework.
 We haven't yet specified the starting state, so let's do that:
\end_layout

\begin_layout LyX-Code
public State startState() { return _newState; }
\end_layout

\begin_layout Standard
We also need to provide a mechanism for the Issue's state to be restored
 after an issue is fetched from the database:
\end_layout

\begin_layout LyX-Code
public State restoredState()
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
  return (State) _stateMap.get(getStatus().code());
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Both of these are really simple.
 Here we see that we use the value of the issue's status (which was fetched
 from the database) as a means to fetch the state object from the state
 map.
\end_layout

\begin_layout Standard
I have not yet showed you the support code for the transitions.
 In each state where a command is defined a transition takes place.
 A logged event is created and passed in to the method named transition().
 Here's how I create the logged event:
\end_layout

\begin_layout LyX-Code
private LoggedEvent makeLog(String msg)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   LoggedEvent evt = (LoggedEvent) createInstance(LoggedEvent.class);
\end_layout

\begin_layout LyX-Code
   evt.getMsg().setValue(msg);
\end_layout

\begin_layout LyX-Code
   evt.getType().setValue(LoggedEvent.INFO);
\end_layout

\begin_layout LyX-Code
   evt.setUser(currentUser());
\end_layout

\begin_layout LyX-Code
   evt.setObject(this);
\end_layout

\begin_layout LyX-Code
   return evt;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
private LoggedEvent makeLog(String msg, TextEO longMsg)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   LoggedEvent evt = makeLog(msg);
\end_layout

\begin_layout LyX-Code
   evt.getLongMsg().setValue(longMsg);
\end_layout

\begin_layout LyX-Code
   return evt;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
I provide two utility methods for constructing logged events.
 The first does not require a long message, the second is an overloaded
 version that also sets the long message.
 Notice how commands such as 
\emph on
Fix
\emph default
, 
\emph on
Close
\emph default
 and 
\emph on
RejectFix
\emph default
 specify arguments.
 Recall that JMatter 
\begin_inset Quotes eld
\end_inset

automagically
\begin_inset Quotes erd
\end_inset

 prompts the end user for these arguments in the user interface and then
 feeds them to the commands when invoking their methods.
 These values are then passed in to the 
\emph on
makeLog()
\emph default
 methods.
\end_layout

\begin_layout Standard
Finally, here is the implementation of the 
\emph on
transition()
\emph default
 method:
\end_layout

\begin_layout LyX-Code
private void transition(State state, LoggedEvent evt)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   _history.add(evt);
\end_layout

\begin_layout LyX-Code
   setState(state, true);
\end_layout

\begin_layout LyX-Code
   _status.setValue(state.getName());
\end_layout

\begin_layout LyX-Code
   persistor().updateAssociation(this, evt);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We see here that the logged event is added to the history field, the state
 transition takes place, the status field is updated accordingly (kept in
 sync with the issue's state).
 The final statement ensures that the updated issue and its association
 to the newly created logged event are saved to the database.
\end_layout

\begin_layout Section
Per-State Icons
\end_layout

\begin_layout Standard
Up until now, you've been told that for each type of object you define,
 that JMatter will look for an image file with a specific naming convention
 to use to represent objects of that type.
 This is true, but it's not the whole story.
\end_layout

\begin_layout Standard
Let's take an example.
 For the class 
\emph on
Issue
\emph default
, we provide 
\emph on
Issue32.png
\emph default
 and 
\emph on
Issue16.png
\emph default
.
 However, you're also free to provide additional icons, one for each state:
 
\emph on
IssueAssigned32.png
\emph default
, 
\emph on
IssueAccepted32.png
\emph default
, etc..
 So we see here an extension of the convention.
 For objects with lifecycles, the icon can be made to further reflect the
 state of the object you're viewing.
 I have specified custom icons for each of Issue's five states.
 Here's (figure 
\begin_inset LatexCommand ref
reference "cap:State-Specific-Icon-Support"

\end_inset

) a screenshot of the icons in my 
\emph on
resources/images
\emph default
 directory, along with their corresponding file names.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/IssueMgr-1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
State-Specific Icon Support
\begin_inset LatexCommand label
name "cap:State-Specific-Icon-Support"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Additional Metadata
\end_layout

\begin_layout Standard
We've defined a number of commands, such as 
\emph on
Fix(CommandInfo cmdInfo, StringEO fix, TextEO description)
\emph default
.
 We customized the captions for the two arguments 
\emph on
fix
\emph default
, and 
\emph on
description
\emph default
 so the end user is clear about what information he or she will have to
 enter.
 We did this by annotating the method's arguments with 
\emph on
@Arg
\emph default
 annotations, like this:
\end_layout

\begin_layout LyX-Code
public void Fix(CommandInfo cmdInfo,
\end_layout

\begin_layout LyX-Code
                      @Arg("Fix") StringEO fix,
\end_layout

\begin_layout LyX-Code
                      @Arg("Description") TextEO description)
\end_layout

\begin_layout Standard
The annotation takes a single argument, the parameter caption.
\end_layout

\begin_layout Standard
There's a second, much more important issue that needs to be addressed though.
 In the case of our issue manager application, it's not enough that the
 command 
\emph on
accept
\emph default
 be only accessible in 
\emph on
Assigned
\emph default
 state.
 Only the developer who has been assigned the particular issue should be
 allowed to accept the issue.
 The same applies to the 
\emph on
fix
\emph default
 command.
 For 
\emph on
rejectFix
\emph default
 and 
\emph on
close
\emph default
, the same idea applies: only the user who opened the issue should be allowed
 to close it, not the developer.
\end_layout

\begin_layout Standard
JMatter provides a means to specify what user is the 
\emph on
owner
\emph default
 of a command.
 A command's owner is the only user who will be allowed to invoke it.
 JMatter will not even display the command's views (a button or a menu item)
 to any other user.
 Here's how this is done:
\end_layout

\begin_layout LyX-Code
static
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   ComplexType type = ComplexType.forClass(Issue.class);
\end_layout

\begin_layout LyX-Code
   type.command("Accept", AssignedState.class).setOwner(type.field("assignedTo"));
\end_layout

\begin_layout LyX-Code
   type.command("Fix", AcceptedState.class).setOwner(type.field("assignedTo"));
\end_layout

\begin_layout LyX-Code
   type.command("RejectFix", FixedState.class).setOwner(type.field("openedBy"));
\end_layout

\begin_layout LyX-Code
   type.command("Close", FixedState.class).setOwner(type.field("openedBy"));
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
I hope you'll agree this is fairly terse, yet clear and legible code.
 The last line, for example, interprets to 
\begin_inset Quotes eld
\end_inset

the owner for the command named 
\emph on
Close
\emph default
 (in 
\emph on
Fixed
\emph default
 state) is the value of the issue's 
\emph on
openedBy
\emph default
 field.
 In other words, whoever opened the issue is the one authorized to close
 it.
\end_layout

\begin_layout Section
A Few Loose Ends
\end_layout

\begin_layout Subsection
Default Assigned-To Developer
\end_layout

\begin_layout Standard
It sure would be nice if each time I created a new issue, a certain developer
 would be the default user assigned to the issue.
 One way to do this is to specify the default in the file 
\emph on
resources/model-metadata.properties
\emph default
, like this:
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
Issue.assignedTo.default=from User as user where user.username='eitan'
\end_layout

\begin_layout Standard
We've already used this file to specify field metadata such as whether and
 which fields are required.
 Here we're specifying a default.
 We can either hard-code it, or specify any valid hql (hibernate query language)
 that will return an instance of a valid type.
\end_layout

\begin_layout Subsection
Automatically Setting OpenedBy
\end_layout

\begin_layout Standard
Each time we create an issue, the person who opened the issue is by definition
 the currently logged in user.
 How do we programmatically specify that this should automatically happen?
 Here is one way to do this:
\end_layout

\begin_layout LyX-Code
public void onBeforeCreate()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   super.onBeforeCreate();
\end_layout

\begin_layout LyX-Code
   setOpenedBy(currentUser());
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This method overrides a superclass method, one that is notified prior to
 the creation of an object.
 It turns out that persistent objects (such as 
\emph on
Issue
\emph default
) are not the only ones that can listen to various object persistence lifecycle
 events.
 JMatter provides a generic notification mechanism that any object can take
 advantage of.
 Each type of event is defined by a string constant, such as DELETE, SAVE,
 BEFORECREATE, CREATE.
 You'll see an example use of this mechanism shortly.
 It's also worth noting that besides object persistence events, JMatter
 provides hooks for application events such as login and logout events.
\end_layout

\begin_layout Subsection
Transitioning to AssignedState
\end_layout

\begin_layout Standard
You might have noticed that I have left a glaring omission: how exactly
 does an issue transition to assigned state? The transition should take
 place when a user is associated to the 
\emph on
assignedTo
\emph default
 property of 
\emph on
Issue
\emph default
.
\end_layout

\begin_layout Standard
We need to be careful here.
 The setter method is called not only when an association is made but also
 when the object is restored from the persistence store (the database).
 To distinguish between these two contexts, JMatter allows the definition
 of an additional method, the 
\emph on
associate
\emph default
 method.
 It works like this: if both a setter and an associator are defined, JMatter
 will make sure to call the associator only when associating (calling only
 the setter when restoring the property from db).
\end_layout

\begin_layout Standard
Here's the implementation:
\end_layout

\begin_layout LyX-Code
public void associateAssignedTo(User user)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   setAssignedTo(user);
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
   if (_assignedTo != null && !_assignedTo.isEmpty())
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      if (isEditableState())
\end_layout

\begin_layout LyX-Code
      {
\end_layout

\begin_layout LyX-Code
         addAppEventListener(ONCREATE, new AppEventListener()
\end_layout

\begin_layout LyX-Code
         {
\end_layout

\begin_layout LyX-Code
            public void onEvent(AppEvent appEvent)
\end_layout

\begin_layout LyX-Code
            {
\end_layout

\begin_layout LyX-Code
               transition(_assignedState, 
\end_layout

\begin_layout LyX-Code
                          makeLog("Assigned to "+_assignedTo));
\end_layout

\begin_layout LyX-Code
            }
\end_layout

\begin_layout LyX-Code
         });
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      else
\end_layout

\begin_layout LyX-Code
      {
\end_layout

\begin_layout LyX-Code
         transition(_assignedState, makeLog("Assigned to "+_assignedTo));
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This code looks a little complicated.
 It has to concern itself with a specific issue.
 A call to the 
\emph on
transition()
\emph default
 method has the side effect of saving everything and putting the object
 in read state.
 We want to delay the call to transition if the association is made while
 the issue is in an editable state (before it has been saved, while it's
 being edited).
\end_layout

\begin_layout Standard
I'm resorting to using JMatter's application event notification mechanism.
 If the association is made in read state, I simply transition.
 Otherwise, I delay transitioning until after the editing is complete.
\end_layout

\begin_layout Section
Issue Categories
\end_layout

\begin_layout Standard
Our implementation of Issue is now complete.
 Let's add one last feature.
 It might be helpful to define various categories of issues and classify
 issues according to these categories.
\end_layout

\begin_layout Standard
The first thing we do is define an issue category type:
\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class IssueCategory extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO _name = new StringEO();
\end_layout

\begin_layout LyX-Code
   public IssueCategory() {}
\end_layout

\begin_layout LyX-Code
   public StringEO getName() { return _name; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Title title() { return _name.title(); }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Nothing fancy here.
 An issue category is defined to have a single field: a name.
\end_layout

\begin_layout Standard
Rather than define a to-many relationship to issue, I'm going to add a command
 that will fetch the category's issues from the database and return a paged
 list:
\end_layout

\begin_layout LyX-Code
@Cmd
\end_layout

\begin_layout LyX-Code
public Object Issues(CommandInfo cmdInfo)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   ComplexType type = ComplexType.forClass(Issue.class);
\end_layout

\begin_layout LyX-Code
   FieldPath path = new FieldPath("com.u2d.issuemgr.Issue#category");
\end_layout

\begin_layout LyX-Code
   QuerySpecification spec = new QuerySpecification(path,
\end_layout

\begin_layout LyX-Code
         new IdentityInequality().new Equals(), this);
\end_layout

\begin_layout LyX-Code
   SimpleQuery query = new SimpleQuery(type, spec);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   return new PagedList(query);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
I'm not entirely satisfied with the implementation.
 I'd like to be able to use plain old hql or the hibernate API to define
 this query.
 The above uses JMatter's own API for defining queries, which basically
 says: 
\emph on
fetch all issues where the category equals 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
On the issue side, we need to add a to-one association to the issue category:
\end_layout

\begin_layout LyX-Code
private IssueCategory _category;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public IssueCategory getCategory() { return _category; }
\end_layout

\begin_layout LyX-Code
public void setCategory(IssueCategory category)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   IssueCategory oldValue = _category;
\end_layout

\begin_layout LyX-Code
   _category = category;
\end_layout

\begin_layout LyX-Code
   firePropertyChange("category", oldValue, _category);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We also need to update our 
\emph on
fieldOrder
\emph default
 metafield:
\end_layout

\begin_layout LyX-Code
public static String[] fieldOrder = {"status", "title", "description", 
\end_layout

\begin_layout LyX-Code
      "notes", "openedBy", "assignedTo", "history", "severity", 
\end_layout

\begin_layout LyX-Code
      "priority", "category"};
\end_layout

\begin_layout Standard
That's it for the coding.
 Make sure to update the schema and let's run the application.
\end_layout

\begin_layout Section
The Application
\end_layout

\begin_layout Standard
Just because we finished coding does not mean that we're done configuring
 our application.
 For example, it might be useful to define a few standard queries such as
 
\emph on
List Outstanding Issues
\emph default
 and 
\emph on
List Closed Issues
\emph default
 that pre-filters the listing (using JMatter's Smart List mechanism).
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "cap:The-Issue-Manager"

\end_inset

 below shows the issue manager in action.
 I'm listing all issues to illustrate how the issue's icon reflects its
 state (the ones with a lock are closed issues, the ones with the pencil
 are accepted, and supposedly, being worked on).
 I'm also showing two smart lists that I've created and that I often use
 to check out outstanding issues.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/IssueMgr-2.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
The Issue Manager
\begin_inset LatexCommand label
name "cap:The-Issue-Manager"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I also often view issues in tabular view, which allows me to sort issues
 by priority or severity (sorting is invoked by clicking on the table column
 header).
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
As in previous chapters, allow me to show you the stats for this application,
 in terms of lines of code:
\end_layout

\begin_layout LyX-Code
eitan@ubuntu:~/projects/ds/IssueMgr/src/com/u2d/issuemgr$ wc -l *.java
\end_layout

\begin_layout LyX-Code
  40 IssueCategory.java
\end_layout

\begin_layout LyX-Code
 232 Issue.java
\end_layout

\begin_layout LyX-Code
  28 IssueState.java
\end_layout

\begin_layout LyX-Code
 300 total
\end_layout

\begin_layout Standard
Three classes totaling 300 lines of code.
 The current state of lifecycle support in JMatter is pretty strong.
 Its implementation is a natural extension of the conventions already establishe
d for simpler business objects.
 Nevertheless, I believe the implementation can be streamlined further and
 place even less requirements on the developer.
 For example the requirement to add the various states to a state map could
 be done by the framework.
\end_layout

\begin_layout Standard
In summary, support for business objects lifecycle is a necessary component
 of supporting the development of business applications in general.
 Many business objects naturally embody lifecycles, including orders (new,
 confirmed, fulfilled, etc..), visits (scheduled, canceled, confirmed, ongoing,
 archived), etc..
\end_layout

\begin_layout Standard
We have now covered four distinct applications: a contact manager, the MyTunes
 application, the Sympster conference manager, and finally our issue manager
 in a very short time.
 JMatter also comes with a movie library application, that, among other
 things, illustrates many-to-many relationships, as well as two other demonstrat
ion applications that illustrate how to integrate custom views into your
 application (the topic of chapter 
\begin_inset LatexCommand vref
reference "cha:Customized-Views-and"

\end_inset

).
\end_layout

\begin_layout Standard
Let's now turn our attention to part 
\begin_inset LatexCommand vref
reference "par:Framework-Reference"

\end_inset

, which covers the JMatter framework in detail.
\end_layout

\begin_layout Part
Framework Reference
\begin_inset LatexCommand label
name "par:Framework-Reference"

\end_inset


\end_layout

\begin_layout Chapter
Dichotomy of a Model Object
\begin_inset LatexCommand label
name "cha:model-objs-ref"

\end_inset


\end_layout

\begin_layout Standard
Let's begin by taking a look at a very simple model for a Person:
\end_layout

\begin_layout LyX-Code
package com.u2d.contactmgr;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import ...
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Person
\end_layout

\begin_layout LyX-Code
      extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO name = new StringEO();
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Person() { }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public StringEO getName() { return name; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   @Cmd
\end_layout

\begin_layout LyX-Code
   public String SayHello(CommandInfo info) { return "Hi"; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Title title() { return name.title(); }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We see that:
\end_layout

\begin_layout Enumerate
At the most basic level a class definition consists of data and behaviour,
 implemented as fields and commands (or methods), known as the type's members.
\end_layout

\begin_layout Enumerate
JMatter relies heavily on conventions for the purpose of inferring information
 about a type.
\end_layout

\begin_layout Standard
Here are some of the conventions:
\end_layout

\begin_layout Enumerate
Our class must extend the base type 
\emph on
AbstractComplexEObject.

\emph default
 This base class is a partial implementation of the 
\emph on
ComplexEObject
\emph default
 interface.
\end_layout

\begin_layout Enumerate
We have a field, the person's name, defined via a private variable but inferred
 from a getter method
\end_layout

\begin_layout Enumerate
We have a command, 
\begin_inset Quotes eld
\end_inset

Say Hello
\begin_inset Quotes erd
\end_inset

, implemented of course as a method.
\end_layout

\begin_layout Enumerate
Every type must also provide an implementation of the method 
\emph on
title()
\emph default
, which in a sense defines instances' labels, or captions in the application's
 user interface.
 The 
\emph on
Title
\emph default
 class exists simply to facilitate the task of constructing a title when
 we wish those titles to be constructed by concatenating various field values.
\end_layout

\begin_layout Enumerate
We use the 
\emph on
@Persist
\emph default
 annotation to mark the type as one that we want to persist to database.
\end_layout

\begin_layout Enumerate
We mark a method with the 
\emph on
@Cmd
\emph default
 annotation to indicate that we wish to expose this method to the user interface.
\end_layout

\begin_layout Standard
There exist a number of subtleties too.
 Here are some examples:
\end_layout

\begin_layout Enumerate
For command methods that return a String, the returned string is implied
 to be a message returned by the action that JMatter will display to the
 user.
\end_layout

\begin_layout Enumerate
Commands can accept arguments (I'll have more to say about that later).
\end_layout

\begin_layout Enumerate
Type commands can be defined by marking the method as static.
\end_layout

\begin_layout Enumerate
JMatter infers the type names and captions, member names and captions from
 our choice of class name, getter method name, and command method name.
 This is done via run-time reflection in Java.
\end_layout

\begin_layout Standard
The total sum of conventions and features supported by JMatter is 
\series bold
much
\series default
 lengthier than this basic introduction.
 Let us then delve into the details.
\end_layout

\begin_layout Section
Types
\end_layout

\begin_layout Standard
When building a JMatter application, your job as a developer is to develop
 the model completely, using object-oriented techniques: accounting for
 both data and behaviour.
\end_layout

\begin_layout Standard
You can think of the complete application as having a model-view-controller
 design.
 In the case of JMatter, the view and controller are generic, and already
 implemented.
 This frees you to focus on the model.
\end_layout

\begin_layout Standard
From a persistence perspective, all types inherit three fields or pseudo
 fields:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" leftline="true" width="1in">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="4in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Field
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Serves as surrogate primary key.
 You do not need to define a primary key for your types.
 The framework does this for you.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
version
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
This field is used by the underlying hibernate persistence framework to
 keep track of whether two objects are being edited at the same time, used
 for optimistic locking.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
createdOn
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
A read-only field that records the date and time that an object is created.
 When displaying a view of an object in form view, the value of this field
 is displayed at the bottom, in the view's status bar.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Fields
\end_layout

\begin_layout Standard
JMatter makes a distinction between atomic fields and complex fields, where
 atomic fields have a single value, while complex fields are in a sense
 composed of atomic and other fields.
\end_layout

\begin_layout Standard
There's a second distinction that has to do with ownership of a field.
 Composite, or aggregate fields are ones that are wholly owned by their
 parent object.
 All atomic fields are aggregates.
 Associations on the other hand are fields that represent relationships
 to other objects, or entities; these relationships can be set or severed.
 Field ownership has implications on specific operations.
 For example, if the parent object is deleted, associations are only severed,
 but the associated object is not deleted.
 That is, the delete operation does not cascade to associations.
 A deletion on the other hand implies the deletion of child aggregate fields.
\end_layout

\begin_layout Standard
It turns out that JMatter's domain design happens to match the rules set
 forth by Eric Evans in his book Domain Driven Design 
\begin_inset LatexCommand cite
key "Evans"

\end_inset

.
 If you're familiar with this work, then the notions of entities, value
 objects, and aggregates and their interrelationships should already by
 familiar to you.
\end_layout

\begin_layout Standard
We also need to discuss how to model fields with different cardinalities.
 There are of course to-one relationships, and * or to-many relationships.
\end_layout

\begin_layout Subsection
Atomic Fields
\end_layout

\begin_layout Standard
JMatter defines and provides implementations for a variety of types of atomic
 fields.
 Developers are required to use the framework's definitions.
 That is, a string-based field must be defined as a 
\emph on
com.u2d.type.atomic.StringEO
\emph default
 and not a 
\emph on
java.lang.String
\emph default
.
 Internally the frameworks' atomic type implementations often wrap or encapsulat
e the more primitive type.
\end_layout

\begin_layout Standard
The framework's atomic types are modeled as value objects.
 JMatter defines an interface for Atomics, 
\emph on
com.u2d.model.AtomicEObject.
\end_layout

\begin_layout Standard
The framework requires that all aggregate type fields be implemented as
 final fields.
 Consequently accessor methods for these fields comprise of only a getter
 method.
 The definitions look like this:
\end_layout

\begin_layout LyX-Code
private final StringEO name = new StringEO();
\end_layout

\begin_layout LyX-Code
public StringEO getName() { return name; }
\end_layout

\begin_layout Standard
You may wonder then how one sets the value of an object's name field? All
 value objects have a method:
\end_layout

\begin_layout LyX-Code
public void setValue(EObject value);
\end_layout

\begin_layout Standard
to provide a means for setting the value.
 That is, the reference to the object never changes, only its contained
 value.
 StringEO has an additional convenience method:
\end_layout

\begin_layout LyX-Code
public void setValue(String value);
\end_layout

\begin_layout Standard
Other atomic types have similar conveniences.
 IntEO for example (which represents an integer) has this convenience method:
\end_layout

\begin_layout LyX-Code
public void setValue(int value);
\end_layout

\begin_layout Standard
These types also have a corresponding way of getting the represented value
 as a simple Java primitive or object.
 IntEO has:
\end_layout

\begin_layout LyX-Code
public int intValue();
\end_layout

\begin_layout Standard
StringEO has:
\end_layout

\begin_layout LyX-Code
public String stringValue();
\end_layout

\begin_layout Standard
..and, you guessed it, DateEO has:
\end_layout

\begin_layout LyX-Code
public Date dateValue();
\end_layout

\begin_layout Standard
Finally, all these atomic types are 
\emph on
ChangeNotifier
\emph default
's, which means that they publish (or 
\emph on
fire
\emph default
, in pub/sub speak) change events that you can listen to.
 This can be useful for building lotus123-style dependencies between objects
 (when A changes, update B).
 This is also useful internally to keep the user interface in sync with
 its underlying model.
\end_layout

\begin_layout Subsubsection
Build-In Atomics
\end_layout

\begin_layout Standard
Here is a listing of the various JMatter atomic types:
\end_layout

\begin_layout LyX-Code
BooleanEO, CharEO, ChoiceEO, ColorEO, DateEO, DateTime, DateWithAge, 
\end_layout

\begin_layout LyX-Code
Email, FileEO, FileWEO, FloatEO, ImgEO, IntEO, Logo, LongEO, 
\end_layout

\begin_layout LyX-Code
Password, Percent, Photo, SSN, StringEO, TextEO, TimeEO, 
\end_layout

\begin_layout LyX-Code
TimeInterval, TimeSpan, URI, USDollar, USPhone, USZipCode.
\end_layout

\begin_layout Standard
They are all defined in the 
\emph on
package com.u2d.type.atom.

\emph default
 Writing your own additional types is quite straightforward.
 The existing implementations represent a wealth of examples that one can
 draw from.
\end_layout

\begin_layout Subsection
Composite Fields
\end_layout

\begin_layout Standard
There isn't much to say about composite (or aggregates) fields that I haven't
 already.
 Again, what makes a field an aggregate in the framework is the fact that
 its member is defined as a value object: define a final field, and only
 a getter method.
 Here's an example:
\end_layout

\begin_layout LyX-Code
public class Person extends AbstractComplexEObject implements Emailable
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   protected final Name _name = new Name();
\end_layout

\begin_layout LyX-Code
   public Name getName() { return _name; }
\end_layout

\begin_layout LyX-Code
   ...
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The 
\emph on
setValue()
\emph default
 method applies to composite fields.
 For example, to copy one contact's address to another by value, you might
 do this:
\end_layout

\begin_layout LyX-Code
public void copyAddress(Contact fromContact, Contact toContact)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  toContact.getAddress().setValue(fromContact.getAddress());
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsubsection
Composite Types Provided with the Framework
\end_layout

\begin_layout Standard
The framework predefines a number non-atomic, or higher-level types.
 They're reside in the package 
\emph on
com.u2d.type.composite
\emph default
.
 Here's a list of type names:
\end_layout

\begin_layout LyX-Code
Name, USAddress, ContactMethod, Contact, BusinessContact, 
\end_layout

\begin_layout LyX-Code
EmailMessage, Folder, Note, Person, Business, LoggedEvent
\end_layout

\begin_layout Subsubsection
Composite Indexed Field
\end_layout

\begin_layout Standard
JMatter provides a means for modeling a composite field with a to-many (*)
 cardinality.
 A prototypical example is the relationship between an Order and its list
 of OrderItems.
\end_layout

\begin_layout Standard
JMatter provides the type 
\emph on
com.u2d.list.CompositeList
\emph default
 for the task.
 Here's an example field definition inside an 
\emph on
Order
\emph default
 class:
\end_layout

\begin_layout LyX-Code
private final CompositeList _orderItems = 
\end_layout

\begin_layout LyX-Code
                 new CompositeList(OrderItem.class, this, "order");
\end_layout

\begin_layout LyX-Code
public static final Class lineItemsType = OrderItem.class;
\end_layout

\begin_layout LyX-Code
public CompositeList getLineItems() { return _orderItems; }
\end_layout

\begin_layout Standard
Here's the constructor method signature:
\end_layout

\begin_layout LyX-Code
public CompositeList(Class clazz, ComplexEObject parent, String parentFldname);
\end_layout

\begin_layout Standard
The first argument is the child type (Order Items).
 The second is a reference to the parent object (this).
 Finally, there's a convention where CompositeList can automatically give
 child objects a reference to its containing, parent object.
 This is done by writing a setter method in the child type definition:
\end_layout

\begin_layout LyX-Code
private Order _order;
\end_layout

\begin_layout LyX-Code
public void setOrder(Order order) { _order = order; }
\end_layout

\begin_layout Standard
and passing the name of the field (
\emph on
order
\emph default
) as an argument to the CompositeList constructor.
\end_layout

\begin_layout Standard
Notice that you also must (at the present time) provide metadata for the
 framework to introspect the list type statically.
 The framework looks for a public static variable name of type 
\emph on
Class
\emph default
 of the form 
\emph on
<fieldname>Type.
\end_layout

\begin_layout Standard
In the user interface, JMatter provides an tabular component that provides
 means for adding child items, deleting them, editing them, etc..
\end_layout

\begin_layout Subsection
Associations
\end_layout

\begin_layout Subsubsection
To-One Associations
\end_layout

\begin_layout Standard
A to-one association definition is essentially the implementation of a JavaBeans
 bound property.
 Let's look at an example, 
\emph on
Song.artist
\emph default
:
\end_layout

\begin_layout LyX-Code
private Artist _artist = null;
\end_layout

\begin_layout LyX-Code
public Artist getArtist() { return _artist; }
\end_layout

\begin_layout LyX-Code
public void setArtist(Artist artist)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  Artist oldValue = _artist;
\end_layout

\begin_layout LyX-Code
  _artist = artist;
\end_layout

\begin_layout LyX-Code
  firePropertyChange("artist", oldValue, _artist);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
That's about it.
\end_layout

\begin_layout Subsubsection
To-Many Associations
\end_layout

\begin_layout Standard
For an indexed association, use the type 
\emph on
com.u2d.list.RelationalList
\emph default
.
 Here's an example, from the Sympster demo application (
\emph on
Speaker.talks
\emph default
):
\end_layout

\begin_layout LyX-Code
public class Speaker extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  private final RelationalList talks = new RelationalList(Talk.class);
\end_layout

\begin_layout LyX-Code
  public static final Class talksType = Talk.class;
\end_layout

\begin_layout LyX-Code
  public RelationalList getTalks() { return talks; }
\end_layout

\begin_layout LyX-Code
  ..
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We do three things:
\end_layout

\begin_layout Enumerate
define a final member variable, 
\emph on
talks
\end_layout

\begin_layout Enumerate
provide metadata for the framework to statically introspect the type to
 determine the list type
\end_layout

\begin_layout Enumerate
supply a getter method
\end_layout

\begin_layout Subsubsection
Bidirectional Associations
\end_layout

\begin_layout Standard
We often like to be able to navigate an association from both directions.
 Take the example of a speaker and his or her list of presentations.
 The presentation would have an association to its speaker, and the speaker
 may have a to-many association called 
\emph on
presentations
\emph default
.
\end_layout

\begin_layout Standard
You can define both associations in the manner described in the two previous
 subsections:
\end_layout

\begin_layout LyX-Code
public class Speaker..
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  private final RelationalList talks = new RelationalList(Talk.class);
\end_layout

\begin_layout LyX-Code
  public static final Class talksType = Talk.class;
\end_layout

\begin_layout LyX-Code
  public RelationalList getTalks() { return talks; }
\end_layout

\begin_layout LyX-Code
  ..
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
public class Talk..
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  private Speaker speaker;
\end_layout

\begin_layout LyX-Code
  public Speaker getSpeaker() { return speaker; }
\end_layout

\begin_layout LyX-Code
  public void setSpeaker(Speaker spk)
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
    Speaker oldValue = this.speaker;
\end_layout

\begin_layout LyX-Code
    this.speaker = spk;
\end_layout

\begin_layout LyX-Code
    firePropertyChange("speaker", oldValue, this.speaker);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In addition, you need to supply metadata for the framework to infer the
 other side of the relationship.
 The implementation at the moment is not too elegant but is nevertheless
 simple enough.
 In class Talk, add:
\end_layout

\begin_layout LyX-Code
public static String speakerInverseFieldName = "talks";
\end_layout

\begin_layout Standard
And in Speaker:
\end_layout

\begin_layout LyX-Code
public static String talksInverseFieldName = "speaker";
\end_layout

\begin_layout Standard
Basically, the field name is of the form: 
\emph on
<fieldname>InverseFieldName
\emph default
.
 Speaker has a field named talks, so the variable name is 
\emph on
talksInverseFieldName
\emph default
.
 Its value is the name of the inverse field: the talk's speaker's field
 name is 
\emph on
speaker
\emph default
.
 Both sides must define the bit of metadata.
\end_layout

\begin_layout Subsection
Choice Types
\end_layout

\begin_layout Standard
The notion of a Choice in JMatter is somewhat analogous to what programmers
 call 
\emph on
enumerations
\emph default
.
 JMatter provides two flavors of choices.
 The first and more basic flavor is the 
\emph on
ChoiceEO
\emph default
 and is implemented as an atomic object.
\end_layout

\begin_layout Standard
This flavor is suitable for enumerations (or small lists) that are static;
 i.e.
 they do not change.
 The framework itself implements a couple of types as ChoiceEO's.
 As part of my work on providing access control to information, I define
 a 
\emph on
FieldRestrictionType
\emph default
 (in package 
\emph on
com.u2d.restrict
\emph default
) as follows:
\end_layout

\begin_layout LyX-Code
public class FieldRestrictionType extends ChoiceEO
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public FieldRestrictionType() {}
\end_layout

\begin_layout LyX-Code
   public FieldRestrictionType(String value)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      setValue(value);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   private static Set STATUS_OPTIONS = new HashSet();
\end_layout

\begin_layout LyX-Code
   static
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      STATUS_OPTIONS.add(FieldRestriction.NONE);
\end_layout

\begin_layout LyX-Code
      STATUS_OPTIONS.add(FieldRestriction.READ_ONLY);
\end_layout

\begin_layout LyX-Code
      STATUS_OPTIONS.add(FieldRestriction.HIDDEN);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public Collection entries() { return STATUS_OPTIONS; }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We also wrote a ChoiceEO in chapter 
\begin_inset LatexCommand ref
reference "cha:Issue-Manager"

\end_inset

 to define the various states for an 
\emph on
Issue
\emph default
.
 Basically the way to define such enumerations is by extending the base
 type 
\emph on
ChoiceEO
\emph default
 and implementing the method 
\emph on
entries()
\emph default
.
 The editors for these types are Swing JComboBoxes (pick lists).
\end_layout

\begin_layout Standard
The second flavor is modeled as a 
\emph on
ComplexEObject
\emph default
.
 The data is not hard-coded and the type is defined as an entity in the
 database.
 These lists are more versatile in that one can define new entries, new
 choices as a system evolves.
 We developed an example implementation in the MyTunes tutorial chapter,
 to define song genres.
\end_layout

\begin_layout Standard
The framework provides full create/edit/delete capabilities for these types.
 They are defined by extending the type 
\emph on
AbstractChoiceEO
\emph default
.
 The framework itself defines four such types of choices: US States, Sex,
 Marrital Status, Contact Method (instances of these four types are pre-populate
d from the xml files located in 
\emph on
jmatter/resources/data
\emph default
).
\end_layout

\begin_layout Standard
Both flavors adhere to the 
\emph on
Choice
\emph default
 interface:
\end_layout

\begin_layout LyX-Code
public interface Choice
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public String code();
\end_layout

\begin_layout LyX-Code
   public String caption();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Section
Commands
\end_layout

\begin_layout Standard
Let's discuss how commands work in detail.
 Here is the basic syntax:
\end_layout

\begin_layout LyX-Code
@Cmd
\end_layout

\begin_layout LyX-Code
public <modifier> <returntype> <MethodName>(CommandInfo cmdInfo, 
\end_layout

\begin_layout LyX-Code
                                 [additional arguments]) { <body> }
\end_layout

\begin_layout Standard
This is not really that different from the task of defining any method.
 The main differences are:
\end_layout

\begin_layout Enumerate
Marking the method with the 
\emph on
@Cmd
\emph default
 annotation exposes it to the UI
\end_layout

\begin_layout Enumerate
The first argument to the method is some context information about the command
 invocation (at the moment you don't really need to concern yourself with
 the 
\emph on
CommandInfo
\emph default
 type; I am discovering that this information is rarely needed and am beginning
 to question passing this argument).
\end_layout

\begin_layout Standard
Making the method static has the effect of defining the command on the type
 instead of its instances.
 You can see the command action exposed as a context menu on the type in
 the classbar (or anywhere else, say after browsing types).
\end_layout

\begin_layout Standard
If the method returns a String, that string is treated as a message that
 is displayed to the user in a sort of self-dismissing dialog box.
\end_layout

\begin_layout Standard
If the method returns a type that is viewable (another entity), the framework
 makes sure to display a view of the returned instance after the command
 is invoked.
\end_layout

\begin_layout Standard
If the method accepts arguments, then the framework will first prompt the
 user for these arguments (via an input form) before proceeding to invoke
 the command.
 Take for example, this command, defined on 
\emph on
User.java
\emph default
 in the framework:
\end_layout

\begin_layout LyX-Code
@Cmd(mnemonic='p')
\end_layout

\begin_layout LyX-Code
public String ChangePassword(CommandInfo cmdInfo,
\end_layout

\begin_layout LyX-Code
                              @Arg("New Password") Password password)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   _password.setValue(password);
\end_layout

\begin_layout LyX-Code
   save();
\end_layout

\begin_layout LyX-Code
   log(LoggedEvent.INFO, cmdInfo.getCommand(), "User changed password");
\end_layout

\begin_layout LyX-Code
   return "Password has been changed";
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
When an end-user invokes this command (by pressing the 
\emph on
Change Password
\emph default
 button on an instance of a user), he or she will first be prompted to enter
 a password, using the caption 
\emph on
New Password
\emph default
.
 The framework does it all.
 Once the password is entered, the framework proceeds to invoke the command
 (in the proper thread).
 In this case, the password editor takes care to properly validate the password
 before the method is ever invoked.
\end_layout

\begin_layout Subsection
Types of Commands
\end_layout

\begin_layout Standard
So we see that with the 
\emph on
@Cmd
\emph default
 annotation, we can expose a method to the user interface.
 Also note the subtlety of adding the static modifier to define a command
 on a different object: the instance's type, rather than the instance itself.
\end_layout

\begin_layout Standard
So we have two types of commands: instance commands and type commands.
 In the JMatter framework, the Java class 
\emph on
ComplexType
\emph default
 represents or models a type, in the same way that the class 
\emph on
java.lang.Class
\emph default
 is an instance's type.
 You will also find 
\emph on
@Cmd
\emph default
 definitions in 
\emph on
ComplexType
\emph default
.
 So the JMatter framework uses many of the concepts that it defines for
 application development internally, to build itself.
 Also this should make you realize that a type command on a given object
 is nothing more than an instance command on its type instance.
\end_layout

\begin_layout Standard
Atomic types can have their own commands too.
 They can be invoked from the UI by right-clicking on the rendered value.
 For example, 
\emph on
StringEO
\emph default
 has the command 
\emph on
Capitalize()
\emph default
.
 We encourage you to define additional commands that might be useful to
 the plethora of atomic types that JMatter defines.
\end_layout

\begin_layout Subsubsection
Type Commands
\end_layout

\begin_layout Standard
Aside from marking a method static to designate a command belong to the
 instance's type, you also have the option of specifying a method signature
 with an extra parameter, like this:
\end_layout

\begin_layout LyX-Code
@Cmd
\end_layout

\begin_layout LyX-Code
public static void SayHi(CommandInfo cmdInfo, ComplexType targetType) ...
\end_layout

\begin_layout Standard
The last parameter is optional.
 If specified, then JMatter will make sure and pass a reference to the target
 object (a ComplexType) upon which the command was invoked.
 Even though the method is static, it was invoked in the context of an instance,
 which happens to be a type.
 In some circumstances, the called method needs to know what context it
 was called in, and needs a reference to that object.
\end_layout

\begin_layout Subsubsection
List Commands
\end_layout

\begin_layout Standard
Aside from type and instance commands, there is a third type of command:
 list commands.
 List commands can be defined in several ways.
\end_layout

\begin_layout Standard
First, if an instance command is given the annotation attribute 
\emph on
batchable
\emph default
 as shown here:
\end_layout

\begin_layout LyX-Code
@Cmd(batchable=true)
\end_layout

\begin_layout LyX-Code
public void Email(CommandInfo cmdInfo) ...
\end_layout

\begin_layout Standard
This is an indication that the command can be invoked 
\emph on
in batch
\emph default
, so to speak; that is, given a list of instances (perhaps search results
 from a query), you will be able to invoke that command on all the items
 in the list.
 The logic basically iterates over all instances in the list and invokes
 the command on each instance.
\end_layout

\begin_layout Standard
There exists a command 
\emph on
Email
\emph default
 on JMatter's type 
\emph on
Person
\emph default
, which launches your default email client and opens a compose window with
 the destination address pre-filled with the person's email address information.
 You can try this from the 
\emph on
ContactMgr
\emph default
 demo application.
 To invoke it in batch mode, just bring up a list of contacts and right-click
 on the list-view's title to reveal its context menu.
\end_layout

\begin_layout Standard
Invoking the 
\emph on
Email
\emph default
 command in batch will open multiple compose windows, one for each recipient
 on the list.
\end_layout

\begin_layout Standard
The additional command: 
\emph on
EmailWithSubject
\emph default
, defined like this:
\end_layout

\begin_layout LyX-Code
@Cmd(batchable=true)
\end_layout

\begin_layout LyX-Code
public void EmailWithSubject(CommandInfo cmdInfo, @Arg("Subject") StringEO
 subject)
\end_layout

\begin_layout Standard
prompts you for a subject line and then launches your email client's compose
 command.
 Note that this command is also marked as batchable.
 JMatter is smart enough to ask you for the subject line once, irrespective
 of the number of times the command is invoked.
\end_layout

\begin_layout Standard
What if we wanted the behavior of the command to be smarter? That is, we
 wish to write a separate implementation of 
\emph on
Email
\emph default
, perhaps named 
\emph on
EmailAll
\emph default
, that opened a single composition window, but that specified multiple addresses
 (the addresses of each of the persons on the list) in the 
\emph on
To:
\emph default
 field.
\end_layout

\begin_layout Standard
To do that, define a list command, like this:
\end_layout

\begin_layout LyX-Code
@ListCmd
\end_layout

\begin_layout LyX-Code
public static String EmailAll(CommandInfo cmdInfo, AbstractListEO list)
 ...
\end_layout

\begin_layout Standard
The command will be exposed on the list and the method will be invoked,
 passing in the list reference as an argument to the method.
 You can now iterate over the list items to grab all the email addresses,
 but implement the method such that a single email message is composed.
\end_layout

\begin_layout Standard
Finally, List Commands also allow multiple parameters, here's an example:
\end_layout

\begin_layout LyX-Code
@ListCmd
\end_layout

\begin_layout LyX-Code
public static String EmailAllWithSubject(CommandInfo cmdInfo, AbstractListEO
 list, 
\end_layout

\begin_layout LyX-Code
                                         @Arg("Subject") StringEO subject)
\end_layout

\begin_layout Standard
Note that list commands must be denoted as 
\emph on
static
\emph default
.
 Please refer to the 
\emph on
Person
\emph default
 class for the complete code listing.
 
\end_layout

\begin_layout Standard
List commands are a powerful tool that can significantly increase the usability
 of applications.
 Their use is highly encouraged.
 Without them, end users may be forced to perform the same operation repetitivel
y to effect a business change in their model.
\end_layout

\begin_layout Section
Metadata
\end_layout

\begin_layout Subsection
Overriding Plural Name
\end_layout

\begin_layout Standard
JMatter applications are all about managing information.
 Information stored in objects and presented in the user interface as objects.
 Every model object of course has a distinct name (or label) and icon, and
 a distinct set of fields and commands.
 The user interface displays a classbar, which in a sense is a starting
 point for performing various operations, listing information of a given
 type, searching for information, creating a new instance, etc..
\end_layout

\begin_layout Standard
The classbar displays the various types in iconized form: with a caption
 and an icon.
 Each type's caption is derived from its class name.
 It's actually the plural form of the class name.
 For a 
\emph on
Boat
\emph default
, the plural form is simply 
\emph on
Boats.

\emph default
 For a 
\emph on
Person
\emph default
 object you might wish the caption to say 
\emph on
People
\emph default
.
\end_layout

\begin_layout Standard
To override the default behaviour for deriving the plural for a type, define
 a static method named 
\emph on
pluralName
\emph default
.
\end_layout

\begin_layout Description
Example:
\end_layout

\begin_layout LyX-Code
public static String pluralName() { return "People"; }
\end_layout

\begin_layout Subsection
Color Coding
\end_layout

\begin_layout Standard
Types may optionally be color-coded.
 List views' and instance views' titles are painted using a gradient background
 color.
 By defining this field, for example:
\end_layout

\begin_layout LyX-Code
public static Color colorCode = new Color(0x4169aa);
\end_layout

\begin_layout Standard
The framework will use the specified color as the starting color for the
 gradient.
 Additionally, list entries are painted such that row background colors
 alternate from white to another color.
 The type's color code, if specified, is used for that other color.
 Both these styling mechanisms make it easier to distinguish types in the
 user interface.
\end_layout

\begin_layout Standard
Color coding is generally a very effective tool for improving a user interface.
\end_layout

\begin_layout Subsection
Icons
\begin_inset LatexCommand label
name "sub:Icons"

\end_inset


\end_layout

\begin_layout Standard
You can assign an icon to each type.
 Rather than edit a configuration file, the name of the icon is derived
 from the type name.
 JMatter supports .png, .gif, and .jpg formats.
 Two icons sizes must be supplied: a 16x16 pixel icon (used in listings),
 and a larger 32x32 pixel icon.
 The files must be placed in the 
\emph on
resources/images
\emph default
 folder of your project.
 Your project's build file automaticaly copies these resources to the classpath
\emph on
 
\emph default
at 
\emph on
images/<imgresourcename>
\emph default
.
\end_layout

\begin_layout Standard
For the 
\emph on
User
\emph default
 class, the files should be named 
\emph on
User16.png
\emph default
 and 
\emph on
User32.png
\emph default
 respectively (the file suffix may vary of course).
\end_layout

\begin_layout Standard
List views of a uniform type are also decorated with an icon.
 You can distinguish icons used for lists of a given type from icons used
 for individual instances: drop in 
\emph on
Users16.png
\emph default
 and 
\emph on
Users32.png
\emph default
 into the 
\emph on
images
\emph default
 folder.
 Note how the file name uses the pluralized form of the type.
\end_layout

\begin_layout Standard
JMatter also leverages and honors the type's inheritance hierarchy.
 For example, if you define a specific subclass of 
\emph on
User.java
\emph default
, say 
\emph on
UberUser.java
\emph default
, without providing a set of icons for the subtype, JMatter will fall back
 the super type's icon.
\end_layout

\begin_layout Standard
For types that are stateful, you can also distinguish between instances
 of different states by icon.
 For example, the JMatter framework provides a 
\emph on
UserLocked32.png
\emph default
.
 If for some reason a user is locked, an administrator viewing a list of
 users can easily spot the locked user.
 The IssueManager demo application also leverages this feature (see chapter
 
\begin_inset LatexCommand ref
reference "cha:Issue-Manager"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Per-Instance Icons
\end_layout

\begin_layout Standard
There are situations where one of the fields of a model object contains
 a picture representing the instance in question.
 Here are examples:
\end_layout

\begin_layout Enumerate
An album's cover
\end_layout

\begin_layout Enumerate
A person's photo
\end_layout

\begin_layout Enumerate
A photo of a car part
\end_layout

\begin_layout Standard
So far, all instances of a given type use the same icon.
 Why not use a different icon per instance in such situations?
\end_layout

\begin_layout Standard
The methods 
\emph on
iconLg() and iconSm()
\emph default
 which are instance methods on model objects, govern what icon is to be
 used for an instance.
 Simply override the implementations in your classes.
 JMatter provides a utility class: 
\emph on
PhotoIconAssistant,
\emph default
 that takes the work out of properly scaling the photo to the right size
 for an icon, on your behalf.
 Here's an example of how this is done:
\end_layout

\begin_layout LyX-Code
public class Speaker extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  public ImgEO getPhoto() { ...
 }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  private transient PhotoIconAssistant assistant = 
\end_layout

\begin_layout LyX-Code
                        new PhotoIconAssistant(this, photo);
\end_layout

\begin_layout LyX-Code
  public Icon iconLg() { return assistant.iconLg(); }
\end_layout

\begin_layout LyX-Code
  public Icon iconSm() { return assistant.iconSm(); }
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Field Order
\end_layout

\begin_layout Standard
To control the order in which a type's fields are laid out on a form, use
 the 
\emph on
fieldOrder
\emph default
 static member.
\end_layout

\begin_layout Description
Example:
\end_layout

\begin_layout LyX-Code
public static String[] fieldOrder = {"name", "contact"};
\end_layout

\begin_layout Standard
Whatever field names you don't reference in 
\emph on
fieldOrder
\emph default
 will still appear on the form, after the listed ones, in no guaranteed
 order.
\end_layout

\begin_layout Standard
This piece of metadata underscores an important aspect of the framework
 which you must understand: the notion that fields and commands can be reference
d by name, as a string.
 What are the rules that govern the derivation of a field's name?
\end_layout

\begin_layout Standard
Field names are derived from their accessor method name.
 Here are a couple of simple examples:
\end_layout

\begin_layout LyX-Code
getName() -> "name"
\end_layout

\begin_layout LyX-Code
getFirstName() -> "firstName"
\end_layout

\begin_layout Standard
Fields also have 
\emph on
natural names
\emph default
, presented as field captions in the user interface.
 The natural name for the 
\emph on
firstName
\emph default
 field is 
\emph on
First Name
\emph default
.
\end_layout

\begin_layout Subsection
Command Order
\end_layout

\begin_layout Standard
In a manner analogous to the way fields are ordered on a form, we can control
 the order in which a type's commands are displayed with the 
\emph on
commandOrder
\emph default
 static field.
\end_layout

\begin_layout Standard
The ContactMgr demo application's 
\emph on
PersonContact
\emph default
 type has two static methods 
\emph on
Report
\emph default
 and 
\emph on
NewPersonWizard
\emph default
.
 Their relative order can be specified as follows:
\end_layout

\begin_layout LyX-Code
public static String[] commandOrder = {"Report", "NewPersonWizard"};
\end_layout

\begin_layout Standard
What's interesting here is that these two commands are static methods: they're
 type commands.
 The 
\emph on
commandOrder
\emph default
 field controls both static commands and instance commands.
 Each list is mutually exclusive and so can be (and is) specified with a
 single commandOrder string array field.
\end_layout

\begin_layout Subsection
Flatten Into Parent
\end_layout

\begin_layout Standard
Types can have different types of member fields.
 Some are simple, atomic, fields such as a string, a number, a percentage
 perhaps.
 These fields are not entities.
 From a persistence perspective, they don't get their own tables.
 A type may also bear members which are not atomic, but nevertheless aggregates
 of their containing types.
 Say for example that I define a 
\emph on
Person
\emph default
 type with the field 
\emph on
name
\emph default
 of type is 
\emph on
Name.

\emph default
 The type 
\emph on
Name
\emph default
 in turn has two fields: 
\emph on
first
\emph default
, and 
\emph on
last
\emph default
, both of which are atomic fields.
 
\emph on
Person.name
\emph default
 on the other hand is not atomic.
 The hierarchical relationship is sometimes important and useful in many
 situations.
\end_layout

\begin_layout Standard
By default JMatter maintains a one-to-one correspondence from model to view,
 and does not hide this relationship.
 The view widget used by JMatter's Swing-based view mechanism can expand
 or collapse to show the 
\emph on
name
\emph default
 field's children.
 An instance is shown in expanded mode below.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/person_name.png
	lyxscale 30
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Hierarchical Display of Aggregates
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sometimes it's more practical to display all descendant fields as a single
 flattened form, rather than require users to expand and collapse sub-nodes
 in order to perform data entry.
 That's what the 
\emph on
flattenIntoParent
\emph default
 metadata bit is for.
 In our example, to communicate to the framework that we wish to flatten
 the 
\emph on
name
\emph default
 field's child fields (
\emph on
first
\emph default
 and 
\emph on
last
\emph default
) into its parent form, we would do this:
\end_layout

\begin_layout LyX-Code
public static String[] flattenIntoParent = {"name"};
\end_layout

\begin_layout Subsection
Tab Views
\end_layout

\begin_layout Standard
Another feature related to controlling an aspect of how information is displayed
 to users is the 
\emph on
tabViews
\emph default
 metabit.
 You use it in a manner similar to many other pieces of metadata: by specifying
 a list of member fields:
\end_layout

\begin_layout LyX-Code
public static String[] tabViews = {"contact"};
\end_layout

\begin_layout Standard
The above example may be used, say, in a 
\emph on
Person
\emph default
 object to specify that the person's contact information (an aggregate field)
 should be displayed in a separate tab.
\end_layout

\begin_layout Standard
In the Swing-based user interface, the keyboard shortcut 
\emph on
Alt-<index>
\emph default
 can be used to switch the focus to the tab at index 
\emph on
<index>
\emph default
.
 That is, in a view with three tabs, the shortcuts 
\emph on
Alt-1
\emph default
, 
\emph on
Alt-2
\emph default
, and 
\emph on
Alt-3
\emph default
 can be used to toggle tab focus.
\end_layout

\begin_layout Subsection
Default Search Path
\begin_inset LatexCommand label
name "sub:dflt-searchpath"

\end_inset


\end_layout

\begin_layout Standard
This piece of metadata is useful to define one field that is most commonly
 used to search for instances of a given type.
 It may be 
\emph on
name
\emph default
 for a Person object, or 
\emph on
title
\emph default
 for a Presentation object.
 Here is how to specify it:
\end_layout

\begin_layout LyX-Code
public static String defaultSearchPath = "name";
\end_layout

\begin_layout Standard
The value is specified as a string but may actually be a field path, such
 as 
\emph on
name.first
\emph default
.
\end_layout

\begin_layout Standard
This value in turn is used in the user interface to assist with quick searches
 for performing associations or defaulting the search field when performing
 a search operation.
 It's quite useful.
 At the moment, this feature is supported only for text-based fields where
 the inequality defaults to 
\emph on
TextStarts
\emph default
 (i.e.
 that we're looking for instances whose default search field value starts
 with the value entered by the user).
\end_layout

\begin_layout Subsection
Unique Fields
\end_layout

\begin_layout Standard
JMatter automatically takes care to define a surrogate primary key for your
 model classes.
 Often there may exist additional fields, natural keys, that must remain
 unique.
 Optionally defining a static field 
\begin_inset Quotes eld
\end_inset

identities
\begin_inset Quotes erd
\end_inset

 will ensure that JMatter constructs the database schema properly (marking
 the field as unique in the database, which will also create an index on
 the table).
 In the user interface, such fields cannot be revised after an object has
 been created for the first time.
\end_layout

\begin_layout Description
Example:
\end_layout

\begin_layout LyX-Code
public static String[] identities = {"ssn"};
\end_layout

\begin_layout Subsection
Read-only Fields
\end_layout

\begin_layout Standard
Fields can be marked as 
\begin_inset Quotes eld
\end_inset

read only
\begin_inset Quotes erd
\end_inset

 by providing an optional 
\begin_inset Quotes eld
\end_inset

readOnly
\begin_inset Quotes erd
\end_inset

 static field (in the same manner fieldOrder is specified).
 This is useful when working with derived (or calculated) fields, which
 we discuss next.
\end_layout

\begin_layout Description
Example:
\end_layout

\begin_layout LyX-Code
public static String[] readOnly = {"created"};
\end_layout

\begin_layout Subsection
Calculated Fields
\end_layout

\begin_layout Standard
We sometimes use fields whose values are derived from other information.
 The information does not need to be persisted (made part of the database
 schema) and the information can simply be derived when the object is restored
 from the database.
\end_layout

\begin_layout Standard
Define such fields in the usual way.
 JMatter provides a way to mark the field as 
\begin_inset Quotes eld
\end_inset

not persisted
\begin_inset Quotes erd
\end_inset

, and a way to hook into the object's life cycle in order to update the
 field value, as illustrated in the following example.
\end_layout

\begin_layout Description
Example:
\end_layout

\begin_layout LyX-Code
private final USDollar _total = new USDollar();
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Fld(persist = false)
\end_layout

\begin_layout LyX-Code
public USDollar getTotal() { return _total; }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public void onLoad()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   super.onLoad();
\end_layout

\begin_layout LyX-Code
   calculate();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
private void calculate()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   ChargeCalculator calc = new ChargeCalculator(_trip, _settings);
\end_layout

\begin_layout LyX-Code
   _charges = calc.getCharges();
\end_layout

\begin_layout LyX-Code
   _total.setValue(calc.getTotal());
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Since derived fields need to be recalculated as a function of their inputs,
 it's also useful to attach change listeners on the input values.
 Here's an example:
\end_layout

\begin_layout LyX-Code
_settings.addChangeListener(new ChangeListener()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public void stateChanged(ChangeEvent e)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      _tracer.info("Settings changed, recalculating..");
\end_layout

\begin_layout LyX-Code
      calculate();
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
});
\end_layout

\begin_layout Standard
In this case the variable 
\emph on
_settings
\emph default
 is a composite member of the enclosing class.
\end_layout

\begin_layout Section
Per-Field Metadata
\end_layout

\begin_layout Subsection
@Fld Annotation
\end_layout

\begin_layout Standard
We can augment a field's getter method with the 
\emph on
@Fld
\emph default
 annotation.
 Here is a list of the parameters this annotation accepts, along with a
 description (all of these parameters are optional).
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features>
<column alignment="left" valignment="top" leftline="true" width="1in">
<column alignment="left" valignment="top" leftline="true" width="0.75in">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="3.25in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Parameter Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
What keyboard mnemonic to attach to the field in question.
 Useful for form entry, to directly set the focus on a specific field
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
label
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
A way to override the caption used to display a field in a form
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The field's description.
 Used as the contents of a tooltip on the field.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
colname
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
A means to override the name of the database column corresponding to this
 field.
 By default, the column name is automatically derived from the field name.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
colsize
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Controls the size of the field's underlying database column.
 By default, many string-type fields are set as varchar(255).
 This attribute provides a means to control the column size at a finer level.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
displaysize
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Controls the size of the corresponding text field used for doing data entry
 on the field.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
format
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Applies only to 
\emph on
TimeEO
\emph default
 and 
\emph on
DateEO
\emph default
 type fields.
 Accepts a 
\emph on
SimpleDateFormat
\emph default
 string to control the format of times and dates for both parsing and rendering.
 e.g.
 
\emph on
@Fld(format='m:ss')
\emph default
 might be useful on a TimeEO field for displaying song durations.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
persist
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Whether the field should be persisted at all (see the discussion on Calculated
 Fields)
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
hidden
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Use to hide certain fields from the user interface
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Although the framework provides a means for overriding the label for a field,
 we generally discourage this practice.
 We believe there is great value in maintaining a correspondence between
 field labels in the user interface and their corresponding field names
 in our object models.
\end_layout

\begin_layout Standard
If you wish to revise the date and time format throughout the application
 (i.e.
 not for a specific field), you can specify the format in the 
\emph on
model-metadata.properties
\emph default
 file (see subsection 
\begin_inset LatexCommand ref
reference "sub:model-metadata.properties"

\end_inset

).
\end_layout

\begin_layout Section
Per-Command Metadata
\end_layout

\begin_layout Standard
Commands must be marked with the 
\emph on
@Cmd
\emph default
 in order to be exposed to the user interface.
 There's nothing special about these methods and they can be invoked programmati
cally as well.
 When these commands are invoked from the user interface, JMatter makes
 sure to call the method off the 
\emph on
event dispatch thread
\emph default
.
\end_layout

\begin_layout Standard
If a command returns a 
\emph on
ComplexEObject
\emph default
, its view is drawn and displayed back on the event dispatch thread.
 The framework also makes sure to display a waiting cursor while the operation
 is invoked.
\end_layout

\begin_layout Subsection
@Cmd Metatada
\end_layout

\begin_layout Standard
Here is a summary of the optional parameters that the 
\emph on
@Cmd
\emph default
 annotation supports:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features>
<column alignment="left" valignment="top" leftline="true" width="1in">
<column alignment="left" valignment="top" leftline="true" width="0.75in">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="3.25in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Parameter Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
What keyboard mnemonic to use to invoke the command
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
label
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Use to override command's caption in the user interface
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Used as a tooltip to the command's corresponding view (usually a button)
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
sensitive
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Specify whether this is a sensitive command (e.g.
 
\emph on
Delete
\emph default
) where it would be beneficial for the ui to provide a mechanism to prevent
 against inadvertent invocation of the command.
 This is done in the Swing view mechanism by disabling the command's button.
 A small lock on the button can be clicked on to unlock (enable) the action.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
shortcut
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Applies only to type commands (commands marked static).
 Specify a keyboard shortcut (an accelerator).
 Example: "control Z"
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
batchable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Whether the command can be invoked in list context (composed across a number
 of instances)
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
iconref
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Decorate the command view (button or menu item) with an icon.
 For example, the 
\emph on
Edit
\emph default
 command is defined with 
\emph on
iconref="pencil"
\emph default
; make sure to place a copy of 
\emph on
pencil32.png
\emph default
 and 
\emph on
pencil16.png
\emph default
 in the image resources folder.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note: although the framework provides ways of overriding field and command
 labels, we highly discourage this practice.
 Having a one-to-one correspondence between the action's label and its correspon
ding method name significantly improves the maintainability of your application.
\end_layout

\begin_layout Subsection
@Arg Metadata
\end_layout

\begin_layout Standard
In addition, method arguments can be optionally marked with the 
\emph on
@Arg
\emph default
 annotation.
 This annotation accepts a single value, which is used as the caption on
 the form drawn to accept input to the method, as this example illustrates:
\end_layout

\begin_layout LyX-Code
@Cmd(mnemonic='p')
\end_layout

\begin_layout LyX-Code
public String ChangePassword(CommandInfo cmdInfo,
\end_layout

\begin_layout LyX-Code
                              @Arg("New Password") Password password);
\end_layout

\begin_layout Subsection
The model-metadata.properties file
\begin_inset LatexCommand label
name "sub:model-metadata.properties"

\end_inset


\end_layout

\begin_layout Standard
By default all child projects have a file that can be customized to provide
 model metadata: 
\emph on
resources/model-metadata.properties
\emph default
.
 Here are the default contents of this file:
\end_layout

\begin_layout LyX-Code
User.role.required=true
\end_layout

\begin_layout LyX-Code
User.role.default=from Role r where r.name='Default'
\end_layout

\begin_layout LyX-Code
CompositeQuery.name.required=true
\end_layout

\begin_layout LyX-Code
# e.g.
\end_layout

\begin_layout LyX-Code
#Speaker.name.required=true
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
# date and time format override (optional)
\end_layout

\begin_layout LyX-Code
#DateEO.format=dd.MM.yyyy
\end_layout

\begin_layout LyX-Code
#TimeEO.format=HH:mm:ss
\end_layout

\begin_layout Standard
Although this file is discussed in the next chapter from the perspetive
 of validation, not all aspects of this file pertain to validation.
\end_layout

\begin_layout Standard
First, we see that we can use a sort of field path notation to reference
 a field, such as 
\emph on
User.role
\emph default
, or perhaps 
\emph on
Person.name.first
\emph default
.
\end_layout

\begin_layout Standard
We can mark fields as required by setting the field property value, appending
 the 
\emph on
.required
\emph default
 suffix, to 
\emph on
true
\emph default
.
 We can also specify a field's default value.
 Above we see that we can even specify the default value in terms of a hibernate
 (hql) query.
 We can also provide a hard-coded value, say 
\emph on
Person.salutation.default=Mr.
\end_layout

\begin_layout Standard
For choice-type fields, we can specify the code for the choice and if a
 database lookup is necessary, it will be performed (e.g.
 
\emph on
Address.state.default=TX
\emph default
)
\end_layout

\begin_layout Standard
Finally, we just recently inroduced the ability to specify the default date
 and time format, which previously was hard-coded to US norms.
 The format is specified using Java's 
\emph on
SimpleDateFormat
\emph default
 rules.
\end_layout

\begin_layout Section
Persistence Lifecycle and AppEvents
\end_layout

\begin_layout Standard
The base class 
\emph on
AbstractComplexEObject
\emph default
 implements the interface 
\emph on
PersistorListener
\emph default
:
\end_layout

\begin_layout LyX-Code
public interface PersistorListener
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  public void onLoad();
\end_layout

\begin_layout LyX-Code
  public void onBeforeCreate();
\end_layout

\begin_layout LyX-Code
  public void onCreate();
\end_layout

\begin_layout LyX-Code
  public void onBeforeSave();
\end_layout

\begin_layout LyX-Code
  public void onSave();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The persistence mechanism implementation calls these methods at the appropriate
 times: when an object is loaded from the persistence store, 
\emph on
onLoad()
\emph default
 will automatically be called, for example.
\end_layout

\begin_layout Standard
It is permissible to override these methods, but be sure to first call the
 superclass's implementation.
 That is, do not mask the superclass implementations:
\end_layout

\begin_layout LyX-Code
public class Car extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  public void onLoad()
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
    super.onLoad();
\end_layout

\begin_layout LyX-Code
    System.out.println("Loaded "+this);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ..
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This is useful for some things.
 For example, 
\emph on
onLoad()
\emph default
 is useful for recalculating a derived field.
 The framework itself uses 
\emph on
onBeforeCreate()
\emph default
 to set the value of the read-only field 
\emph on
createdOn:
\end_layout

\begin_layout LyX-Code
1   public void onBeforeCreate()
\end_layout

\begin_layout LyX-Code
2   {
\end_layout

\begin_layout LyX-Code
3      _createdOn.setValue(new Date());
\end_layout

\begin_layout LyX-Code
4      fireAppEventNotification(BEFORECREATE, this);
\end_layout

\begin_layout LyX-Code
5   }
\end_layout

\begin_layout Standard
This bring up another aspect of the framework that might be useful to know
 about: 
\emph on
AppEvent
\emph default
's.
\end_layout

\begin_layout Standard
The JMatter framework contains an implementation of the Observer pattern
 (aka publish/subscribe) that is used internally for communicating various
 events between various parts of the application.
 For example, the framework defines LOGIN and LOGOUT events.
 When a user logs in, this event is published and all interested listeners
 are notified.
 The framework's class 
\emph on
AppSession
\emph default
 is an 
\emph on
AppEventNotifier
\emph default
 in that it notifies listeners of login-related events.
\end_layout

\begin_layout Standard

\emph on
AbstractComplexEObject
\emph default
s do a similar thing.
 By virtue of being persistor listeners, they are notified of persistence
 lifecycle changes.
 These objects use the AppEvent mechanism to also notify any interested
 listeners of these events.
 That explains line 4 in the above code sample.
\end_layout

\begin_layout Standard
To the extent that you have objects in your application that need to be
 informed of such events, these objects may configure themselves as listeners
 on whatever model objects they're interested in.
\end_layout

\begin_layout Standard
In fact, we saw an example in the 
\emph on
IssueMgr
\emph default
 sample application where we wanted to delay transitioning to another state
 until after the object was created.
\end_layout

\begin_layout Chapter
Validation
\begin_inset LatexCommand label
name "cha:Validation"

\end_inset


\end_layout

\begin_layout Standard
There are a number of facets to validation.
 
\end_layout

\begin_layout Standard
Let's begin by describing one aspect of the GUI.
 In the user interface, when an object is displayed, it can be edited and
 saved (updated).
 The user interface code that lays out the form conveniently inserts a number
 of panels called validation panels.
 These panels are normally empty and thus not apparent in the user interface.
 
\end_layout

\begin_layout Standard
For an object with three atomic fields, say a Speaker with a name (
\emph on
StringEO
\emph default
), a title (
\emph on
StringEO
\emph default
), and a biography (
\emph on
TextEO
\emph default
), four validation panels will be setup: one for each field, and one for
 the instance.
\end_layout

\begin_layout Standard
Each atomic type asserts its own validation requirements.
 Let's take a look at 
\emph on
USZipCode
\emph default
 for a moment:
\end_layout

\begin_layout LyX-Code
private static String omit = "- ";
\end_layout

\begin_layout LyX-Code
private static String valid = "0123456789";
\end_layout

\begin_layout LyX-Code
public int validate()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  String value = SimpleParser.parseValue(omit, valid, _value);
\end_layout

\begin_layout LyX-Code
  if (value == null || value.length() != 5 && value.length() != 9)
\end_layout

\begin_layout LyX-Code
    return invalid();
\end_layout

\begin_layout LyX-Code
  return 0;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
private int invalid()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  fireValidationException("Invalid zip code: "+_value);
\end_layout

\begin_layout LyX-Code
  return 1;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Here we see that 
\emph on
USZipCode
\emph default
 implements the 
\emph on
validate()
\emph default
 method, which the framework will invoke at the proper time.
 The return value, an 
\emph on
int
\emph default
, specifies the number of "errors" encountered.
 So a return value of 
\emph on
0
\emph default
 implies that validation passed.
\end_layout

\begin_layout Standard
There's a publish/subscribe pattern here, where the model object does not
 have a reference to its corresponding view (or editor) object.
 Yet, somehow the UI must display the validation error message.
 So the model object publishes the message *Invalid zip code...* when a validation
 error is encountered.
 The validation panel that corresponds to a field of this type in the user
 interface is a listener, and receives the messages, and properly displays
 the error:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/zipcode_validation.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:Zip-Code-Validation"

\end_inset

Zip Code Validation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The way you should view this form is that each field has its own validation
 panel embedded in the form, just above it.
 Most of the time these panels are dormant.
 When a validation message is published, it will appear in the appropriate
 place.
 Each panel listens to the value of its corresponding field.
\end_layout

\begin_layout Standard
The method 
\emph on
validate()
\emph default
 will be called on atomic objects when a user tabs out of the editor (when
 the field loses focus) and again when the user attempts to save the object.
 
\end_layout

\begin_layout Standard
So validation on atomic types such as such as 
\emph on
USZipCode
\emph default
, 
\emph on
SSN
\emph default
, and 
\emph on
USPhone
\emph default
 is implemented in this way.
 
\end_layout

\begin_layout Standard
Some validation logic is really more an artifact of how the atomic type's
 editor chose to allow you to enter the information, and so is implemented
 directly on the editor.
 Let's take a look at 
\emph on
PasswordEditor
\emph default
's 
\emph on
bind()
\emph default
 method, which is called by the framework to bind the value entered in the
 editor back to the model object:
\end_layout

\begin_layout LyX-Code
public int bind(AtomicEObject value)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  Password eo = (Password) value;
\end_layout

\begin_layout LyX-Code
  String pwd1 = new String(_pf1.getPassword());
\end_layout

\begin_layout LyX-Code
  String pwd2 = new String(_pf2.getPassword());
\end_layout

\begin_layout LyX-Code
  if (pwd1.length() < Password.MINLENGTH)
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
    eo.fireValidationException("Password must be at least "
\end_layout

\begin_layout LyX-Code
                   + Password.MINLENGTH+" characters long");
\end_layout

\begin_layout LyX-Code
    return 1;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  if (! pwd1.equals(pwd2) )
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
    eo.fireValidationException("Password and repeated password do not match.");
\end_layout

\begin_layout LyX-Code
    return 1;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  eo.parseValue(pwd1);
\end_layout

\begin_layout LyX-Code
  return 0;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This editor displays two password fields.
 The entered value must match each time.
 Also there's a check to ensure that the specified password meets certain
 criteria, such as a minimum length, or exceeding a certain minimum password
 strength, based on a specific algorithm.
 Again, we see here how the editor, through its reference to the model object,
 fire a validation signal, causing the proper validation error message to
 display.
 
\end_layout

\begin_layout Standard
In addition, baked into the framework is a simple mechanism for marking
 fields as required.
 The framework will automatically check that required fields left empty
 will veto the ability to save an object, and will also display a proper
 error message.
 
\end_layout

\begin_layout Standard
The way to mark required fields in JMatter is to specify them in the properties
 file 
\emph on
model-metadata.properties
\emph default
.
 Here's a sample file, taken from an application having to do with aircraft
 that I recently implemented:
\end_layout

\begin_layout LyX-Code
Airport.airportID.required=true
\end_layout

\begin_layout LyX-Code
Airport.name.required=true
\end_layout

\begin_layout LyX-Code
Airport.lat.required=true
\end_layout

\begin_layout LyX-Code
Airport.lon.required=true
\end_layout

\begin_layout LyX-Code
Airport.city.required=true
\end_layout

\begin_layout LyX-Code
Airport.stateCode.required=true
\end_layout

\begin_layout LyX-Code
Trip.aircraft.default=from Aircraft a where name='CitationJet'
\end_layout

\begin_layout LyX-Code
TripSegment.from.required=true
\end_layout

\begin_layout LyX-Code
TripSegment.to.required=true
\end_layout

\begin_layout Standard
Notice that this metadata file is also used to specify default values for
 fields.
 Note how a default value is specified for an association by actually looking
 it up in the database.
 The value specified is valid hql (hibernate query language).
 Let's get back to discussing validation.
\end_layout

\begin_layout Standard
Any type you define in your object model can define its own validation as
 well, again, simply by implementing 
\emph on
validate()
\emph default
.
 Here's how it was implemented for the type "TripSegment" in an application
 I developed: 
\end_layout

\begin_layout LyX-Code
public int validate()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  if (_from == null || _to == null)
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
    String msg = "From and To fields cannot be empty";
\end_layout

\begin_layout LyX-Code
    fireValidationException(msg);
\end_layout

\begin_layout LyX-Code
    return 1;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  if (_from.equals(_to))
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
    fireValidationException("From and To fields cannot be the same");
\end_layout

\begin_layout LyX-Code
    return 1;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  if (_trip != null && _trip.getAircraft() != null)
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
    Aircraft aircraft = _trip.getAircraft();
\end_layout

\begin_layout LyX-Code
    if (aircraft.hasRangeFor(_numPassengers.intValue()))
\end_layout

\begin_layout LyX-Code
    {
\end_layout

\begin_layout LyX-Code
      int range = aircraft.rangeFor(_numPassengers.intValue());
\end_layout

\begin_layout LyX-Code
      if (range < distance())
\end_layout

\begin_layout LyX-Code
      {
\end_layout

\begin_layout LyX-Code
        String msg = String.format("Segment distance exceeds aircraft " +
 
\end_layout

\begin_layout LyX-Code
             "range (%d) for specified number of passengers", range);
\end_layout

\begin_layout LyX-Code
        fireValidationException(msg);
\end_layout

\begin_layout LyX-Code
        return 1;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  return 0;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
So there's a simple business rule in this case that a trip segment's distance
 cannot exceed the specified aircraft's range for the specified number of
 passengers.
 
\end_layout

\begin_layout Standard
So here you have it, in a nutshell, an overview of validation in JMatter,
 how to implement it in your applications, and how things work under the
 hood.
\end_layout

\begin_layout Chapter
Authentication & Authorization
\begin_inset LatexCommand label
name "cha:Authentication-&-Authorization"

\end_inset


\end_layout

\begin_layout Standard
JMatter comes built-in with authentication and authorization services.
\end_layout

\begin_layout Standard
When launching a JMatter application for the first time, the framework will
 create two roles (administrative and default) and two corresponding users:
 admin (with admin privileges), and 'johndoe' with default privileges, as
 shown in the figure 38.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/users-and-roles.png
	lyxscale 50
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Standard
Initial Users and Roles
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The framework provides two model objects: 
\emph on
User.java
\emph default
 and 
\emph on
Role.java
\emph default
, that are constructed according to JMatter's own conventions for model
 objects.
 The icons used for these types follow the same convention: you will find
 in the path 
\emph on
jmatter/resources/images
\emph default
 the corresponding icons used by the framework.
 In the case of 
\emph on
User
\emph default
, you will find three variants: an icon for a single user, a plural version,
 and a state-specific icon for locked users (UserLocked32.png).
\end_layout

\begin_layout Standard
Users and Roles are modeled in a bidirectional one-to-many association.
 By default, when creating a new user, the user will be associated with
 the default role.
\end_layout

\begin_layout Standard
Passwords are hashed using the MD5 algorigthm, and it is this hash which
 is stored in the database.
\end_layout

\begin_layout Standard
Upon application launch, the application is in 
\emph on
logged out
\emph default
 state, and a login dialog is presented.
 Three invalid login attempts by default will cause the user account in
 question to lock, requiring an administrator to reset the user's password.
 Password resetting is implemented as a JMatter Command (
\emph on
@Cmd
\emph default
) and so is accessible directly from the user interface (assuming you have
 the proper permission).
\end_layout

\begin_layout Standard
Upon successful login, the user's classbar is fetched from database (upon
 initial login, the classbar is defined from the template file 
\emph on
class-list.xml
\emph default
) and presented in the user interface.
\end_layout

\begin_layout Standard
Again, assuming the proper permissions, one can create new users, new roles,
 assign users to a role, and go about performing whatever activities are
 necessary to manage authentication-related information.
\end_layout

\begin_layout Section
Autologin
\end_layout

\begin_layout Standard
In some situations, one might be interested in developing a application
 that does not care for or require authentication.
 For such cases, JMatter can be configured to automatically log in as a
 specific user upon launch, removing the need for users to manually authenticate.
\end_layout

\begin_layout Standard
To configure a JMatter application with autologin, edit the application's
 
\emph on
src/applicationContext.xml
\emph default
 as follows:
\end_layout

\begin_layout LyX-Code
   <bean id="app-session" class="com.u2d.app.AppSession">
\end_layout

\begin_layout LyX-Code
      <property name="app" ref="application" />
\end_layout

\begin_layout LyX-Code
      <property name="viewMechanism" ref="view-mechanism" />
\end_layout

\begin_layout LyX-Code

\emph on
      <property name="autologinas" value="admin" />
\end_layout

\begin_layout LyX-Code
   </bean>
\end_layout

\begin_layout Standard
The important line is the 
\emph on
autologinas
\emph default
 property, which directs JMatter to turn on autologin and to automatically
 log the user in as the user 
\emph on
admin
\emph default
, in this particular case.
\end_layout

\begin_layout Section
Authorization
\begin_inset LatexCommand label
name "sec:Authorization"

\end_inset


\end_layout

\begin_layout Standard
Authorization governs who can perform what actions.
 Authorization in JMatter is specified by role.
 JMatter comes complete with an authorization implementation, all driven
 from the user interface.
\end_layout

\begin_layout Standard
The starting point is an application where everything is permitted.
 Authorization is specified then by applying a series of restrictions from
 this initial state.
 When a user logs in, the set of restrictions corresponding to the user's
 role are fetched from the database and applied to the system.
 Upon logout, the restrictions are lifted, and reapplied on subsequent login,
 again according to the new logged in user's role's restrictions.
\end_layout

\begin_layout Standard
Restrictions can be applied to both commands and fields.
 Commands can be disabled, in which case, they disappear from the user interface
: from context menus, from the button panels on form views.
 Fields can be marked hidden or read-only, per role.
\end_layout

\begin_layout Standard
To specify the authorization policy, JMatter defines the command 
\emph on
Manage Restrictions,
\emph default
 defined on all types, as shown in figure 39.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/manage-restrictions.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Managing Restrictions
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Just like Form Views are dynamically rendered, based on the structure of
 model objects, so is this view.
 When a new role is created, a new column will appear in this view.
 When a new command or field is added, a new row will be added to the correspond
ing table.
\end_layout

\begin_layout Standard
Here we see that existing administrative commands are already marked restricted
 for the 'default' role.
 For example, the ability to create a new role, to edit or delete roles,
 is prohibited.
 Furthermore the ability to define restrictions on roles is likewise prohibited.
 Finally, the role type's 
\emph on
Open
\emph default
 command is prohibited as well, restricting access to inspection of the
 type's metadata from the user interface.
\end_layout

\begin_layout Section
List Filtering
\end_layout

\begin_layout Standard
Another component of authorization is the ability to filter data.
 For example, in the Issue Manager demo application, we may require that
 users can view only issues assigned to them.
\end_layout

\begin_layout Standard
The Hibernate O/R mapping system provides a way to filter data that JMatter
 now exploits.
\end_layout

\begin_layout Standard
The convention is to optionally define a static method on a given type to
 filter lists of the type in question.
 For example, we might define this method on 
\emph on
Issue
\emph default
:
\end_layout

\begin_layout LyX-Code
public static String typeFilter() { return "assignedTo_id = :currentUser";
 }
\end_layout

\begin_layout Standard
When specifying the filter, you have to be aware that hibernate's implementation
 of filters appears to be sql-based and not hql-based.
 So the filter is used in the construction of a sql query.
 Therefore we reference the type's assignedTo field by its primary key colum
 name.
\end_layout

\begin_layout Standard
JMatter will now produce the filter declarations directly into the generated
 hibernate mapping files.
 You should see something like this at the bottom of the generated Issue.hbm.xml
\end_layout

\begin_layout LyX-Code
  ..
\end_layout

\begin_layout LyX-Code
  <filter name="authFilter" condition="assignedTo_id = :currentUser"/>
\end_layout

\begin_layout LyX-Code
</class>
\end_layout

\begin_layout LyX-Code
<filter-def name="authFilter">
\end_layout

\begin_layout LyX-Code
  <filter-param name="currentUser" type="long"/>
\end_layout

\begin_layout LyX-Code
</filter-def>
\end_layout

\begin_layout Standard
Second, after logging in, JMatter will automatically enable this filter
 for the user's session (unless you log in as administrator), and bind the
 logged in user's primary key to the filter parameter (:currentUser).
\end_layout

\begin_layout Standard
As further use cases for data filtering surface, this implementation will
 be broadened to accommodate them.
\end_layout

\begin_layout Chapter
Search
\end_layout

\begin_layout Standard
Search is an indispensable part of business applications today.
 Database systems provide the ability to lookup information via its SQL
 interface.
 But software applications will almost never provide end users direct access
 to a database via SQL, and there are many good reasons for this.
\end_layout

\begin_layout Standard
Typically a fair amount of code is written by developers on top of SQL (or
 these days HQL or some other object-based query language) to expose search
 features in their applications.
\end_layout

\begin_layout Standard
JMatter integrates search capabilities directly into its user interfaces,
 in a deep and comprehensive fashion.
 The good news is that the entire implementation is independent of the domain
 in question, removing the need for developers to implement their own search
 layer.
\end_layout

\begin_layout Section
Filtering Listings
\end_layout

\begin_layout Standard
All list views in JMatter are decorated with a simple query panel.
 Through this query panel, users can dynamically view a custom-filtered
 set of items, that match a specific criterion: users with a specific last
 name, contacts in a specific city, talks on a given topic, sessions given
 on a specific date, etc..
\end_layout

\begin_layout Standard
Users have adhoc search capabilities on every type in their domain.
 This feature is quite sophisticated.
 JMatter provides a custom widget based on a tree model that comprises an
 acyclic tree of the sum of valid search paths for a type, from the entity's
 root to leaf fields, and can traverse even associations to other fields.
\end_layout

\begin_layout Standard
Furthermore, for every atomic type, JMatter provides a set of matching inequalit
ies and value editors.
\end_layout

\begin_layout Standard
So for example we can ask questions such as 
\begin_inset Quotes eld
\end_inset

return all contacts who live in a zip code that starts with a 7
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

find all talks given by speakers whose who live within such a matching zip
 code.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
The Find Command
\end_layout

\begin_layout Standard
The 
\emph on
Find
\emph default
 command, which is inherent on any type, allows the composing of multiple
 simple criteria in a conjunction.
 Disjunction type composite queries are not yet supported.
\end_layout

\begin_layout Section
Smart Lists
\end_layout

\begin_layout Standard
Smart lists denote the ability to save a query performed using the 
\emph on
Find
\emph default
 command to database.
 All JMatter applications include model objects provided by the framework
 itself.
 Examples include the entities 
\emph on
User
\emph default
, and 
\emph on
Role
\emph default
 to manage authorization.
 With respect to Search, the 
\emph on
Query
\emph default
 model object is also part of your application's domain.
 This means that end-users can create, read, update, delete, and execute
 queries to their heart's content.
 They can even use the built-in search capabilities of JMatter to query
 queries.
\end_layout

\begin_layout Standard
So for example, in the 
\emph on
MyTunes
\emph default
 sample application, we can create our own playlists based on various criteria
 and name them, in a manner analogous that users have become accustomed
 to with other popular players.
\end_layout

\begin_layout Section
Search in Associations
\end_layout

\begin_layout Standard
Another important feature in JMatter is the ability to search directly within
 the context of an association field, for the purpose of establishing a
 relation between two objects.
 Section 
\begin_inset LatexCommand vref
reference "sec:Associations-Made-Easy"

\end_inset

 provides a detailed example of its use.
\end_layout

\begin_layout Section
Polymorphic queries
\end_layout

\begin_layout Standard
When modeling an application using object oriented principles, we avail
 ourselves to various modeling techniques such as modeling with abstract
 classes and interfaces.
 We can have an association from one entity to another which is by nature
 polymorphic.
 We saw two such examples when covering the Sympster demo application:
\end_layout

\begin_layout Enumerate
A symposium's venue was modeled using a simple abstract base class with
 three subclasses (Hotel, Campus, and ConferenceCenter)
\end_layout

\begin_layout Enumerate
Sessions were modeled with a relationship to an Event, an interface, implemented
 by both Talk and BOF.
\end_layout

\begin_layout Standard
The nature of these relationships carries through to queries.
 We can request of our persistence repository for a listing of events, which
 will transparently fetch both Talks and BOFs.
 We can narrow a polymorphic listing by type.
 One possible query is asking for all events of a specific type.
 All queries are performed object-based.
 This support is possible because Hibernate is object-based.
 JMatter takes full advantage of this.
\end_layout

\begin_layout Section
Code Hints for Search
\end_layout

\begin_layout Standard
There is one specific class-level piece of metadata that developers typically
 specify to govern a default that is related to searching, as discussed
 in section 
\begin_inset LatexCommand ref
reference "sub:dflt-searchpath"

\end_inset

: 
\emph on
defaultSearchPath
\emph default
.
\end_layout

\begin_layout Standard
Here's an example:
\end_layout

\begin_layout LyX-Code
public static String defaultSearchPath = "name";
\end_layout

\begin_layout Standard
This piece of metadata is useful to define one field that is most commonly
 used to search for instances of a given type.
 It may be 
\emph on
name
\emph default
 for a Person object, or 
\emph on
title
\emph default
 for a Presentation object.
\end_layout

\begin_layout Standard
The value is specified as a string but may actually be a field path, such
 as 
\emph on
name.first
\emph default
.
\end_layout

\begin_layout Standard
This value in turn is used in the user interface to assist with quick searches
 for performing associations or defaulting the search field when performing
 a search operation.
 It's quite useful.
 At the moment, this feature is supported only for text-based fields where
 the inequality defaults to 
\emph on
TextStarts
\emph default
 (i.e.
 that we're looking for instances whose default search field value starts
 with the value entered by the user).
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Chapter
Wizards, CSV Export, and PDFs
\end_layout

\begin_layout Standard
Remember our zero-code contact manager? In this chapter we're going to actually
 add code to that application.
 Many desktop applications today provide these software assistants, or wizards,
 to help newbie users through a task.
\end_layout

\begin_layout Standard
For example, when we created a contact person in our contact manager, we
 did not resort to an assistant.
 We just right-clicked 
\emph on
New
\emph default
 on Person and typed away.
 This works just fine.
 But maybe we would also like to break the process of entering contact informati
on into these steps:
\end_layout

\begin_layout Enumerate
Enter person's name
\end_layout

\begin_layout Enumerate
Enter person's physical address
\end_layout

\begin_layout Enumerate
Enter remaining contact information (phone numbers, email address)
\end_layout

\begin_layout Enumerate
Finish
\end_layout

\begin_layout Standard
Having more than one way to do something can sometimes help.
 Each method can complement the other.
 Let's see what kind of support JMatter provides for adding assistants to
 our user interface.
\end_layout

\begin_layout Section
Subclassing Person
\end_layout

\begin_layout Standard
When we wrote this application, we used pre-written classes.
 One of them was 
\emph on
com.u2d.type.composite.Person
\emph default
.
 We want to enhance person with an additional behaviour: we want to add
 a command to launch our wizard.
 It should be a class command, not an instance command.
\end_layout

\begin_layout Standard
So we need to subclass 
\emph on
Person
\emph default
.
 Let's create a package 
\emph on
com.u2d.contactmgr
\emph default
.
 In it we're going to create a new class: 
\emph on
PersonContact
\emph default
 like this:
\end_layout

\begin_layout LyX-Code
package com.u2d.contactmgr;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import com.u2d.type.composite.Person;
\end_layout

\begin_layout LyX-Code
import com.u2d.wizard.details.Wizard;
\end_layout

\begin_layout LyX-Code
import com.u2d.element.CommandInfo;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public class PersonContact extends Person
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   @Cmd
\end_layout

\begin_layout LyX-Code
   public static Wizard NewPersonWizard(CommandInfo cmdInfo)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return new Wizard(new NewPersonWizard());
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Pretty simple.
 We're basically exposing a command that will return a 
\emph on
Wizard
\emph default
 object.
 JMatter knows what to do with these objects, how to display them, allow
 the end user to navigate through them, etc..
 All you need to do is provide the steps.
\end_layout

\begin_layout Section
Writing the Wizard
\end_layout

\begin_layout Standard
JMatter models a wizard as a container for a series of steps.
 JMatter defines several types of steps.
 There are basic (or atomic) steps, conditional steps, and composite steps.
 We need to write a class that is essentially a composite step: one that
 defines the set of steps that makes up our wizard.
\end_layout

\begin_layout Standard
Here is the first part of the implementation for our 
\emph on
NewPersonWizard
\emph default
 class:
\end_layout

\begin_layout LyX-Code
package com.u2d.contactmgr;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
import com.u2d.wizard.details.*;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.composite.*;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.ComplexType;
\end_layout

\begin_layout LyX-Code
import com.u2d.view.swing.FormView;
\end_layout

\begin_layout LyX-Code
import javax.swing.*;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
public class NewPersonWizard extends CompositeStep
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private Name _name;
\end_layout

\begin_layout LyX-Code
   private USAddress _address;
\end_layout

\begin_layout LyX-Code
   private Contact _contact;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public NewPersonWizard()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      super("New Person Wizard");
\end_layout

\begin_layout LyX-Code
      createObjects();
\end_layout

\begin_layout LyX-Code
      setupSteps();
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   private void createObjects()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      _name = (Name) ComplexType.forClass(Name.class).instance();
\end_layout

\begin_layout LyX-Code
      _address = (USAddress) ComplexType.forClass(USAddress.class).instance();
\end_layout

\begin_layout LyX-Code
      _contact = (Contact) ComplexType.forClass(Contact.class).instance();
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   private void setupSteps()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      NameStep nameStep = new NameStep();
\end_layout

\begin_layout LyX-Code
      AddressStep addrStep = new AddressStep();
\end_layout

\begin_layout LyX-Code
      ContactStep contactStep = new ContactStep();
\end_layout

\begin_layout LyX-Code
      addStep(nameStep);
\end_layout

\begin_layout LyX-Code
      addStep(addrStep);
\end_layout

\begin_layout LyX-Code
      addStep(contactStep);
\end_layout

\begin_layout LyX-Code
      addStep(new CommitWizardStep());
\end_layout

\begin_layout LyX-Code
      ready();
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Let's analyze this code.
 We defined a class that extends 
\emph on
CompositeStep
\emph default
.
 Recall that our wizard is essentially four steps: specify a name, an address,
 contact info, and finish.
 So we define variables that will hold each of these three pieces of information.
\end_layout

\begin_layout Standard
Next, in the constructor, we set the title for our wizard with the call
 to the super type's constructor.
 We proceed to instantiate our three objects and then to configure them.
 The convention for setting up the steps is pretty easy:
\end_layout

\begin_layout Enumerate
create each step
\end_layout

\begin_layout Enumerate
add the steps in the proper order
\end_layout

\begin_layout Enumerate
call the 
\emph on
ready()
\emph default
 method
\end_layout

\begin_layout Standard
Now all that's left to do is define three basic steps.
 I've decided to do this using inner classes, as follows:
\end_layout

\begin_layout LyX-Code
class NameStep extends BasicStep
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public String title() { return "Name Information"; }
\end_layout

\begin_layout LyX-Code
   public String description() { return "Enter Person's Name"; }
\end_layout

\begin_layout LyX-Code
   public JComponent getView()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return new FormView(_name, false, false);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
class AddressStep extends BasicStep
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public String title() { return "Address Information"; }
\end_layout

\begin_layout LyX-Code
   public String description() { return "Enter Person's Physical Address";
 }
\end_layout

\begin_layout LyX-Code
   public JComponent getView()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return new FormView(_address, false, false);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
class ContactStep extends BasicStep
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public String title() { return "Person's Contact Information"; }
\end_layout

\begin_layout LyX-Code
   public String description()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return "Please specify person's contact information";
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public JComponent getView()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return new FormView(_contact, false, false);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We see here that the implementation is trivial.
 We provide a title, description, and a view for each of our steps.
 Nothing to it!
\end_layout

\begin_layout Standard
It is worth noting that the 
\emph on
FormView
\emph default
 class is taken from JMatter's own Swing-based view mechanism.
 By reusing this class, we automate the chore of having to write the panels
 that make up our wizard's user interface.
 Not only do we automate the construction of each panel, but also the binding
 of the view to its model object, as well as model object validation.
 For example, entering a zip code with an invalid format in the 
\emph on
AddressStep
\emph default
 will automatically be flagged, giving the user a chance to revise and fix
 the data entry (see the screenshots that follow this section) before being
 able to proceed to the next step in the wizard.
\end_layout

\begin_layout Standard
In our last step, the commit step, we sew everything together and save our
 new contact person:
\end_layout

\begin_layout LyX-Code
class CommitWizardStep extends CommitStep
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public void commit()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      PersonContact pc = new PersonContact();
\end_layout

\begin_layout LyX-Code
      pc.getName().setValue(_name);
\end_layout

\begin_layout LyX-Code
      pc.getContact().setValue(_contact);
\end_layout

\begin_layout LyX-Code
      pc.getContact().getAddress().setValue(_address);
\end_layout

\begin_layout LyX-Code
      pc.save();
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public JComponent getView()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return new JLabel(description());
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public String title() { return "Final Step"; }
\end_layout

\begin_layout LyX-Code
   public String description()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return "We're almost done; Person record will be " +
\end_layout

\begin_layout LyX-Code
             "committed after clicking 'Next'";
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Besides providing the basic step information: title, description, and view,
 we also need to fill in the 
\emph on
commit()
\emph default
 method, which is quite straightforward:
\end_layout

\begin_layout Enumerate
we create a new PersonContact instance
\end_layout

\begin_layout Enumerate
we set the name, contact, and address values
\end_layout

\begin_layout Enumerate
finally, we persist our instance
\end_layout

\begin_layout Standard
JMatter does the rest! Let's take our app for a little spin.
\end_layout

\begin_layout Section
Running the Application
\end_layout

\begin_layout Standard
Let's run our app:
\end_layout

\begin_layout LyX-Code
$ ant run
\end_layout

\begin_layout Standard
The next five figures are screen shots for the various steps in our simple
 wizard.
 Note how the name, description, and view for each step are automatically
 placed in their respective places on the wizard's window.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/Wizard-Step0.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/Wizard-Step1.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/Wizard-Step2.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/Wizard-Step3.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/Wizard-Step4.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This coverage of wizards was meant to be an introduction to the topic.
 JMatter's wizard framework is complete from the point of view that one
 can produce wizards of any degree of complexity by combining basic steps,
 composite steps, and conditional steps in various ways.
\end_layout

\begin_layout Section
CSV Export
\end_layout

\begin_layout Standard
If we like, we can also export our contact list to a CSV file.
 This feature is built-in to all JMatter applications.
 Simply browse your contact listing and right-click 
\emph on
Export to CSV
\emph default
.
 You will be prompted for a location to save the file.
 Below is a screenshot of a small CSV export opened in the spreadsheet applicati
on 
\emph on
Gnumeric
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CSVExport.png
	lyxscale 40
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
CSV Export Viewed in Gnumeric
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that this feature could be improved.
 At the moment the CSV Export command simply exports the table model exposed
 by the listing.
 However, in this case, it would be nice if the address fields were flattened
 as properties for each contact.
 It'd be even nicer if there a CSV export wizard walked you through the
 process, allowing you to select which fields to export, which to skip,
 and in what order to serialize them out to file.
 We hope to extend this CSV export feature in a future version of JMatter.
\end_layout

\begin_layout Section
PDFs
\end_layout

\begin_layout Subsection
JFreeReport Integration
\end_layout

\begin_layout Standard
JFreeReport is an open source Java API for reporting; its home page is 
\begin_inset LatexCommand url
target "http://www.jfree.org/jfreereport/"

\end_inset

.
\end_layout

\begin_layout Standard
This API has been around for a number of years.
 It defines an xml vocabulary for laying out reports.
 It's somewhat difficult to describe in one or two sentences what JFreeReport
 is all about.
 Some of its characteristics are reminiscent of templating technologies
 where information from our applications can be merged with a the xml report
 specification to produce the final report.
 The report specification defines various 
\emph on
bands
\emph default
 such as report headers and footers, page headers and footers, and the actual
 report items themselves.
\end_layout

\begin_layout Standard
JFreeReport also provides means for you to automatically display a 
\emph on
print preview
\emph default
 of your report from inside your Swing application.
 From that dialog, one also has the ability to produce the report in a number
 of formats, including PDF, print, and Microsoft Excel.
\end_layout

\begin_layout Standard
The JMatter framework attempts to make the job of producing reports with
 JFreeReport easier.
 The JFreeReport libraries are already bundled with JMatter.
 Producing a PDF report from JMatter via JFreeReport is a relatively easy
 task.
 The task of writing the report specification using JFreeReport's XML specificat
ion however remains unchanged.
\end_layout

\begin_layout Standard
The authors of this framework have used JFreeReport to produce completed
 medical forms, merging information in a medical system with a template
 defining the layout of the form[s] to be completed.
\end_layout

\begin_layout Subsubsection
The basics
\end_layout

\begin_layout Standard
JFreeReport provides two ways in which data can be passed in to its xml
 report specification:
\end_layout

\begin_layout Enumerate
the implementation of a 
\emph on
TableModel
\emph default
 interface, which provides the majority of the tabular data to be included
 in a report, and
\end_layout

\begin_layout Enumerate
a simple properties file with key-value pairs for passing any kind of informatio
n to include in the header or footer sections of the report
\end_layout

\begin_layout Standard
JMatter defines the following interface:
\end_layout

\begin_layout LyX-Code
public interface Reportable
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public String reportName();
\end_layout

\begin_layout LyX-Code
   public Properties properties();
\end_layout

\begin_layout LyX-Code
   public TableModel tableModel();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The latter two methods provide the data to bind to the xml report specification.
 The first method provides the path to the report's xml specification.
 JMatter basically follows the convention that these xml files be placed
 alongside source code.
 The xml files are then loaded into a Java application as a resource from
 the classpath.
\end_layout

\begin_layout Standard
If in a command method, you return a Reportable instance, JMatter will take
 it from there and use JFreeReport to produce a corresponding PDF file and
 open it using a PDF reader application.
\end_layout

\begin_layout Subsubsection
A Simple Example
\end_layout

\begin_layout Standard
Let's build a very simple report for our ContactManager application.
 The point of this section is not to provide documentation for JFreeReport.
 Rather, it's only to illustrate how the integration works.
\end_layout

\begin_layout Standard
So here's a simple mechanism to expose the production of a report that will
 include all the contacts we have in our system:
\end_layout

\begin_layout LyX-Code
@Cmd
\end_layout

\begin_layout LyX-Code
public static Reportable Report(CommandInfo cmdInfo)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   return new Reportable()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      public String reportName()
\end_layout

\begin_layout LyX-Code
      {
\end_layout

\begin_layout LyX-Code
         return "com/u2d/contactmgr/Basic.xml";
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      public Properties properties()
\end_layout

\begin_layout LyX-Code
      {
\end_layout

\begin_layout LyX-Code
         return new Properties();
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      public TableModel tableModel()
\end_layout

\begin_layout LyX-Code
      {
\end_layout

\begin_layout LyX-Code
         return ComplexType.forClass(PersonContact.class).
\end_layout

\begin_layout LyX-Code
                                          list().tableModel();
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
   };
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
So basically what I'm doing here is exposing a static command using the
 JMatter conventions.
 This command returns a 
\emph on
Reportable
\emph default
 implementation that in this case passes data only via a tablemodel.
 I'm basically returning the default table model that JMatter exposes on
 lists of types.
\end_layout

\begin_layout Standard
Here is a very basic sample JFreeReport XML specification:
\end_layout

\begin_layout LyX-Code
<?xml version="1.0" encoding="iso-8859-1"?>
\end_layout

\begin_layout LyX-Code
<!DOCTYPE report PUBLIC
\end_layout

\begin_layout LyX-Code
      "-//JFreeReport//DTD report definition//EN//simple/version 0.8.5"
\end_layout

\begin_layout LyX-Code
      "http://jfreereport.sourceforge.net/report-085.dtd">
\end_layout

\begin_layout LyX-Code
<report name="Basic Persons Listing" 
\end_layout

\begin_layout LyX-Code
   orientation="portrait" pageformat="LETTER" 
\end_layout

\begin_layout LyX-Code
   topmargin="36" bottommargin="36" 
\end_layout

\begin_layout LyX-Code
   leftmargin="36" rightmargin="36">
\end_layout

\begin_layout LyX-Code
  <configuration>
\end_layout

\begin_layout LyX-Code
     <property name="org.jfree.report.modules.gui.base.PreferredWidth">640</property>
\end_layout

\begin_layout LyX-Code
     <property name="org.jfree.report.modules.gui.base.PreferredHeight">480</property>
\end_layout

\begin_layout LyX-Code
  </configuration>
\end_layout

\begin_layout LyX-Code
  <pageheader height="200" fontname="sansserif" fontsize="10" fsbold="true">
\end_layout

\begin_layout LyX-Code
    <label x="0" y="0" 
\end_layout

\begin_layout LyX-Code
           width="100%" height="12" 
\end_layout

\begin_layout LyX-Code
           fonsize="12" fsbold="true"
\end_layout

\begin_layout LyX-Code
           alignment="center"><![CDATA[Person Contacts Listing]]></label>
\end_layout

\begin_layout LyX-Code
    <line x1="170" y1="50" x2="334" y2="50" weight="0.75" />
\end_layout

\begin_layout LyX-Code
  </pageheader>
\end_layout

\begin_layout LyX-Code
  <items height="18"
\end_layout

\begin_layout LyX-Code
         fontname="sansserif" fontstyle="plain" fontsize="10" fsbold="false"
\end_layout

\begin_layout LyX-Code
         vertical-alignment="middle">
\end_layout

\begin_layout LyX-Code
    <string-field x="10" y="0" width="250" height="12" alignment="left"
 
\end_layout

\begin_layout LyX-Code
       fieldname="Person Contacts" />
\end_layout

\begin_layout LyX-Code
    <string-field x="270" y="0" width="100" height="12" alignment="left"
 
\end_layout

\begin_layout LyX-Code
       fieldname="Name" />
\end_layout

\begin_layout LyX-Code
    <string-field x="380" y="0" width="250" height="12" alignment="left"
 
\end_layout

\begin_layout LyX-Code
       fieldname="Contact" />
\end_layout

\begin_layout LyX-Code
  </items>
\end_layout

\begin_layout LyX-Code
</report>
\end_layout

\begin_layout Standard
The essential aspects of this specification are located in the items band,
 where we see that various string-based fields are specified.
 JFreeReport allows you to insert images, other data types, to control the
 font size, style, and placement of the information.
 JFreeReport also provides a number of built-in functions that can be invoked
 to calculate sums, for example.
 Developers can also write and plug in their own custom functions.
\end_layout

\begin_layout Standard
The result of invoking this command from the JMatter user interface is the
 production of the report PDF, as shown below.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/JFree-1.png
	lyxscale 50
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
PDF produced with JFreeReport
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
JasperReports
\end_layout

\begin_layout Standard
JasperReports is yet another, even more popular, open, reporting solution
 for Java.
 It is a well-supported project.
 One appealing feature of this project is its companion project 
\emph on
iReports
\emph default
, a mature graphical report designer, which does away with the tedium of
 writing JasperReport's analog to the the xml report specification we just
 saw in the last section.
\end_layout

\begin_layout Standard
Another attractive feature of JasperReports is its support and integration
 with Hibernate.
 This makes JasperReports a perfect mate for JMatter.
 We recently extended the 
\emph on
Sympster
\emph default
 demo application with an example use of JasperReports for producing a symposium
 schedule.
 Simply run Sympster, create a symposium and a number of associated Sessions,
 and then invoke the Symposium command 
\emph on
Report Schedule
\emph default
.
\end_layout

\begin_layout Standard
JMatter now bundled the JasperReport libraries with its distribution for
 your convenience.
 We also highly recommend you support the JasperReports project by buying
 a copy of their documentation 
\begin_inset LatexCommand cite
key "Jasper"

\end_inset

 in print.
\end_layout

\begin_layout Subsection
Launching PDFs and other Files
\end_layout

\begin_layout Standard
The solution that appears to work well for displaying PDFs is to launch
 the desktop's default PDF viewer, rather than attempt to embed a PDF viewer
 component within one's application.
\end_layout

\begin_layout Standard
The Java platform has such a desktop integration feature in Java SE v6.
 The state of affairs today is such that the MacOSX platform still lags
 other platforms and does not yet support this version of Java.
 Developers often cannot afford to ignore this platform, since the very
 
\emph on
raison d'tre
\emph default
 of the Java platform is platform independence.
\end_layout

\begin_layout Standard
JMatter has a generic solution to this general problem of 
\begin_inset Quotes eld
\end_inset

launching
\begin_inset Quotes erd
\end_inset

 a given file, with the result being the launching of the desktop's default-desi
gnated reader for the document in question, combined with the action of
 opening the file in question within that viewer.
 This solution will work with earlier versions of Java (e.g.
 Java 5), and can be used to open PDF files, and other documents (.doc, .txt,
 .xls, .csv, etc..) in a platform-independent manner.
\end_layout

\begin_layout Standard
Here's example code that uses a simple strategy for launching a dynamically
 generated pdf file:
\end_layout

\begin_layout LyX-Code
File reportFile = File.createTempFile("report", ".pdf");
\end_layout

\begin_layout LyX-Code
reportFile.deleteOnExit();
\end_layout

\begin_layout LyX-Code
// write to the file..
\end_layout

\begin_layout LyX-Code
com.u2d.utils.Launcher.openFile(reportFile);
\end_layout

\begin_layout Standard
In the above example we use Java's API to create a temporary file in a platform-
independent manner and specify that the file should be deleted after the
 end-user quits the application.
 Then we simply call the static method 
\emph on
Launcher.openFile(file)
\emph default
 which does the rest.
 This has been verified to work on windows, apple, and linux platforms reliably.
\end_layout

\begin_layout Standard
The 
\emph on
Launcher
\emph default
 utility in addition provides the following useful two methods:
\end_layout

\begin_layout Enumerate

\emph on
public static void openInBrowser(String url)
\end_layout

\begin_layout Enumerate

\emph on
public static void openInEmailApp(EmailMessage msg)
\newline
public static void openInEmai
lApp(String mailtoURL)
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
In this chapter we've seen the ease with which we can integrate wizards
 (assistants) into an already powerful user interface.
\end_layout

\begin_layout Standard
This wizard feature has already been used in other contexts to produce complex
 wizards, that break down complex new patient forms at medical clinics into
 a set of smaller steps.
 Most of us are too familiar with the amounts of information a patient or
 guarantor must enter when first visiting a medical institution (in the
 United States, at least).
\end_layout

\begin_layout Standard
The JMatter framework attempts to be as open as possible.
 Wizards are not the only way to inject custom user interface features into
 JMatter applications.
 JMatter was designed to allow you to write your own custom views for objects
 and plug them into your existing JMatter applications, which is the topic
 of our next chapter.
\end_layout

\begin_layout Standard
We've also seen the CSV Export feature, a nice though simple mechanism for
 exporting data out of your application.
 Of course, there already exist many tools to export and process your applicatio
n's data.
 It's already easily accessible in that all the information resides in an
 open database system.
\end_layout

\begin_layout Standard
Finally, we also see that JMatter provides an avenue for producing PDFs
 by integrating and leveraging the open source JFreeReport API.
 I've personally also written directly against the underlying iText PDF
 library to produce and display PDFs directly as a consequence of a command
 invocation.
\end_layout

\begin_layout Chapter
Calendars and Maps
\end_layout

\begin_layout Standard
Many types exhibit fields such as time spans: sessions, appointments, meetings,
 visits and more.
 Likewise many pieces of information have location information: a latitude
 and longitude.
 Such information is more naturally interpreted visually.
 
\end_layout

\begin_layout Standard
We saw an example of scheduling in the Sympster demo application.
 JMatter supports both a simple and a fancy model for integrating scheduling
 visually into its graphical user interface.
\end_layout

\begin_layout Standard
For mapping, JMatter integrates Swingx-ws for viewing entities on a map,
 in a fashion similar to what we've become accustomed to with Google maps.
\end_layout

\begin_layout Section
Calendars
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand vref
reference "sec:Calendaring"

\end_inset

 discussed a way to expose a fully-functional calendar view into the Sympster
 sample application.
 This calendar view has some attractive features such as the ability to
 view multiple schedules (we saw different schedules for distinct locations
 at a conference).
 It took only abiding by a few simple conventions to do this integration.
 JMatter now calls this form of calendaring integration its fancy calendaring
 model.
\end_layout

\begin_layout Standard
JMatter now exposes a second, simpler calendaring integration model that
 makes almost no requirements on your model and yet in some ways is even
 more powerful than the former.
 Let's say we need to model a meeting.
 All we need to do is define a field of type 
\emph on
TimeSpan
\emph default
 and extend the base type 
\emph on
CalEvent
\emph default
.
 This base type is now only a marker base class.
 We are not required to provide any metadata, there's no need to implement
 or override any methods, and we're free to name the model object's timespan
 field however we see fit.
\end_layout

\begin_layout Standard
JMatter will detect the type in question and automatically identify the
 timespan field in question.
 JMatter then exposes a command on the type named 
\emph on
Browse in Calendar
\emph default
, which brings up a calendar view with both custom week and day views.
 You can navigate this view in time.
 What's special is that this custom calendar view is nothing but a list
 view.
 It lists instances of a given type.
\end_layout

\begin_layout Standard
As you already know, the default list view that appears as a consequence
 of invoking the 
\emph on
Browse
\emph default
 command is always adorned with a query panel at the top.
 This means that the list can be dynamically filtered.
 This calendar view sports the same query panel.
 So, not only can we browse information in time, but this feature is further
 combined with search capabilities.
 So if we're looking at a calendar that's too crowded with meetings or talks,
 and we're looking for a meeting at a specific location, we can filter the
 listing.
\end_layout

\begin_layout Standard
In figure 
\begin_inset LatexCommand vref
reference "fig:Calendar-dayview"

\end_inset

 we see a calendar view with four talks.
 Note the query panel at the top.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/calendar_dayview.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Calendar view with four talks
\begin_inset LatexCommand label
name "fig:Calendar-dayview"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next figure shows the same listing filtered by title (we're looking
 for talks with the word 'Swing' in their title, just as an example).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/dayview_filtered.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Filtered Calendar View
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Separately, one enhancement to this calendaring view worth noting is that
 durations can now be edited directly from within this view by simply dragging
 the bottom edge of event views to the desired end time.
\end_layout

\begin_layout Standard
So calendaring is even simpler than it used to be, the integration is dead
 simple, requiring only the extension of a marker base type, and the features
 are more compelling, with search being pre-integrated into calendaring
 views.
\end_layout

\begin_layout Section
Maps
\end_layout

\begin_layout Standard
Analogous to having integrated custom views for types with a time component,
 JMatter has begun providing custom views for types with a location component.
\end_layout

\begin_layout Standard
For this feature, JMatter integrates the work done by the Sun Swing team
 on the project named 
\emph on
Swingx-ws
\emph default
 (where ws stands for web services).
\end_layout

\begin_layout Standard
This implementation is a little less mature compared to calendaring but
 has come along nicely.
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:A-Flight-Route"

\end_inset

 shows an example route for a flight itinerary that leverages JMatter's
 mapping support.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/sample_trip.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A Flight Route
\begin_inset LatexCommand label
name "fig:A-Flight-Route"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this particular implementation I embellished the default map view with
 an additional layer using curved paths to delineate the route's segments.
 The waypoints on the map represent actual model objects.
 We can right-click on one and edit it if we wish.
\end_layout

\begin_layout Standard
The basic contract is that a type extend 
\emph on
AbstractComplexMappableEObject
\emph default
 and implement the single method specified in the contract with the interface
 
\emph on
MappableEO
\emph default
: 
\end_layout

\begin_layout LyX-Code
 public GeoPoint geoPosition();
\end_layout

\begin_layout Standard
You guessed it: a 
\emph on
GeoPoint
\emph default
 is a JMatter type, which means that, among other things, it knows how to
 persist itself to database.
 A 
\emph on
GeoPoint
\emph default
 encapsulates a latitude and longitude.
\end_layout

\begin_layout Standard
The specific flight support application from which the previous screenshot
 was taken has a model object named 
\emph on
Airport
\emph default
 which implements this contract.
 In return, each instance will bear the command 
\emph on
View on Map
\emph default
, which will automatically bring up a map view and add the waypoint in question.
 From there, users can further interact with the map.
\end_layout

\begin_layout Standard
Further, list views for 
\emph on
Airports
\emph default
 automatically bear the list command 
\emph on
View on Map
\emph default
 as shown in figure 
\begin_inset LatexCommand ref
reference "fig:List-Command-Map"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/listview.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
List Command: View on Map
\begin_inset LatexCommand label
name "fig:List-Command-Map"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This particular list happens to be the search results of a save query for
 Airports (and Heliports) in the vicinity of Austin, Texas.
 The next figure shows the resulting map view with the waypoints in question.
 A map view is again nothing but a list view.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard

\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/listview_map.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
List Command: View on Map
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The map is zoomable of course.
 This means that if we wish to, we can take a closer look at the Lakeway
 airfield, as shown in the next figure.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/zoomed_in.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Zooming in on a Waypoint
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Future enhancements to mapping support will likely be in the area of enhancing
 the map view with a query panel.
 In addition, we're considering tying panning a map with fetching all waypoints
 bounded by the geographical rectangle that the map represents, which will
 make feasible browsing large amounts of information on a map.
\end_layout

\begin_layout Standard
I would like to thank Andres Almiray for suggesting and prototyping this
 integration into JMatter.
\end_layout

\begin_layout Subsection
Maps: An atlernative to view embedding
\end_layout

\begin_layout Standard
As nice as it is to be able to embed map views directly in a JMatter application
, sometimes a simpler solution may be the more elegant in a particular context.
 For example, I've recently been working on a client application for persons
 who need to service a specific address.
 In that context, I decided to add the ability for the end user to plot
 the given address directly in google maps by launching a web browser:
\end_layout

\begin_layout LyX-Code
public static final String googleMapsUrlPattern = "http://maps.google.com/maps?q=%
s";
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Cmd
\end_layout

\begin_layout LyX-Code
public void ViewInGoogleMaps(CommandInfo cmdInfo)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   String address = String.format("%s, %s %s %s", street, city, stateCode,
 zip);
\end_layout

\begin_layout LyX-Code
   String url = String.format(googleMapsUrlPattern, EmailMessage.htmlEscape(addres
s));
\end_layout

\begin_layout LyX-Code
   Launcher.openInBrowser(url);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
All we're doing above is constructing the proper url to bring up an address
 using google maps, and finally launching the url in a browser.
 It's that easy.
\end_layout

\begin_layout Chapter
Customized Views and Editors
\begin_inset LatexCommand label
name "cha:Customized-Views-and"

\end_inset


\end_layout

\begin_layout Standard
It's nice for a framework to support the automatic generation of views for
 various objects.
 We've also seen how the base user interface can be augmented with calendaring
 features, wizards, and support for producing PDFs.
 However, it's equally important for a framework to remain flexible and
 to allow for the construction of custom views as well.
\end_layout

\begin_layout Standard
JMatter's primary view mechanism at the moment is its Swing-based view mechanism.
 Other view mechanisms might be constructed in the future, including possibly
 a web-based user interface.
\end_layout

\begin_layout Standard
In this chapter I'd like to demonstrate through examples various ways in
 which custom views can be integrated into the Swing view mechanism.
\end_layout

\begin_layout Section
Complex, or Composite Views
\end_layout

\begin_layout Standard
The 
\emph on
demo-apps
\emph default
 subdirectory contains a project, 
\emph on
CustomUI
\emph default
, designed specifically to illustrate how this is done.
 It is similar to our contact manager: There's a 
\emph on
Contact
\emph default
 class and an 
\emph on
Address
\emph default
 class.
 The idea is that we'd like to be able to customize the way Addresses appear
 on the screen; specifically, the way that the form view for addresses is
 laid out.
 The default form view is nice.
 Figure 
\begin_inset LatexCommand ref
reference "cap:Standard-Form-View"

\end_inset

 displays the default view for the 
\emph on
address
\emph default
 property of the 
\emph on
Contact
\emph default
 class.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CustomView-1.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Standard Form View the 
\emph on
Contact.address
\emph default
 Field
\begin_inset LatexCommand label
name "cap:Standard-Form-View"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's say that we'd prefer to display addresses in such a way that the field
 captions are placed above the field editors (instead of appearing to their
 left), and that we'd like to lay out the 
\emph on
city
\emph default
, 
\emph on
state
\emph default
, and 
\emph on
zip
\emph default
 fields all on the same line, instead of having them appear one below the
 other, as shown in Figure 
\begin_inset LatexCommand ref
reference "cap:Desired-view"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/CustomView-2.png
	lyxscale 30
	scale 40
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Desired view for Addresses
\begin_inset LatexCommand label
name "cap:Desired-view"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It turns out that JMatter's 
\emph on
FormView
\emph default
 is already parametrized such that, if you prefer, you can designate that
 labels appear above their editors instead of to their left.
 All you need to do is revise the value for the 
\emph on
labelEditorLayoutHorizontal
\emph default
 property in your application's spring configuration context file 
\emph on
src/applicationContext.xml
\emph default
 as shown below:
\end_layout

\begin_layout LyX-Code
<bean id="view-mechanism" class="com.u2d.view.swing.SwingViewMechanism"
\end_layout

\begin_layout LyX-Code
      factory-method="getInstance">
\end_layout

\begin_layout LyX-Code
   <property name="appSession" ref="app-session" />
\end_layout

\begin_layout LyX-Code
   <property name="labelEditorLayoutHorizontal" value="false" />
\end_layout

\begin_layout LyX-Code
</bean>
\end_layout

\begin_layout Standard
Let's proceed by pretending that this feature was not available.
 We must do two things:
\end_layout

\begin_layout Enumerate
Override the method 
\emph on
getMainView()
\emph default
 on the Address class, to return a new view
\end_layout

\begin_layout Enumerate
Implement the custom view for addresses; this process is similar to the
 way we traditionally build views in Swing
\end_layout

\begin_layout Standard
The first step is straightforward:
\end_layout

\begin_layout LyX-Code
public EView getMainView()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   return new CustomAddressView(this);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Now, for the implementation.
 We could implement the UI by extending from Swing's 
\emph on
JPanel
\emph default
, like this:
\end_layout

\begin_layout LyX-Code
public class CustomAddressView extends JPanel
\end_layout

\begin_layout LyX-Code
      implements ComplexEView, Editor
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private Address _addr;
\end_layout

\begin_layout LyX-Code
   JComponent line1View, line2View, cityView, stateView, zipView;
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public CustomAddressView(Address address)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      _addr = address;
\end_layout

\begin_layout LyX-Code
      buildUI();
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   private void buildUI()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      line1View = (JComponent) _addr.getLine1().getView();
\end_layout

\begin_layout LyX-Code
      line2View = (JComponent) _addr.getLine2().getView();
\end_layout

\begin_layout LyX-Code
      cityView = (JComponent) _addr.getCity().getView();
\end_layout

\begin_layout LyX-Code
      stateView = (JComponent) _addr.getStateCode().getView();
\end_layout

\begin_layout LyX-Code
      zipView = (JComponent) _addr.getZipCode().getView();
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
      FormLayout layout = new FormLayout("pref, 10px, pref, 10px, pref",
 
\end_layout

\begin_layout LyX-Code
                         "pref, pref, 10px, pref, pref, 10px, pref, pref");
\end_layout

\begin_layout LyX-Code
      CellConstraints cc = new CellConstraints();
\end_layout

\begin_layout LyX-Code
      DefaultFormBuilder builder = new DefaultFormBuilder(layout, this);
\end_layout

\begin_layout LyX-Code
      // add caption..
\end_layout

\begin_layout LyX-Code
      builder.add(new JLabel("Line 1:"), cc.xyw(1, 1, 5));
\end_layout

\begin_layout LyX-Code
      builder.add(line1View, cc.xyw(1, 2, 5));
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
      builder.add(new JLabel("Line 2:"), cc.xyw(1, 4, 5));
\end_layout

\begin_layout LyX-Code
      builder.add(line2View, cc.xyw(1, 5, 5));
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
      builder.add(new JLabel("City:"), cc.xy(1, 7));
\end_layout

\begin_layout LyX-Code
      builder.add(new JLabel("State:"), cc.xy(3, 7));
\end_layout

\begin_layout LyX-Code
      builder.add(new JLabel("Zip:"), cc.xy(5, 7));
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
      builder.add(cityView, cc.xy(1,8));
\end_layout

\begin_layout LyX-Code
      builder.add(stateView, cc.xy(3, 8));
\end_layout

\begin_layout LyX-Code
      builder.add(zipView, cc.xy(5, 8));
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public EObject getEObject() { return _addr; }
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   // as a composite view, this particular class may not
\end_layout

\begin_layout LyX-Code
   // necessarily be interested in binding to the model
\end_layout

\begin_layout LyX-Code
   // and listen to changes.
  to the extent that i use
\end_layout

\begin_layout LyX-Code
   // the jmatter views for the subparts of the address,
\end_layout

\begin_layout LyX-Code
   // they will be listening directly to the parts.
\end_layout

\begin_layout LyX-Code
   public void detach() { }
\end_layout

\begin_layout LyX-Code
   public void stateChanged(ChangeEvent e) { }
\end_layout

\begin_layout LyX-Code
   public void propertyChange(PropertyChangeEvent evt) { }
\end_layout

\begin_layout LyX-Code
   public boolean isMinimized() { return false; }
\end_layout

\begin_layout LyX-Code
   public int transferValue()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      int result = 0;
\end_layout

\begin_layout LyX-Code
      result += ((Editor) line1View).transferValue();
\end_layout

\begin_layout LyX-Code
      result += ((Editor) line2View).transferValue();
\end_layout

\begin_layout LyX-Code
      result += ((Editor) cityView).transferValue();
\end_layout

\begin_layout LyX-Code
      result += ((Editor) stateView).transferValue();
\end_layout

\begin_layout LyX-Code
      result += ((Editor) zipView).transferValue();
\end_layout

\begin_layout LyX-Code
      return result;
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public void setEditable(boolean editable)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      ((Editor) line1View).setEditable(editable);
\end_layout

\begin_layout LyX-Code
      ((Editor) line2View).setEditable(editable);
\end_layout

\begin_layout LyX-Code
      ((Editor) cityView).setEditable(editable);
\end_layout

\begin_layout LyX-Code
      ((Editor) stateView).setEditable(editable);
\end_layout

\begin_layout LyX-Code
      ((Editor) zipView).setEditable(editable);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public boolean isEditable()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return ((Editor) line1View).isEditable();
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Let's review this code.
 Here I am using the excellent JGoodies Forms framework to layout a form
 
\begin_inset Quotes eld
\end_inset

by hand,
\begin_inset Quotes erd
\end_inset

 so to speak.
 JGoodies' 
\emph on
DefaultFormBuilder
\emph default
 makes this pretty easy.
 Similar code could also be produced with the help of a visual form designer,
 such as the 
\emph on
Abeille Forms Designer
\emph default
.
 Note however, that there are additional responsibilities that this class
 must fulfill:
\end_layout

\begin_layout Enumerate
The class must implement the 
\emph on
ComplexEView
\emph default
 interface
\end_layout

\begin_layout Enumerate
If the class will also participate in the editing process, it must implement
 the 
\emph on
Editor
\emph default
 interface
\end_layout

\begin_layout Standard
In this case, the 
\emph on
ComplexEView
\emph default
 interface is fairly simple.
 Some of the methods have no-op implementations (
\emph on
detach()
\emph default
, 
\emph on
stateChanged()
\emph default
, 
\emph on
propertyChange()
\emph default
).
 Every view can, at its discretion, attach itself as a listener to the object
 model and thus receive model change notifications.
 In this case, we're dealing with a composite view, and each of the sub-views
 already listens to changes to the parts, so we don't technically need to
 listen to model changes here.
 Views must also make sure to 
\begin_inset Quotes eld
\end_inset

detach
\begin_inset Quotes erd
\end_inset

 themselves from the model objects when they're destroyed.
 It's very important that the 
\emph on
detach()
\emph default
 method properly do this.
 A careless implementation can easily introduce a memory leak into the applicati
on as views are created and their memory not reclaimed because they may
 still be attached to a model object whose lifetime is typically longer
 than its views'.
\end_layout

\begin_layout Standard
The 
\emph on
Editor
\emph default
 interface is also fairly straightforward.
 The 
\emph on
setEditable()
\emph default
 method is called when the model object's state toggles from 
\emph on
Read
\emph default
 to 
\emph on
Edit
\emph default
 (and back), thus giving the user interface a chance to update itself accordingl
y (if so desired).
 Notice also that 
\emph on
transferValue()
\emph default
 is called before an object is saved, allowing the view a chance to bind
 the newly entered data back to the model object (or possibly raise a validation
 exception, in which case the save operation is vetoed.
 The integer value returned by this method is an indication of the number
 of validation errors, which is also displayed by the framework in such
 circumstances.
\end_layout

\begin_layout Section
A Custom View for Sympster Sessions
\end_layout

\begin_layout Standard
Here's a more compelling illustration of customizing a view for an object:
 the 
\emph on
Sympster
\emph default
 demo application was recently further customized with a custom view for
 its 
\emph on
Session
\emph default
 class.
 In this situation, I wanted to reuse JMatter's default 
\emph on
FormView
\emph default
 which handles the editing process beautifully and saves me a lot of work.
 On the other hand, I wanted a more compelling view for sessions in read
 state, as shown in figure 
\begin_inset LatexCommand ref
reference "fig:Customized-View-for"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/custom-sessionview.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Customized View for Session
\begin_inset LatexCommand label
name "fig:Customized-View-for"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
JMatter provides a class named 
\emph on
CustomReadView
\emph default
 which automatically composes JMatter's 
\emph on
FormView
\emph default
 in edit state with a custom view that you provide for the read state, as
 shown in the following code snippet from the class Session where the 
\emph on
getMainView()
\emph default
 method is overridden correspondingly:
\end_layout

\begin_layout LyX-Code
   public EView getMainView()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return new CustomReadView(new SessionView(this));
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout Standard
Please refer to the implementation of 
\emph on
SessionView
\emph default
 in the Sympster demo application for the details of its implementation.
 One note worthy of mentioning is that the implementation leverages JMatter's
 
\emph on
css4swing
\emph default
 library to style itself, which I discuss in chapter 
\begin_inset LatexCommand vref
reference "cha:Styling-the-UI"

\end_inset

.
\end_layout

\begin_layout Section
The 
\emph on
Self
\emph default
 demo application
\end_layout

\begin_layout Standard
Yet another way to augment JMatter with hand-crafted views and widgets is
 illustrated through the bundled demo application named 
\emph on
Self
\emph default
.
 The model for this application is trivial on purpose: it consists of a
 Space that contains Balls.
 The space has one additional property: the temperature within the space.
\end_layout

\begin_layout Standard
In this particular scenario, it is quite unpallatable to view these objects
 through forms when it would be so much more compelling if their visual
 representations were represented directly in the UI.
\end_layout

\begin_layout Standard
Any command you write that returns an object of type 
\emph on
View
\emph default
 or 
\emph on
JComponent
\emph default
 will be displayed by JMatter upon invocation.
 The 
\emph on
Self
\emph default
 demo application takes advantage of this feature:
\end_layout

\begin_layout LyX-Code
public class Space
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
   @Cmd(mnemonic='s')
\end_layout

\begin_layout LyX-Code
   public View Show(CommandInfo cmdInfo)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return new SpaceView(this);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout Standard
Running this application, we can create a space, and add a few balls into
 our space.
 We can further set the temperature.
 I created two balls: a filled red ball with radius 30, and a blue ball
 with radius 80, and my temperature was 30 degrees celsius.
 Proceeding with invoking the 
\emph on
Show
\emph default
 command, I can expose my custom view 
\emph on
SpaceView
\emph default
 directly in JMatter:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/Self.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
The Self Demo Application
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The screenshot doesn't really do it justince since the balls are moving
 withing the space at a certain speed.
 Try to change the temperature within the space to, say, 50 degrees.
 This will cause the balls to move faster.
 Technically, this custom view could also have been implemented by wrapping
 it in a CustomReadView as we did in the previous example.
\end_layout

\begin_layout Section
Customizing Layout
\end_layout

\begin_layout Standard
JMatter provides a means through which a layout for a form can be defined
 by using the open-source 
\emph on
Abeille Forms Designer
\emph default
.
 By placing placeholder components in the layout and giving each a name
 matching a model object's field name, JMatter can be made to use the specified
 layout when displaying the form in question.
 
\emph on
Abeille
\emph default
 allows us to serialize the form design's definition to a 
\emph on
.jfrm
\emph default
 file which we place along with our source code (JMatter's build file automatica
lly copies these files to the classpath as part of the build process) in
 a file we name after the model object whose view we want to customize.
 The 
\emph on
CustomUI
\emph default
 demo application provides an example implementation.
\end_layout

\begin_layout Section
Atomic Views
\end_layout

\begin_layout Standard
JMatter defines the notion of atomic types.
 Examples include representations for booleans, dates, text, zip codes,
 social security numbers, percentages, integers, floats, etc..
 They're defined in the package 
\emph on
com.u2d.type.atom
\emph default
.
\end_layout

\begin_layout Standard
This section describes how to write a custom view and/or editor for a given
 type.
 Let's take 
\emph on
BooleanEO
\emph default
 as an example.
 Here is the implementation for the default renderer for boolean's:
\end_layout

\begin_layout LyX-Code
public class BooleanRenderer extends JLabel implements AtomicRenderer
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public void render(AtomicEObject value)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      BooleanEO eo = (BooleanEO) value;
\end_layout

\begin_layout LyX-Code
      setText((eo.booleanValue()) ? "Yes" : "No");
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public void passivate() { }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The interface 
\emph on
AtomicRenderer
\emph default
 has essentially a single method.
 You can ignore the 
\emph on
passivate()
\emph default
 method for now (we're considering making a design revision where views
 are pooled, and then re-used for different atomic types, in which case
 this method could be used to 
\begin_inset Quotes eld
\end_inset

clean up
\begin_inset Quotes erd
\end_inset

 the view before it's re-used).
\end_layout

\begin_layout Standard
So basically one implements the 
\emph on
render()
\emph default
 method.
 This method is handed a model object that it must render.
 So in this case, the renderer is given an instance of a 
\emph on
BooleanEO
\emph default
 which it uses to 
\begin_inset Quotes eld
\end_inset

paint
\begin_inset Quotes erd
\end_inset

 the text 
\emph on
Yes
\emph default
 or 
\emph on
No
\emph default
 on a JLabel.
\end_layout

\begin_layout Standard
To write a custom Editor for a type, you must implement two methods: 
\emph on
render()
\emph default
 and 
\emph on
bind()
\emph default
.
 Here's the definition of the interface that one must implement:
\end_layout

\begin_layout LyX-Code
public interface AtomicEditor extends AtomicRenderer
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public int bind(AtomicEObject value);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
And here's an example implementation, again for the 
\emph on
BooleanEO
\emph default
 type:
\end_layout

\begin_layout LyX-Code
public class BooleanCheckboxEditor extends JCheckBox
\end_layout

\begin_layout LyX-Code
      implements ItemListener, AtomicEditor, ActionNotifier
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public BooleanCheckboxEditor()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      addItemListener(this);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public void itemStateChanged(ItemEvent e)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      setText( (isSelected()) ? "Yes" : "No" );
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public int bind(AtomicEObject value)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      BooleanEO eo = (BooleanEO) value;
\end_layout

\begin_layout LyX-Code
      eo.setValue(isSelected());
\end_layout

\begin_layout LyX-Code
      return 0;
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public void render(AtomicEObject value)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      BooleanEO eo = (BooleanEO) value;
\end_layout

\begin_layout LyX-Code
      setSelected(eo.booleanValue());
\end_layout

\begin_layout LyX-Code
      itemStateChanged(null); // text synch with checkbox
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public void passivate() { }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The 
\emph on
bind()
\emph default
 method is responsible on setting the newly edited value back to the model
 object.
 Here's a second implementation for a 
\emph on
BooleanEO
\emph default
 editor that uses a pair of radio buttons instead:
\end_layout

\begin_layout LyX-Code
public class BooleanRadioEditor extends JPanel implements AtomicEditor
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private JRadioButton _yesBtn, _noBtn;
\end_layout

\begin_layout LyX-Code
   public BooleanRadioEditor()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      _yesBtn = new JRadioButton("Yes");
\end_layout

\begin_layout LyX-Code
      _yesBtn.setOpaque(false);
\end_layout

\begin_layout LyX-Code
      _noBtn = new JRadioButton("No");
\end_layout

\begin_layout LyX-Code
      _noBtn.setOpaque(false);
\end_layout

\begin_layout LyX-Code
      _yesBtn.addActionListener(new ActionListener()
\end_layout

\begin_layout LyX-Code
      {
\end_layout

\begin_layout LyX-Code
         public void actionPerformed(ActionEvent evt)
\end_layout

\begin_layout LyX-Code
         {
\end_layout

\begin_layout LyX-Code
            _yesBtn.setSelected(true);
\end_layout

\begin_layout LyX-Code
         }
\end_layout

\begin_layout LyX-Code
      });
\end_layout

\begin_layout LyX-Code
      _noBtn.addActionListener(new ActionListener()
\end_layout

\begin_layout LyX-Code
      {
\end_layout

\begin_layout LyX-Code
         public void actionPerformed(ActionEvent evt)
\end_layout

\begin_layout LyX-Code
         {
\end_layout

\begin_layout LyX-Code
            _noBtn.setSelected(true);
\end_layout

\begin_layout LyX-Code
         }
\end_layout

\begin_layout LyX-Code
      });
\end_layout

\begin_layout LyX-Code
      ButtonGroup group = new ButtonGroup();
\end_layout

\begin_layout LyX-Code
      group.add(_yesBtn);
\end_layout

\begin_layout LyX-Code
      group.add(_noBtn);
\end_layout

\begin_layout LyX-Code
      FormLayout layout = new FormLayout("pref, 3px, pref", "pref");
\end_layout

\begin_layout LyX-Code
      DefaultFormBuilder builder = new DefaultFormBuilder(layout, this);
\end_layout

\begin_layout LyX-Code
      CellConstraints cc = new CellConstraints();
\end_layout

\begin_layout LyX-Code
      builder.add(_yesBtn, cc.xy(1, 1));
\end_layout

\begin_layout LyX-Code
      builder.add(_noBtn, cc.xy(3, 1));
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public void render(AtomicEObject value)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      BooleanEO eo = (BooleanEO) value;
\end_layout

\begin_layout LyX-Code
      JRadioButton btn = (eo.booleanValue()) ? _yesBtn : _noBtn;
\end_layout

\begin_layout LyX-Code
      btn.setSelected(true);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public int bind(AtomicEObject value)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      BooleanEO eo = (BooleanEO) value;
\end_layout

\begin_layout LyX-Code
      eo.setValue(_yesBtn.isSelected());
\end_layout

\begin_layout LyX-Code
      return 0;
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   public void passivate() { }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The JMatter codebase is rife with examples of atomic editors and renderers.
 Use them as the basis for creating your own implementations.
\end_layout

\begin_layout Subsection
Specifying the Default Editor and Renderer
\end_layout

\begin_layout Standard
Specifying the default renderer and editor for a given type is straightforward.
 JMatter defines the interface 
\emph on
ViewMechanism
\emph default
.
 The Swing implementation of that interface is 
\emph on
SwingViewMechanism
\emph default
.
 This interface defines a litany of methods that specify the components
 for the entire user interface.
 By revising the corresponding method for a given view mechanism, you control
 the user interface.
\end_layout

\begin_layout Standard
For our above implementations of a boolean editor and renderer, and assuming
 the 
\emph on
SwingViewMechanism
\emph default
, you'd revise the implementations of 
\emph on
getBooleanRenderer()
\emph default
 and getBooleanEditor() respectively for the 
\emph on
BooleanEO
\emph default
 type:
\end_layout

\begin_layout LyX-Code
public AtomicRenderer getBooleanRenderer() {
\end_layout

\begin_layout LyX-Code
  return new BooleanRenderer();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
public AtomicEditor getBooleanEditor() {
\end_layout

\begin_layout LyX-Code
  return new BooleanRadioEditor();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Of course, if you're going to be implementing a custom view for a more complex
 or composite object, then you're in complete control of the rendering and
 editing process.
\end_layout

\begin_layout Standard
The framework's view mechanism in general is extremely modular.
 It's easy to override one small aspect and plug it right into the existing
 view mechanism to fundamentally change one aspect of the user interface,
 whether it's by providing your own implementation of a 
\emph on
FormView
\emph default
 (or embellishing the existing one), or by customizing the widgets that
 represent associations.
\end_layout

\begin_layout Chapter
Localization
\end_layout

\begin_layout Standard
I would like to thank Felix Torre for assisting in the development of support
 for localization (l10n) in JMatter, and Marco Meschieri for meticulously
 going through the codebase to extract captions and other text so that they
 could be localized.
 This chapter documents the current support for l10n in JMatter.
\end_layout

\begin_layout Standard
The basic requirement is to be able to deploy a single application to a
 diverse population, in any of a combination of languages.
 For example, we may have both English-speaking and French-speaking users.
\end_layout

\begin_layout Standard
Fundamentally, JMatter resorts to one aspect of the Java language that was
 designed for localization: the notion of resource bundles.
 JMatter uses property-file based resource bundles.
 Multiple properties files are created.
 Each follows a certain convention to designate what language and locale
 it corresponds to, by combining a base name with a suffix.
\end_layout

\begin_layout Standard
Look at the Sympster demo application for example.
 You will find three files: 
\emph on
locale-metadata.properties
\emph default
, 
\emph on
locale-metadata_fr.properties
\emph default
, and 
\emph on
locale-metadata_es.properties
\emph default
.
 So each suffix, 
\emph on
_fr
\emph default
 or 
\emph on
_es
\emph default
, is a language designation: the former is the code for the French language,
 while the second designates Spanish.
 Resource bundles imply a specific hierarchy for retrieving values for specific
 keys in these property files: we check the computer's specific language
 and country.
 Let's say we're in Canada, where the language is 
\emph on
fr
\emph default
 and the country is 
\emph on
CA
\emph default
.
 The system will look for the file 
\emph on
locale-metadata_fr_CA.properties
\emph default
, falling back to the more generic 
\emph on
_fr
\emph default
 file, and finally, falling back to the most generic property file.
\end_layout

\begin_layout Standard
JMatter defines keys for retrieving all the labels and text rendered on
 the login dialog box.
 Here is how they're specified in the _fr resource bundle:
\end_layout

\begin_layout LyX-Code
# Login Dialog
\end_layout

\begin_layout LyX-Code
# ===============================
\end_layout

\begin_layout LyX-Code
logindlg.title=Entrez
\end_layout

\begin_layout LyX-Code
logindlg.lbl.username=Nom D'utilisateur:
\end_layout

\begin_layout LyX-Code
logindlg.lbl.pwd=Mot de passe:
\end_layout

\begin_layout LyX-Code
logindlg.msg.login=Entrez S'il vous plait..
\end_layout

\begin_layout LyX-Code
logindlg.msg.failed_auth=Mauvais credentiaux; Essayez encore une fois..
\end_layout

\begin_layout LyX-Code
logindlg.msg.user_locked=Votre compte est verouille; 
\backslash
 
\end_layout

\begin_layout LyX-Code
   Contactez l'administrateur svp..
\end_layout

\begin_layout Standard
JMatter also defines a convention for specifying type labels, command labels,
 and field labels that are shared by all applications:
\end_layout

\begin_layout LyX-Code
# JMatter Global Localization Entries
\end_layout

\begin_layout LyX-Code
# ===================================
\end_layout

\begin_layout LyX-Code
Command.Save=Sauve
\end_layout

\begin_layout LyX-Code
Command.Cancel=Abandone
\end_layout

\begin_layout LyX-Code
Command.Copy=Copie
\end_layout

\begin_layout LyX-Code
Command.Paste=Colle
\end_layout

\begin_layout LyX-Code
Command.SaveAndClose=Sauve et Ferme
\end_layout

\begin_layout LyX-Code
Command.Open=Ouvre
\end_layout

\begin_layout LyX-Code
Command.Edit=Edite
\end_layout

\begin_layout LyX-Code
Command.Delete=Efface
\end_layout

\begin_layout LyX-Code
Command.Refresh=Rafraichi
\end_layout

\begin_layout LyX-Code
ComplexType.New=Fait Nouveau
\end_layout

\begin_layout LyX-Code
ComplexType.Browse=Liste
\end_layout

\begin_layout LyX-Code
ComplexType.Find=Trouve
\end_layout

\begin_layout LyX-Code
User=Utilisateur
\end_layout

\begin_layout LyX-Code
Users=Utilisateurs
\end_layout

\begin_layout LyX-Code
User.username=Nom d'utilisateur
\end_layout

\begin_layout LyX-Code
User.password=Mot de passe
\end_layout

\begin_layout LyX-Code
User.locked=Verrouill
\end_layout

\begin_layout LyX-Code
User.photo=Photographe
\end_layout

\begin_layout LyX-Code
User.role=rle
\end_layout

\begin_layout LyX-Code
User.desktop=criture-bureau
\end_layout

\begin_layout Standard
Here we see that generic commands, shared by all types, are specified as
 
\emph on
Command.<commandname>
\emph default
.
 Generic type commands are specified using the key 
\emph on
ComplexType.<commandname>
\emph default
.
 Other type commands and type fields are likewise specified using the key:
 
\emph on
<typename>.<fieldname|commandname>
\emph default
.
 When dealing with aggregate fields, you can use a multiple dot notation,
 as in 
\emph on
Speaker.contact.homePhone
\emph default
 (see below).
\end_layout

\begin_layout Standard
Here are some application-specific label designations for French, for the
 Sympster application:
\end_layout

\begin_layout LyX-Code
# Application-Specific Localization Example Entries
\end_layout

\begin_layout LyX-Code
# =================================================
\end_layout

\begin_layout LyX-Code
Speaker=Presenteur
\end_layout

\begin_layout LyX-Code
Speakers=Presenteurs
\end_layout

\begin_layout LyX-Code
Speaker.name=Nom
\end_layout

\begin_layout LyX-Code
Speaker.title=Titre
\end_layout

\begin_layout LyX-Code
Speaker.bio=Biographie
\end_layout

\begin_layout LyX-Code
Speaker.photo=Photo
\end_layout

\begin_layout LyX-Code
Speaker.AddTalk=Ajoute Une Presentation
\end_layout

\begin_layout LyX-Code
Speaker.contact.homePhone=Telephone Maison
\end_layout

\begin_layout Standard
Note also that plural designations can be provided.
 The key is simply the plural name for the type in English.
\end_layout

\begin_layout Standard
Here in the USA I can test how my application might look to a French speaker
 by revising the locale on my system, or by forcing a locale through a system
 property, as illustrated by the 
\emph on
run
\emph default
 target in 
\emph on
build.xml
\emph default
:
\end_layout

\begin_layout LyX-Code
 <target name="run" description="run app" depends="genhbm">
\end_layout

\begin_layout LyX-Code
   <java classname="${main.class}" classpathref="class.path"
\end_layout

\begin_layout LyX-Code
         fork="true" maxmemory="192m">
\end_layout

\begin_layout LyX-Code
    <!-- to test localization, uncomment this..
\end_layout

\begin_layout LyX-Code
     <sysproperty key="user.language" value="fr" />
\end_layout

\begin_layout LyX-Code
      -->
\end_layout

\begin_layout LyX-Code
   </java>
\end_layout

\begin_layout LyX-Code
 </target>
\end_layout

\begin_layout Standard
Uncomment the 
\emph on
<sysproperty>
\emph default
 line and set its value accordingly.
 We've included a couple of snapshots of the resulting localized application
 (figures 
\begin_inset LatexCommand ref
reference "fig:login_localized"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "fig:partiallocalization"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/i18n_login.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Login dialog localized for French 
\begin_inset LatexCommand label
name "fig:login_localized"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/i18n_speakers.png
	lyxscale 30
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Partially localized Sympster Application (French) 
\begin_inset LatexCommand label
name "fig:partiallocalization"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We see a number of the commands now use French captions.
 The speaker is called a Presenteure, the field 
\emph on
name
\emph default
 becomes 
\emph on
Nom
\emph default
 and 
\emph on
title
\emph default
 becomes 
\emph on
titre
\emph default
.
 Not all the text appears in French simply because I didn't provide a full
 list of values for all commands and fields.
 The figures don't show how the context menus also become localized.
 
\emph on
Open
\emph default
 becomes 
\emph on
Ouvre
\emph default
, etc..
\end_layout

\begin_layout Standard
Localization support in JMatter is by no means complete or exhaustive.
 For example, at the moment support for the proper date and currency formats
 for different locales needs work.
 We've already gotten some feedback on how to provide a more complete set
 of localization services.
 We hope that future versions will flesh out this support completely.
\end_layout

\begin_layout Chapter
Child Projects
\begin_inset LatexCommand label
name "cha:Child-Projects"

\end_inset


\end_layout

\begin_layout Standard
This chapter provides a more detail information about the structure of JMatter
 project directories, and documents a JMatter application's build file.
\end_layout

\begin_layout Section
Creating Child Projects
\end_layout

\begin_layout Standard
The framework has its own build file, used to compile the framework itself.
 This build file contains a target: 
\emph on
new-project-ui
\emph default
 that automates the creation of a JMatter project.
 We walked through using this target in chapter 
\begin_inset LatexCommand ref
reference "cha:tut_contactmgr"

\end_inset

.
 Invoking this target brings up a simple user interface, shown in figure
 
\begin_inset LatexCommand vref
reference "fig:newprojectui"

\end_inset

.
 We specify:
\end_layout

\begin_layout Enumerate
The project name
\end_layout

\begin_layout Enumerate
The base directory
\end_layout

\begin_layout Enumerate
Whether we wish to produce a 
\emph on
standalone
\emph default
 or 
\emph on
dependent
\emph default
 project
\end_layout

\begin_layout Standard
The project name is required.
 It is also used as the name of the directory that contains the project
 files.
 If the base directory is not specified, we default to creating the project
 as a sibling directory of the framework itself.
 The last option needs a slightly lengthier explanation.
\end_layout

\begin_layout Standard
A standalone project has no external dependencies.
 Not only is the child project structure created, but all libraries necessary
 to run it are containing within the project, in the 
\emph on
lib/
\emph default
 subdirectory.
 That is, a copy of the JMatter framework is in a sense frozen into the
 child project.
 Standalone projects are therefore not subject to changes to the framework
 that might take place after its creation (unless the JMatter jar file and
 other dependent jar files are manually replaced).
\end_layout

\begin_layout Standard
When creating a dependent project, its build file is told where the JMatter
 framework is located and so it can reference the JMatter framework's .class
 files directly, as well as any 
\emph on
.jar
\emph default
 files that the framework itself leverages.
\end_layout

\begin_layout Standard
Both modes are useful in different contexts.
 For developers with in-depth knowledge of the framework, that expect expect
 perhaps to make changes to the framework as they develop their application,
 it's convenient not to have to repackage the framework jar file and copy
 it to the child project each time a change takes place.
 Dependent child projects would pick up these changes immediately.
 So therein lays the tradeoff.
\end_layout

\begin_layout Standard
It isn't particularly difficult to change one's project from being dependent
 to being standalone or vice versa.
 However, at the time of this writing, there is no magic ant target that
 will do this work on our behalf.
\end_layout

\begin_layout Section
Directory Structure and Files
\end_layout

\begin_layout Standard
The main directories that you'll see after creating a new project are:
\end_layout

\begin_layout LyX-Code
src, test, doc, resources
\end_layout

\begin_layout Standard
Each directory's name fairly clearly implies its role.
 The base directory for Java source code is 
\emph on
src
\emph default
, while 
\emph on
test
\emph default
 is the base directory for tests.
 The 
\emph on
doc
\emph default
 subdirectory contains a basic README file.
 The 
\emph on
doc/
\emph default
 directory is of course an ideal location for your project's own documentation.
\end_layout

\begin_layout Standard
The 
\emph on
resources
\emph default
 folder is interesting; its composition is summarized in the table below.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="left" valignment="top" leftline="true" width="2in">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="2.5in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Directory or File
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
images/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where to place icons for model objects, the image for the splash screen,
 and other image resources that your application will use.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
styles.css
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Default stylesheet for JMatter; governs how the JMatter user interface is
 styled (see chapter 
\begin_inset LatexCommand ref
reference "cha:Styling-the-UI"

\end_inset

).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
model-metadata.properties
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where to specify required fields, and field default values.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
local-metadata_<locale>.properties
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Use for localization: provide translations for type names, command captions,
 field captions, and more in order to produce a user interface that is properly
 translated for the given locale.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
hibernate.properties
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Governs database configuration: database dialect, driver class name, connection
 url, username and password.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
resources/jws
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Contains resources necessary to bundle the application as a java webstart
 distribution (see chapter 
\begin_inset LatexCommand ref
reference "cha:Deploying-your-Application"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
wings/
\emph default
 and 
\emph on
echo2/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
This requires some explanation.
 We're in the process of developing a web-based user interface for JMatter.
 At the time of this writing, this work is not yet finished.
 Resources necessary to construct the web application distribution resides
 in these directories.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
src/class-list.xml
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(
\emph on
Optional
\emph default
) This is where you can preconfigure your application's classbar: that is,
 specify here the list of model objects you wish to expose to your user
 interface.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
src/persistClasses.st
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
You typically will not need to edit this file.
 This template is resolved at build time to list the persisted entities
 in your application.
 The list is derived from the 
\emph on
@Persist
\emph default
 annotations in your class files.
 It is passed to Hibernate via a Spring configuration file.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
All child projects come with an ant build file.
 This build file generates a number of directories for the purpose of maintainin
g artifacts.
 Let's discuss these:
\end_layout

\begin_layout Description
db If you configure your application to use a lightweight or file-based
 database, such as H2 or hsqldb, the database files by default reside in
 this subdirectory
\end_layout

\begin_layout Description
build/classes Your application is compiled to this directory.
 All resources are also copied here, including images and hibernate mapping
 files (the latter being generated, not copied)
\end_layout

\begin_layout Description
jws-dist Used to assemble the Java WebStart distribution
\end_layout

\begin_layout Description
dist The Java WebStart distribution is packaged as a 
\emph on
.war
\emph default
 file and copied to this directory
\end_layout

\begin_layout Section
Build File Targets
\end_layout

\begin_layout Standard
Let's now turn our attention to the child project's ant build file.
 Here is a listing and description of the relevant targets.
\end_layout

\begin_layout LyX-Code
 compile        compile code
\end_layout

\begin_layout LyX-Code
 compile-tests  compile tests
\end_layout

\begin_layout LyX-Code
 genhbm         generate hbm.xml files
\end_layout

\begin_layout LyX-Code
 jar            jar it
\end_layout

\begin_layout LyX-Code
 jar-model      jar just the model 
\end_layout

\begin_layout LyX-Code
 jws-dist       create java webstart distribution
\end_layout

\begin_layout LyX-Code
 macappbundle   create macosx app bundle 
\end_layout

\begin_layout LyX-Code
 reveng-db      Reverse engineer an existing database schema..
\end_layout

\begin_layout LyX-Code
 run            run app
\end_layout

\begin_layout LyX-Code
 run-test       run a test class
\end_layout

\begin_layout LyX-Code
 run-tests      run tests
\end_layout

\begin_layout LyX-Code
 schema-export  export schema to db
\end_layout

\begin_layout LyX-Code
 schema-update  update db schema
\end_layout

\begin_layout LyX-Code
 shellscript    produce runnable shell script
\end_layout

\begin_layout LyX-Code
 test-report    produce junit reports
\end_layout

\begin_layout LyX-Code
Default target: run
\end_layout

\begin_layout Standard
There isn't that much to say beyond the default description of these targets.
 JMatter generates Hibernate 
\emph on
hbm.xml
\emph default
 files to the 
\emph on
build/classes
\emph default
 directory.
 The 
\emph on
run
\emph default
 target is useful while developing.
 You typically don't need to invoke many of these targets.
 Invoking 
\emph on
schema-export
\emph default
 for example will automatically compile the code and generate the mapping
 files first.
 Also, if you're working with a dependent project, any changes to the framework
 codebase will automatically be recompiled first.
\end_layout

\begin_layout Standard
The 
\emph on
jar-model
\emph default
 target is useful in the context of the JMatter Application Browser (see
 chapter 
\begin_inset LatexCommand ref
reference "cha:Deployment,-Take-II:"

\end_inset

).
 For more detail about the 
\emph on
reveng-db
\emph default
 target, see 
\begin_inset LatexCommand vref
reference "sec:Reverse-Engineer-Schema"

\end_inset

.
\end_layout

\begin_layout Standard
Other targets worth pointing out include 
\emph on
shellscript
\emph default
 and 
\emph on
macappbundle
\emph default
.
 The first generates a 
\emph on
run.sh
\emph default
 (or 
\emph on
run.bat
\emph default
 on win platforms) to launch the application.
 On Linux, going from such a script to a desktop-launched application, complete
 with icon, is trivial.
 The latter is specifically for macosx users and bundles the application
 as a 
\emph on
.app
\emph default
 
\begin_inset Quotes eld
\end_inset

file.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Chapter 
\begin_inset LatexCommand vref
reference "cha:Deploying-your-Application"

\end_inset

 walks you through deploying your project via Java WebStart.
\end_layout

\begin_layout Chapter
Styling the UI with CSS
\begin_inset LatexCommand label
name "cha:Styling-the-UI"

\end_inset


\end_layout

\begin_layout Standard
Cascading Stylesheets (CSS) is a web technology.
 It is supported by modern web browsers to style user interfaces.
 CSS is simple and elegant.
 It is also powerful.
 It has an aspect-like design in that styles for parts of a user interface
 can be specified in a manner that is orthogonal from the rest of an application
: it is a cross-cutting concern.
\end_layout

\begin_layout Standard
JMatter comes with built-in support for a subset of the CSS that I believe
 to be applicable to Java's Swing technology.
 By default, JMatter will automatically load the file 
\emph on
resources/styles.css
\emph default
 on startup, and interpret and apply the rules contained within that stylesheet.
 Stylesheets consist of rules, and rules consist of selectors and declarations.
\end_layout

\begin_layout Standard
Let us begin with a description of the CSS engine itself and specifically
 what subset of CSS is supported, and how it is adapted to Swing.
 We will then turn our attention to the default stylesheet.
\end_layout

\begin_layout Section
JMatter's CSS Engine
\end_layout

\begin_layout Subsection
Selectors
\end_layout

\begin_layout Standard
JMatter's CSS implementation supports both simple and composite selectors.
 Simple selectors match a component by any of the following, or a combination
 thereof:
\end_layout

\begin_layout Enumerate
its type
\end_layout

\begin_layout Enumerate
a semantic style name (a css class name)
\end_layout

\begin_layout Enumerate
an id
\end_layout

\begin_layout Standard
In the web world, a component type is designated by its corresponding tag
 name, such as <h1> or <p>.
 In Swing it's designated by its class name, for example: JLabel.
\end_layout

\begin_layout Standard
Composite selectors allow the expression of a path.
 They're composed of two or more simple selectors, related through a combinator:
\end_layout

\begin_layout Enumerate
the Child combinator (denoted by the character >)
\end_layout

\begin_layout Enumerate
the Sibling combinator (denoted by the character +)
\end_layout

\begin_layout Enumerate
the Descendant combinator (denoted with a space)
\end_layout

\begin_layout Subsection
Adapting Selectors for Swing
\end_layout

\begin_layout Standard
By default, you can reference any Swing component class that is a member
 of the package 
\emph on
javax.swing
\emph default
 without qualifying it.
 Some examples include: JPanel, JLabel, and JButton.
\end_layout

\begin_layout Standard
Any component that is assignable from the referenced class name will be
 matched.
 That is, if you write a subclass of JLabel, and write a CSS rule like this:
\end_layout

\begin_layout LyX-Code
JLabel
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  background-color: blue;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The rule will apply to instances of the subclass as well (this is not true
 the other way around of course).
\end_layout

\begin_layout Standard
A parsing ambiguity arises if one wished to reference a fully-qualified
 class name in a selector.
 Let's say we had a rule such as:
\end_layout

\begin_layout LyX-Code
JLabel.special
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  background-color: blue;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
If the component type were referenced fully-qualified:
\end_layout

\begin_layout LyX-Code
javax.swing.JLabel.special
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  background-color: blue;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
It would be less clear (though not impossible to disambiguate) that we were
 referencing a component marked with a css class name.
 JMatter's CSS implementation therefore does not allow fully-qualified class
 names in selectors.
\end_layout

\begin_layout Standard
This CSS implementation adopts and leverages CSS3's namespaces (thanks to
 Tiago Silveira) module to resolve this issue.
 CSS3 namespaces were designed to resolve the issue of possibly clashing
 namespaces in different xml vocabularies.
\end_layout

\begin_layout Standard
To reference a type in a different package, you must define a namespace
 for it, like so:
\end_layout

\begin_layout LyX-Code
@namespace l2f com.l2fprod.common.swing
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
l2f|JOutlookBar
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  color: olive;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The two main items to note here are:
\end_layout

\begin_layout Enumerate
A @namespace css rule is defined and aliased as 
\emph on
l2f
\emph default
.
\end_layout

\begin_layout Enumerate
To reference a type selector in that namespace, concatenate the namespace
 id and type name with the vertical bar delimiter (|).
\end_layout

\begin_layout Subsection
Assigning Components CSS class names
\end_layout

\begin_layout Standard
On the web, components are given semantic style names by annotating them
 with an html attribute, as in: class=
\begin_inset Quotes erd
\end_inset

title
\begin_inset Quotes erd
\end_inset

.
 JMatter's CSS implementation provides an API method for assigning a css
 class name to a component:
\end_layout

\begin_layout LyX-Code
ComponentStyle.addClass(componentRef, "title");
\end_layout

\begin_layout Standard
Since components can have more than a single semantic class name, one can
 invoke the above method repeatedly.
 There's also a corresponding method for removing a class assignment:
\end_layout

\begin_layout LyX-Code
ComponentStyle.removeClass(componentRef, "title");
\end_layout

\begin_layout Standard
One can likewise assign an id to a component with:
\end_layout

\begin_layout LyX-Code
ComponentStyle.setIdent(componentRef, "btn103");
\end_layout

\begin_layout Standard
The above are all static methods.
\end_layout

\begin_layout Standard
Application developers needn't concern themselves with this because the
 work associated with defining style names and annotating a user interface
 is a part of the task of writing that user interface.
 In the case of JMatter, the user interface is already written and is already
 annotated.
 To customize the style of a JMatter application, all you need to concern
 yourself with (besides knowing what semantic names to reference) is editing
 the stylesheet itself.
\end_layout

\begin_layout Standard
You might however want to take a look at the Sympster demo application where
 a custom view for a type is written that leverages CSS.
\end_layout

\begin_layout Subsection
Values
\end_layout

\begin_layout Standard
Of the myriad of ways in which measures can be specified in CSS, JMatter
 supports only a subset:
\end_layout

\begin_layout Enumerate
Font sizes must be specified in pt's
\end_layout

\begin_layout Enumerate
Borders, margins, and padding must be specified in px's
\end_layout

\begin_layout Enumerate
Colors can be specified either using the sixteen predefined color names,
 the six-digit hex notation, or the shortened three-digit hex notation.
 The 
\emph on
rgb()
\emph default
 function is not supported at this time
\end_layout

\begin_layout Enumerate
Only the line styles 
\emph on
dotted
\emph default
, 
\emph on
dashed
\emph default
, and 
\emph on
solid
\emph default
 are supported at this time
\end_layout

\begin_layout Enumerate
Only the generic font family names 
\emph on
serif
\emph default
, 
\emph on
sans-serif
\emph default
, and 
\emph on
monospace
\emph default
 are supported at this time
\end_layout

\begin_layout Subsection
Properties
\end_layout

\begin_layout Standard
A subset of the CSS defined properties is supported at this time.
 They are:
\end_layout

\begin_layout LyX-Code

\size small
cursor
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
color
\end_layout

\begin_layout LyX-Code

\size small
background-color
\end_layout

\begin_layout LyX-Code

\size small
background-image
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
font-family
\end_layout

\begin_layout LyX-Code

\size small
font-size
\end_layout

\begin_layout LyX-Code

\size small
font-weight
\end_layout

\begin_layout LyX-Code

\size small
font-style
\end_layout

\begin_layout LyX-Code

\size small
font
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
border-color, border-left-color, border-right-color, border-top-color, border-bo
ttom-color
\end_layout

\begin_layout LyX-Code

\size small
border-style, border-left-style, border-right-style, border-top-style, border-bo
ttom-style
\end_layout

\begin_layout LyX-Code

\size small
border-width, border-left-width, border-right-width, border-top-width, border-bo
ttom-width
\end_layout

\begin_layout LyX-Code

\size small
border
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
margin, margin-left, margin-right, margin-top, margin-bottom
\end_layout

\begin_layout LyX-Code

\size small
padding, padding-left, padding-right, padding-top, padding-bottom
\end_layout

\begin_layout Standard
JMatter's CSS implementation also supports these CSS3 properties, but only
 on SwingX components that allow for the delegation of background painting:
\end_layout

\begin_layout LyX-Code

\size small
opacity
\end_layout

\begin_layout LyX-Code

\size small
border-radius
\end_layout

\begin_layout LyX-Code

\size small
border-top-left-radius, border-top-right-radius, 
\end_layout

\begin_layout LyX-Code

\size small
 border-bottom-left-radius, border-bottom-right-radius
\end_layout

\begin_layout Subsection
CSS Inheritance
\end_layout

\begin_layout Standard
It is important to mention that this engine supports CSS inheritance: that
 [inheritable] properties inherited from containing components are applied
 as well.
\end_layout

\begin_layout Section
The JMatter Stylesheet
\end_layout

\begin_layout Standard
Let's study the file 
\emph on
resources/styles.css
\emph default
 one piece at a time.
\end_layout

\begin_layout Standard
First comes an import declaration:
\end_layout

\begin_layout LyX-Code
@namespace jm com.u2d.view.swing
\end_layout

\begin_layout Standard
This allows me to reference custom components from JMatter's Swing view
 mechanism in selectors.
 Here are some examples:
\end_layout

\begin_layout LyX-Code
JDesktopPane
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  background-color: #7684FF;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
jm|FormPane
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  background-color: #fffaf0;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The first rule customizes the background color of the desktop pane.
 The selector matches a standard swing component.
 The second rule customizes the background color of form panes (using an
 off-beige color).
\end_layout

\begin_layout Standard
Here are two more rules:
\end_layout

\begin_layout LyX-Code
.command
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  font-style: italic;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
.default-button
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  font-weight: bold;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Views of commands in JMatter are annotated with the CSS class name 
\emph on
command
\emph default
.
 I have chosen to emphasize that commands are 
\emph on
active
\emph default
 by italicizing their views (views of commands are either JMenuItem's or
 JButton's).
\end_layout

\begin_layout Standard
Furthermore, Swing (and forms) has the notion of a single command being
 designated as the default command on a form.
 Default buttons are given a little extra attention, such as interpreting
 pressing of the 
\emph on
Enter
\emph default
 key on the form as implying the invocation of the default command.
 Here you can specify how its view should be styled.
\end_layout

\begin_layout Standard
Note how both rules 
\emph on
.command
\emph default
 and 
\emph on
.default-button
\emph default
 match for default commands so that their properties are combined.
 This CSS engine will make sure to apply the more specific rule in case
 of a conflict.
\end_layout

\begin_layout Standard
Here is a rule that styles the text in title views:
\end_layout

\begin_layout LyX-Code
.list-title, .instance-title
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  color: #400;
\end_layout

\begin_layout LyX-Code
  font-weight: bold;
\end_layout

\begin_layout LyX-Code
  font-size: 16pt;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We are applying the same set of declarations to both list titles and instance
 titles, so we grouped the selectors together.
\end_layout

\begin_layout Standard
Here are two more semantic styles:
\end_layout

\begin_layout LyX-Code
.required
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   color: blue;
\end_layout

\begin_layout LyX-Code
   font-weight: bold;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
.validation-msg
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   color: red;
\end_layout

\begin_layout LyX-Code
   font-style: italic;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Here we specify how to style the captions for required fields and validation
 error messages.
 Feel free to customize these (and any other styles) as you see fit.
\end_layout

\begin_layout Standard
And finally, this rule styles the large semi-transparent message panel that
 appears for 2-3 seconds to acknowledge various actions, for example when
 one creates and persists a new instance to database:
\end_layout

\begin_layout LyX-Code
.feedback-pane
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  color: white;
\end_layout

\begin_layout LyX-Code
  background-color: black;
\end_layout

\begin_layout LyX-Code
  font-size: 24pt;
\end_layout

\begin_layout LyX-Code
  font-weight: bold;
\end_layout

\begin_layout LyX-Code
  padding: 30px;
\end_layout

\begin_layout LyX-Code
  border-radius: 24px;
\end_layout

\begin_layout LyX-Code
  opacity: 0.7;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Styling JMatter UIs is now much more accessible thanks to CSS.
 Since CSS is a technology you might already be familiar with, and since
 this implementation adheres strictly to the specification (i.e.
 it doesn't invent its own properties), you should be able to jump in right
 away without a learning curve.
\end_layout

\begin_layout Subsection
The complete stylesheet
\end_layout

\begin_layout Standard
Below is a copy of the complete stylesheet, for reference.
\end_layout

\begin_layout LyX-Code
@namespace jm com.u2d.view.swing
\end_layout

\begin_layout LyX-Code
@namespace types com.u2d.view.swing.atom
\end_layout

\begin_layout LyX-Code
JDesktopPane
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  background-color: #7684FF;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
jm|FormPane
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  background-color: #fffaf0;
\end_layout

\begin_layout LyX-Code
  padding: 5px;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
.command
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  font-style: italic;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
.list-title, .instance-title, .title
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  color: #400;
\end_layout

\begin_layout LyX-Code
  font-weight: bold;
\end_layout

\begin_layout LyX-Code
  font-size: 16pt;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
.list-title-panel, .instance-title-panel
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
jm|FieldCaption
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  color: #2f4f4f;
\end_layout

\begin_layout LyX-Code
  font-weight: normal;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
.required
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  color: #483d8b;
\end_layout

\begin_layout LyX-Code
  font-weight: bold;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
.validation-msg
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   color: red;
\end_layout

\begin_layout LyX-Code
   font-style: italic;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
.default-button
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  font-weight: bold;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
.feedback-pane
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  color: white;
\end_layout

\begin_layout LyX-Code
  background-color: black;
\end_layout

\begin_layout LyX-Code
  font-size: 24pt;
\end_layout

\begin_layout LyX-Code
  font-weight: bold;
\end_layout

\begin_layout LyX-Code
  padding: 30px;
\end_layout

\begin_layout LyX-Code
  border-radius: 24px;
\end_layout

\begin_layout LyX-Code
  opacity: 0.7;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
#aboutPnl
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  margin: 5px;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
types|URIRenderer
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  cursor: pointer;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Using CSS4Swing in Standalone Swing Applications
\end_layout

\begin_layout Standard
The CSS engine used by JMatter was developed by Eitan Suez, for the purpose
 of enhancing JMatter.
 However, the implementation is agnostic to the JMatter framework, and can
 be used with any old Swing application.
\end_layout

\begin_layout Standard
That is, if you're working on a Swing-related project and wished you could
 style your application with CSS, well, now you can.
\end_layout

\begin_layout Standard
First you'll need to add these libraries to your classpath, which you'll
 find in 
\emph on
jmatter/lib/runtime/swingvm
\emph default
:
\end_layout

\begin_layout Enumerate
css4swing.jar
\end_layout

\begin_layout Enumerate
antlr-runtime-3.0.1.jar
\end_layout

\begin_layout Enumerate
swingx.jar
\end_layout

\begin_layout Standard
This chapter has already documented how to write stylesheets, and how to
 apply semantic style names or id's to various components.
\end_layout

\begin_layout Standard
The only other requirement is to insert this statement before you start
 building your Swing user interface:
\end_layout

\begin_layout LyX-Code
CSSEngine.initialize();
\end_layout

\begin_layout Standard
By default, the engine will look for the resource 
\emph on
styles.css
\emph default
 in your classpath.
 Alternatively, you can specify a different origin for your stylesheet with
 this method:
\end_layout

\begin_layout LyX-Code
CSSEngine.initialize(InputStream is);
\end_layout

\begin_layout Standard
Here is a sample class that provides a little more context, and a more complete
 illustration:
\end_layout

\begin_layout LyX-Code
package com.u2d.css4swing;
\end_layout

\begin_layout LyX-Code
import com.l2fprod.common.swing.JOutlookBar;
\end_layout

\begin_layout LyX-Code
import com.u2d.css4swing.style.ComponentStyle;
\end_layout

\begin_layout LyX-Code
import javax.swing.*;
\end_layout

\begin_layout LyX-Code
/**
\end_layout

\begin_layout LyX-Code
 * Created by IntelliJ IDEA.
\end_layout

\begin_layout LyX-Code
 * User: eitan
\end_layout

\begin_layout LyX-Code
 * Date: Jan 30, 2007
\end_layout

\begin_layout LyX-Code
 * Time: 11:48:24 AM
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
public class SampleTest
\end_layout

\begin_layout LyX-Code
      extends JPanel
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public SampleTest()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      JLabel label = new JLabel("Eitan is testing..");
\end_layout

\begin_layout LyX-Code
      ComponentStyle.addClass(label, "required");
\end_layout

\begin_layout LyX-Code
      add(label);
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
      JLabel lbl2 = new JLabel("Ident-Designated");
\end_layout

\begin_layout LyX-Code
      ComponentStyle.setIdent(lbl2, "theone");
\end_layout

\begin_layout LyX-Code
      add(lbl2);
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
      FieldCaption caption = new FieldCaption("A label subclass..");
\end_layout

\begin_layout LyX-Code
      add(caption);
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
      JButton button = new JButton("Button 1 (required)..");
\end_layout

\begin_layout LyX-Code
      ComponentStyle.addClass(button, "required");
\end_layout

\begin_layout LyX-Code
      add(button);
\end_layout

\begin_layout LyX-Code
      JButton button2 = new JButton("Button 2 (not required)..");
\end_layout

\begin_layout LyX-Code
      add(button2);
\end_layout

\begin_layout LyX-Code
      _bar = new JOutlookBar();
\end_layout

\begin_layout LyX-Code
      ComponentStyle.addClass(_bar, "left-sidebar");
\end_layout

\begin_layout LyX-Code
      _bar.addTab("Hello", new JLabel("Hi"));
\end_layout

\begin_layout LyX-Code
      _bar.addTab("Bye", new JLabel("Bye"));
\end_layout

\begin_layout LyX-Code
      add(_bar);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   JOutlookBar _bar;
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   public static void main(String[] args)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      CSSEngine.initialize();
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
      SwingUtilities.invokeLater(new Runnable()
\end_layout

\begin_layout LyX-Code
      {
\end_layout

\begin_layout LyX-Code
         public void run()
\end_layout

\begin_layout LyX-Code
         {
\end_layout

\begin_layout LyX-Code
            JFrame f = new JFrame();
\end_layout

\begin_layout LyX-Code
            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
\end_layout

\begin_layout LyX-Code
            SampleTest st = new SampleTest();
\end_layout

\begin_layout LyX-Code
            f.setContentPane(st);
\end_layout

\begin_layout LyX-Code
            f.setBounds(100,100,500,500);
\end_layout

\begin_layout LyX-Code
            f.setVisible(true);
\end_layout

\begin_layout LyX-Code
         }
\end_layout

\begin_layout LyX-Code
      });
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Section
Future Plans
\end_layout

\begin_layout Standard
Additional enhancements for CSS support in JMatter are planned.
 Here is a tentative list:
\end_layout

\begin_layout Enumerate
Produce multiple alternative stylesheets that can be used as themes to skin
 JMatter applications
\end_layout

\begin_layout Enumerate
Support all border line styles defined by the CSS specification
\end_layout

\begin_layout Enumerate
Complete support for color value syntax, including the 
\emph on
rgb()
\emph default
 function and the CSS3 
\emph on
rgba()
\emph default
 function for supporting transparency
\end_layout

\begin_layout Enumerate
Possibly adding support for CSS 
\emph on
@import
\emph default
 statements, as a simple 
\emph on
include
\emph default
 mechanism
\end_layout

\begin_layout Enumerate
Possibly adding support for applicable CSS pseudo classes and pseudo elements
\end_layout

\begin_layout Enumerate
Perhaps expose the ability to apply effects in a Swing application through
 CSS
\end_layout

\begin_layout Standard
If you produce a stylesheet that you find does a good job at styling the
 JMatter user interface, please consider contributing it back to the project
 as a JMatter theme.
\end_layout

\begin_layout Chapter
Deploying your Application
\begin_inset LatexCommand label
name "cha:Deploying-your-Application"

\end_inset


\end_layout

\begin_layout Standard
In this chapter we'll discuss how to setup your application for distribution
 with Sun's Java Web Start technology.
\end_layout

\begin_layout Section
JMatter Applications Architecture
\end_layout

\begin_layout Standard
We already know that JMatter applications rely on a database management
 system for storing information, performing queries, and more.
 The architecture of JMatter applications is simple and straightforward:
 JMatter applications are installed at end-user workstations, and communicate
 to the database that resides on the server.
 This architecture is known as a two-tier client-server architecture and
 is quite suitable for small multi-user applications (roughly up to 100
 users).
\end_layout

\begin_layout Standard
The dilemma is having to install and maintain JMatter applications on each
 client machine.
 This is where Java Web Start comes to the rescue.
\end_layout

\begin_layout Section
Java Web Start
\end_layout

\begin_layout Standard
The basic idea behind Java Web Start is to distribute your application using
 the world wide web.
 End users simply visit a web page and click on a link that triggers the
 automatic download and installation of the application to the end-user's
 computer.
 Java Web Start is bundled with every distribution of Java.
\end_layout

\begin_layout Standard
It gets even better: each time the end user launches the application, Java
 Web Start verifies whether any updates are available and will automatically
 download and install the updates prior to launching the application.
 So, not only is the distribution of your application automated but also
 its maintenance.
 You can read all about Java Web Start at 
\emph on
http://java.sun.com/products/javawebstart/
\end_layout

\begin_layout Standard
In our case, we'll be deploying applications within an intranet or extranet.
 Nevertheless, we'll be using web technologies to distribute and keep our
 client installations up to date.
\end_layout

\begin_layout Section
Deploying ContactMgr
\end_layout

\begin_layout Standard
JMatter provides an ant target for bundling your application for distribution
 via Java Web Start.
\end_layout

\begin_layout Standard
We first need to decide what web server to use to deploy our application.
 We'll need the machine's host name or ip address, and the port number (which
 typically will be 80).
 Enter these two bits of information into the file 
\emph on
project.properties
\emph default
 located in 
\emph on
resources/jws/dynamic
\end_layout

\begin_layout Standard
Second we need to ensure that the database connection url we specify in
 
\emph on
hibernate.properties
\emph default
 is not a relative url (such as 
\emph on
jdbc:postgresql://localhost/contactmgr
\emph default
); that url must be valid for all the end-user computers.
 We also need to ensure that no firewalls forbid communications traffic
 between the end-user machines and the database.
 Remember, JMatter was designed for workgroup applications: that is, for
 multiple users on a Local Area Network or a Virtual Private Network.
\end_layout

\begin_layout Standard
Ok, here's the magic ant target:
\end_layout

\begin_layout LyX-Code
ant jws-dist
\end_layout

\begin_layout Standard
When the target is finished running, it will have produced a 
\emph on
.war
\emph default
 file in the 
\emph on
dist
\emph default
 folder.
\end_layout

\begin_layout Standard
Create a directory with the same name as your project inside your web server's
 document root directory:
\end_layout

\begin_layout LyX-Code
sudo mkdir /var/www/ContactMgr
\end_layout

\begin_layout Standard
Extract the 
\emph on
war
\emph default
 file to that directory.
 This should do the trick:
\end_layout

\begin_layout LyX-Code
sudo unzip dist/ContactMgr.war -d /var/www/ContactMgr
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
We should now be ready to give our application a try.
 Sit at a client machine and visit the web page in question (perhaps http://loca
l-server/ContactMgr).
 You'll see a page that looks like figure 
\begin_inset LatexCommand ref
reference "cap:Java-Web-Start"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/JWS-1.png
	lyxscale 30
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:Java-Web-Start"

\end_inset

Java Web Start Launch Page
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Click on the link and Java Web Start will launch and begin downloading your
 application.
 Before permitting you to proceed, you will be prompted to accept the certificat
e used to sign the code (see figure 
\begin_inset LatexCommand ref
reference "cap:JWS-Security"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/JWS-2.png
	scale 60
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:JWS-Security"

\end_inset

Java Web Start Security Prompt
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This requires some explanation.
 Java Web Start will not run any code that is not signed with a code certificate.
 This is not 100% true.
 It is possible to customize the Java security policy on every client machine
 to allow locally deployed code to run.
 However this is not really a viable option as it completely defeats the
 original purpose of Java Web Start being a simple and easy way to deploy
 applications without having to perform modifications on each client machine.
\end_layout

\begin_layout Standard
So the code must be signed.
 By default JMatter will sign the codebase anonymously so as to allow the
 code to run.
 Java Web Start will prompt the end-user to allow the the application to
 launch.
 This is essentially the hand-off point.
 It is the place where you, the developer of the application, procure a
 valid code certificate and use it to sign the code base that you're deploying.
\end_layout

\begin_layout Standard
Enough discussion, go ahead and reply 
\emph on
Yes
\emph default
 to the prompt and watch the application launch.
 You can proceed by logging in to the application and interacting with it
 as you always have up to now.
\end_layout

\begin_layout Standard
That's basically it.
 That is, anyone in your organization can now visit the intranet web page
 for our Contact Manager and with a single click of the mouse they will
 have downloaded, installed, and run our Contact Manager application.
\end_layout

\begin_layout Section
Caveats
\end_layout

\begin_layout Standard
The process of accessing a database by nature is meant to be difficult as
 data security is of utmost importance.
 You need to make sure your database is configured to accept connections
 from the network, that the configuration does not leave any security holes
 (pass in an MD5 hash of the database user's password for logging in, for
 example).
 If Java Web Start fails during the launch process the first time you attempt
 to deploy your application, it is likely due to a connection timeout attempting
 to access the database.
 This would be a good time to take a moment and review your database documentati
on and your database settings.
\end_layout

\begin_layout Section
Security Options
\end_layout

\begin_layout Standard
The PostgresQL database can be configured to communicate with clients over
 SSL, providing secure communications between clients and the database server.
 This option is an interesting one because it allows us to consider the
 possibility of deploying a JMatter application to a limited number of concurren
t users over a wider geographic area.
\end_layout

\begin_layout Standard
Also, it's worth mentioning that H2 is a lightweight database that also
 supports SSL.
 In addition it supports encrypting the entire database.
\end_layout

\begin_layout Section
More About JWS
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "cap:JWS-MacClient"

\end_inset

 depicts a MacOSX client application launched via Java Web Start.
 The database server in this instance is a PostgresQL cluster running on
 a nearby Linux machine.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/JWS-3.png
	lyxscale 40
	scale 35

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "cap:JWS-MacClient"

\end_inset

Java Web Start - Launched Application on a MacOSX Client
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first time the application is launched, Java Web Start will be downloading
 and installing an entire application.
 So the first launch will be fairly slow; it might take 30 seconds.
 Subsequent launches will not require the download (only a quick check for
 updates against the server) and consequently will take considerably less
 time.
\end_layout

\begin_layout Standard
The hyperlink on the ContactMgr intranet page is only one way in which end
 users can launch their application.
 Java Web Start can be configured to place a shortcut for the application
 directly on the end user's desktop, for example.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
JMatter attempts to make the Java Web Start process as easy and painless
 as possible.
 Let's review what we just did:
\end_layout

\begin_layout Enumerate
We invoked the 
\emph on
ant jws-dist
\emph default
 target, and
\end_layout

\begin_layout Enumerate
extracted the generated 
\emph on
.war
\emph default
 file to the web server
\end_layout

\begin_layout Enumerate
Visited the web page and clicked on a link, which triggered Java Web Start
\end_layout

\begin_layout Standard
Anyone who's had to configure Java Web Start the 
\emph on
normal
\emph default
 way will certainly appreciate this.
\end_layout

\begin_layout Chapter
Deployment, Take II: The Application Browser
\begin_inset LatexCommand label
name "cha:Deployment,-Take-II:"

\end_inset


\end_layout

\begin_layout Standard
Deploying JMatter applications with Java WebStart works well enough.
 It's certainly what people term the 
\emph on
fat client
\emph default
 model, where the client application is quite sizable, in the order of 20
 Megabytes, primarily due to the large number of dependent libraries required
 to support the application.
\end_layout

\begin_layout Standard
The web model on the other hand is seen as a more lightweight approach,
 and termed the 
\emph on
thin client
\emph default
 model.
\end_layout

\begin_layout Standard
In a manner directly analogous to the web, JMatter now supports a 
\emph on
thin client
\emph default
 model for deploying your applications, thereby deriving the same set of
 benefits typically associated with web:
\end_layout

\begin_layout Itemize
Smaller downloads
\end_layout

\begin_layout Itemize
Dynamic application loading
\end_layout

\begin_layout Itemize
No installation required (just visit a URL)
\end_layout

\begin_layout Standard
Here is how it works.
 JMatter comes equipped with an application named the 
\emph on
Application Browser
\emph default
.
 You will find it in the base directory of the JMatter distribution.
 This application consists of a single model object: the 
\emph on
Application Bookmark
\emph default
.
 Roughly speaking, this application is to JMatter applications what the
 Firefox web browser is to web applications: it's an application that allows
 you to load applications by specifying or entering a URL.
\end_layout

\begin_layout Standard
The Application Browser can be packaged and deployed using the traditional
 Java WebStart mechanism, or perhaps through the more traditional mechanism
 of using an automated installer.
 By virtue of being implemented entirely in Java, this application is by
 definition cross-platform.
 It's worthwhile noting that the JMatter application browser is itself nothing
 but a standard JMatter application with a very simple model comprising
 a single entity: the Bookmark.
\end_layout

\begin_layout Section
How it works, by example
\end_layout

\begin_layout Standard
Allow me to illustrate how this deployment mechanism works by example: let's
 deploy the Sympster application.
 Here are the steps we need to follow:
\end_layout

\begin_layout Enumerate
Package the application
\end_layout

\begin_layout Enumerate
Copy the packaged application to a web server so it can be http-loaded
\end_layout

\begin_layout Enumerate
Launch the application browser
\end_layout

\begin_layout Enumerate
Specify the url for the application and launch the application
\end_layout

\begin_layout Standard
For the first task, you will find a new JMatter ant target named 
\emph on
jar-model
\emph default
 that will produce the packaged artifact.
 The output of this target is the file 
\emph on
dist/Sympster.jar
\emph default
 which consists strictly of the compiled object model and supporting classes
 (if any), the application resources and configuration files (images, class-list.
xml, hibernate mapping files, database connection setings, and spring configurat
ion files).
\end_layout

\begin_layout Standard
We can now upload the artifact to a web server, say for example, to the
 jmatter.org web site perhaps at the url: 
\emph on
http://jmatter.org/demo-apps/Sympster.jar
\end_layout

\begin_layout Standard
We now launch the application browser.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/app-browser.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
The JMatter Application Browser
\begin_inset LatexCommand label
name "fig:The-AppBrowser"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure 
\begin_inset LatexCommand ref
reference "fig:The-AppBrowser"

\end_inset

, we see that I've defined an application bookmark for the Sympster demo
 application that I've deployed to jmatter.org.
 I can now click on the 
\emph on
Launch
\emph default
 button to launch the application.
\end_layout

\begin_layout Standard
The jar file is downloaded, and class-loaded into the client application's
 virtual machine.
 The application configuration is read and the application is loaded.
 Its splash screen appears, and we are finally presented with a login dialog.
 Upon logging in, we see the Sympster application's class bar show up on
 the left hand side and we're ready to start using our application: perhaps
 defining new talks, creating a new session schedule for an upcoming symposium,
 etc..
\end_layout

\begin_layout Standard
When we're finished with our Sympster application session, we can either
 quit the application, or unload it (from the menu: 
\emph on
File -> Unload Application
\emph default
).
 The Application Browser re-appears, and we can choose to launch an entirely
 different application from a different URL.
\end_layout

\begin_layout Standard
The application model remains two-tier, with the application talking directly
 to its back-end database.
 But it is worthwhile at this time to examine the benefits of this method
 of deployment:
\end_layout

\begin_layout Itemize
We have turned a fat client into a thin client
\end_layout

\begin_layout Itemize
The size of our download has shrunk from 20MB to 80KB (it's worth stressing
 that many web 
\emph on
pages
\emph default
 today are larger than 80KB)
\end_layout

\begin_layout Itemize
No installation of Sympster was necessary
\end_layout

\begin_layout Itemize
Developers are free to work on enhanced versions of the application, drop
 a new copy on the web server, and thereby upgrading the application, in
 a manner that is transparent to clients (end users)
\end_layout

\begin_layout Section
Dealing with dependencies
\end_layout

\begin_layout Standard
The MyTunes demo application is a good example of an application that has
 dependencies on third party libraries that are not bundled with the Application
 Browser.
 How can we deploy MyTunes along with these necessary dependencies?
\end_layout

\begin_layout Standard
The answer turns out to be very simple.
 All that is necessary is to properly cite the dependencies in the jar file's
 manifest.
 Here is MyTune's ant target 
\emph on
jar-model
\emph default
:
\end_layout

\begin_layout LyX-Code
<target name="jar-model" description="jar just the model"
\end_layout

\begin_layout LyX-Code
        depends="clean,genhbm">
\end_layout

\begin_layout LyX-Code
   <jar file="${model-jar.file}">
\end_layout

\begin_layout LyX-Code
     <manifest>
\end_layout

\begin_layout LyX-Code
       <attribute name="Created-By" value="jMatter" />
\end_layout

\begin_layout LyX-Code
       <attribute name="Main-Class" value="${main.class}" />
\end_layout

\begin_layout LyX-Code
       <attribute name="Class-Path" value="JID3.jar jl1.0.jar" />
\end_layout

\begin_layout LyX-Code
     </manifest>
\end_layout

\begin_layout LyX-Code
     <fileset dir="${build.classes.dir}" includes="**/*" />
\end_layout

\begin_layout LyX-Code
   </jar>
\end_layout

\begin_layout LyX-Code
</target>
\end_layout

\begin_layout Standard
The interesting part here is how we've added the two libraries 
\emph on
JID3.jar
\emph default
 and 
\emph on
jl1.0.jar
\emph default
 (responsible for playing mp3's) using the jar manifest's Class-Path attribute.
 All we do next is make sure to put these libraries alongside 
\emph on
MyTunes.jar
\emph default
 on our web server.
 The rest is transparent: the associated jar files are fetched alongside
 the application.
 In this case our application is 300KB in size, counting the dependencies.
 Not bad for a music player.
\end_layout

\begin_layout Section
Looking Ahead
\end_layout

\begin_layout Standard
We're thinking about further enhancing the application browser to allow
 multiple applications to be loaded in separate tabs, in a manner similar
 to the way that web browsers today feature tabbed-browsing.
 We're also beginning to contemplate developing a way to run JMatter application
s using a three-tier model: by splitting the application logic between client
 and application server.
\end_layout

\begin_layout Chapter
Tooling
\end_layout

\begin_layout Standard
This chapter attempts to answer the question: are tools available specifically
 for assisting developers in writing JMatter applications?
\end_layout

\begin_layout Section
Reverse Engineering an Existing Schema
\begin_inset LatexCommand label
name "sec:Reverse-Engineer-Schema"

\end_inset


\end_layout

\begin_layout Standard
Jim Slack graciously contributed this code to the JMatter project.
 Here is a brief description of this tool from Jim:
\end_layout

\begin_layout Quote
I became very interested in JMatter after reading your book and playing
 around with the demos, but was disappointed in the lack of a way to use
 a legacy database.
 Therefore, I just finished writing a Java program that creates JMatter
 Java source files from a database.
 It seems to work fine, although using it is a bit tricky because it involves
 a few manual steps: run the program, update the schema, then run an SQL
 script.
 
\end_layout

\begin_layout Standard
So here are the instructions for how to use it.
\end_layout

\begin_layout Enumerate
Make a backup copy of your database
\end_layout

\begin_layout Enumerate
Create a new project as usual using the ant target 
\emph on
new-project-ui
\end_layout

\begin_layout Enumerate
Navigate (cd) to your newly-created project and edit the file 
\emph on
resources/hibernate.properties
\emph default
 to point to the database schema in question
\end_layout

\begin_layout Enumerate
Invoke the ant target 
\emph on
reveng-db
\emph default
 which stands for 
\emph on
Reverse Engineer Database
\emph default
.
 You have the option of specifying the name of the Java package that the
 generated source code will belong to with 
\emph on
-Dreveng-pkgname=my.pkg.name
\emph default
 (otherwise the code will default to 
\emph on
org.jmatter.app
\emph default
)
\end_layout

\begin_layout Enumerate
You can now invoke the 
\emph on
schema-update
\emph default
 target which will do two things:
\end_layout

\begin_deeper
\begin_layout Enumerate
it will invoke the 
\emph on
genhbm
\emph default
 target that will generate the hibernate mapping files from the generated
 source code; and
\end_layout

\begin_layout Enumerate
it will update the existing database schema to include 
\emph on
version
\emph default
 and 
\emph on
createdOn
\emph default
 columns and additional jmatter-specific tables
\end_layout

\end_deeper
\begin_layout Enumerate
At the present time, there's one other simple matter to address.
 JMatter does not deal well with null initial values for the 
\emph on
version
\emph default
 and 
\emph on
createdOn
\emph default
 columns.
 Step [4] above creates the sql script aptly named 
\emph on
reveng_update_script.sql
\emph default
 that you can manually invoke to rectify this issue.
 Here's an example of how I do this with postgreSQL:
\end_layout

\begin_layout LyX-Code
psql databasename
\end_layout

\begin_layout LyX-Code
$ 
\backslash
i reveng_update_script
\end_layout

\begin_layout LyX-Code
$ 
\backslash
q
\end_layout

\begin_layout Standard
That's it.
 You're now ready to either run your JMatter application and to layer behavior
 on to your existing application.
\end_layout

\begin_layout Standard
Jim: Thank you very much!
\end_layout

\begin_layout Section
IDEA Productivity Templates
\begin_inset LatexCommand label
name "sec:IDEA-Productivity-Templates"

\end_inset


\end_layout

\begin_layout Standard
I have developed a set of IntelliJ IDEA templates that constitutes a lightweight
 productivity solution for building JMatter apps.
 I can no longer write JMatter applications without them.
\end_layout

\begin_layout Standard
This tool is included with the JMatter distribution in 
\emph on
jmatter/tools/IDEA
\emph default
.
 Follow the instructions in the README file to install the templates into
 the IDE.
 The tool thus far consists of one basic file template and a number of live
 templates that can significantly assist the development of JMatter applications
 within IDEA.
\end_layout

\begin_layout Subsection
How it works
\end_layout

\begin_layout Standard
After creating a Java project, you can create basic JMatter model objects
 in a manner similar to the creation of new classes:
\end_layout

\begin_layout Enumerate
Select a package in the side bar
\end_layout

\begin_layout Enumerate
Right-click "New->ACO" (ACO stands for 
\emph on
AbstractComplexEObject
\emph default
)
\end_layout

\begin_layout Enumerate
Specify the class name
\end_layout

\begin_layout Standard
For example, for a class named 
\emph on
Car
\emph default
, this basic template will be created:
\end_layout

\begin_layout LyX-Code
package com.u2d.issuemgr;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.AbstractComplexEObject;
\end_layout

\begin_layout LyX-Code
import com.u2d.model.Title;
\end_layout

\begin_layout LyX-Code
import com.u2d.type.atom.StringEO;
\end_layout

\begin_layout LyX-Code
import com.u2d.persist.Persist;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@Persist
\end_layout

\begin_layout LyX-Code
public class Car extends AbstractComplexEObject
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   private final StringEO name = new StringEO();
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Car() {}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public StringEO getName()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return name;
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   public Title title()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      return name.title();
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
In the IDEA project settings, enter the "Live Templates" section.
 You can inspect the various live templates defined for jmatter under the
 "jmatter" tree node.
\end_layout

\begin_layout Standard
Some examples include:
\end_layout

\begin_layout LyX-Code
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features>
<column alignment="left" valignment="top" leftline="true" width="1in">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="3.5in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Key
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
fo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
expands to the metadata specification for 
\emph on
fieldOrder
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
flat
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
expands to the 
\emph on
flattenIntoParent
\emph default
 metadata specification
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
bprop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
will write the bound property getter and setter methods for you
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
tv
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
expands to specify the 
\emph on
tabViews
\emph default
 metadata
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
plu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
will write the 
\emph on
pluralName()
\emph default
 method to override the plural name for a type
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Ultraviolet and UMLC
\end_layout

\begin_layout Standard
Ultraviolet is a UML class editor.
 A copy is packaged with and integrated into JMatter.
 One way to launch it is by invoking the ultraviolet target from the framework
 build file:
\end_layout

\begin_layout LyX-Code
$ cd jmatter
\end_layout

\begin_layout LyX-Code
$ ant ultraviolet
\end_layout

\begin_layout Standard
See the accompanying screenshot of Ultraviolet in action.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/UltraViolet.jpg
	lyxscale 30
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Ultraviolet
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this editor, you can define the set of classes in your model and their
 interrelationships.
 One can specify associations, their cardinality, whether they're bidirectional.
 Much of JMatter's metadata can be specified directly via each class's property
 sheet: class name, plural name, icon, color code, fields, commands, as
 well as field and command metadata.
 One can also model inheritance.
\end_layout

\begin_layout Standard
Ultraviolet will generate a .umlc file for your model: a complete description
 of your model in the umlc language.
 Finally, the tool will automatically translate the model into a JMatter
 application.
 Technically, the only aspects of development that you do outside of Ultraviolet
 is the implementation of the commands.
\end_layout

\begin_layout Standard
This tool is inspiring and shows the power of domain-driven design and implement
ation.
 One can go from a simple idea to a model to a running application in minutes.
\end_layout

\begin_layout Standard
Both Ultraviolet and umlc were developed entirely by Ryan Ramage.
 This tool is open source and has its own home page: 
\begin_inset LatexCommand url
target "http://code.google.com/p/umlc/"

\end_inset

 and 
\begin_inset LatexCommand url
target "http://code.google.com/p/umlc/"

\end_inset

.
\end_layout

\begin_layout Chapter
The Power User
\end_layout

\begin_layout Standard
This chapter details features of JMatter applications' user interfaces,
 including many subtle features that aim to improve usability and users'
 productivity.
\end_layout

\begin_layout Section
Visual Command Interface
\end_layout

\begin_layout Standard
JMatter sports a feature inspired by blacktree software's 
\emph on
QuickSilver
\emph default
, and more recently, 
\emph on
Gnome Do
\emph default
.
 Briefly, these applications provide a visual command interface for desktops.
 For a desktop management application, most commands involve launching applicati
ons or bringing them up in the terminal or the file manager.
 The end user composes an instruction by first specifying the target application
 and second the specific command to invoke on that application.
 Its primary use is for launching applications.
 Applications are specified by typing, and identified via a text matching
 algorithm.
\end_layout

\begin_layout Standard
It turns out that these applications adhere to the noun-verb metaphor which
 is a strong part of JMatter's general philosophy.
 Every operation in JMatter boils down to the invocation of a command on
 a target object (and optionally specifying command arguments).
 JMatter's implementation of a visual command interface now provides an
 additional, alternative visual mechanism to invoke commands.
\end_layout

\begin_layout Standard
I will illustrate how this interface works with an example.
 Let's take the Sympster demonstration application.
 Let's say we wish to create a new speaker.
 We typically do this by right-clicking on the Speaker icon in the class
 bar (the visual representation of its type) and selecting the command 
\emph on
New
\emph default
 from its context menu.
 Now, you can also:
\end_layout

\begin_layout Enumerate
Press 
\emph on
Ctrl-I
\emph default
 (
\emph on
Cmd-I
\emph default
 on the mac) to invoke the visual command interface,
\end_layout

\begin_layout Enumerate
Type 
\emph on
Spe
\emph default
, press the tab key, and type 
\emph on
New
\end_layout

\begin_layout Enumerate
Press the 
\emph on
Enter
\emph default
 key
\end_layout

\begin_layout Standard
In step 2, we first search for the type 
\emph on
Speakers
\emph default
 by name, and then we search for the command named 
\emph on
New
\emph default
.
 We don't have to type the full name, just enough characters to match the
 item (the object) we're looking for.
 Optionally, you can press the down-arrow key to see other matches and select
 the appropriate one.
 The escape key dismisses the visual command interface.
 In the above case, invoking the command causes the visual command interface
 to auto-dismiss.
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:visual-cmd"

\end_inset

 shows JMatter's visual command interface in action.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename figures/visual-cmd-interface.png
	lyxscale 40
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
JMatter's visual command interface in action
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:visual-cmd"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Many desktop users have become habituated to this type of command interface
 and prefer it.
 First, this is a testament that noun-verb types of user interfaces are
 a good match for the way we tend to go about doing things.
 Second, it provides a uniform way of invoking any command.
 Finally, you don't have to take your fingers off of the keyboard.
\end_layout

\begin_layout Standard
This feature is built-in to JMatter.
 No work is necessary to enable it.
 You might however be interested in extending its capabilities further by
 extending its index, which we discuss next.
\end_layout

\begin_layout Subsection
Extending the Index
\end_layout

\begin_layout Standard
The visual command interface by default matches types.
 Match a target type, and then invoke a specific command on it, for example:
 
\emph on
Person Contacts -> Browse
\emph default
.
\end_layout

\begin_layout Standard
It would be nice however if we could interact with instances of a given
 type in addition.
 For example, with the contact manager, it'd be nice to match a contact
 by name directly from the visual command interface.
 Likewise, in MyTunes, it'd be nice to direclty match a song by title.
 In Sympster, 
\emph on
Speakers
\emph default
 and 
\emph on
Talks
\emph default
 are also good candidates.
\end_layout

\begin_layout Standard
The visual command interface provides a mechanism for you to add items to
 its index.
 The ContactMgr application has recently been enhanced to show you how.
 Here's how this is done..
\end_layout

\begin_layout Standard
First, we subclass 
\emph on
com.u2d.app.Application
\emph default
 and override the 
\emph on
postInitialize()
\emph default
 method:
\end_layout

\begin_layout LyX-Code
public class Application extends com.u2d.app.Application
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   public void postInitialize()
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
      super.postInitialize();
\end_layout

\begin_layout LyX-Code
      contributeToIndex(PersonContact.class);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The above call to 
\emph on
contributeToIndex()
\emph default
 instructs the visual interface to include contact instances in its index.
\end_layout

\begin_layout Standard
Next we need to revise our spring configuration file to specify our subclass
 as the application's 
\emph on
Application
\emph default
 bean.
 We edit the file 
\emph on
src/applicationContext.xml
\emph default
 as follows:
\end_layout

\begin_layout LyX-Code
 <bean id="application" class="com.u2d.contactmgr.Application">
\end_layout

\begin_layout LyX-Code
    <property name="name" value="Contact Manager" />
\end_layout

\begin_layout LyX-Code
    <property name="version" value="1.0" />
\end_layout

\begin_layout LyX-Code
    <property name="description" 
\end_layout

\begin_layout LyX-Code
              value="A simple contact manager" />
\end_layout

\begin_layout LyX-Code
    <property name="helpContentsUrl" 
\end_layout

\begin_layout LyX-Code
              value="http://jmatter.org/documentation/html/index.html" />
\end_layout

\begin_layout LyX-Code
    <property name="pagesize" value="15" />
\end_layout

\begin_layout LyX-Code
    <property name="persistenceMechanism" ref="persistor" />
\end_layout

\begin_layout LyX-Code
 </bean>
\end_layout

\begin_layout Standard
Notice how the bean's class above references our subclass.
 That's it.
 Now when we launch the contact manager, assuming we have a contact named
 
\emph on
John Doe
\emph default
, we can invoke the visual command interface, start typing 
\emph on
John
\emph default
 and the instance will be matched.
 We can then invoke any of a number of commands, for example 
\emph on
Open
\emph default
 or 
\emph on
Edit
\emph default
.
\end_layout

\begin_layout Section
Associations Made Easy
\begin_inset LatexCommand label
name "sec:Associations-Made-Easy"

\end_inset


\end_layout

\begin_layout Standard
NakedObjects originally introduced a terrific way to establish associations
 between objects in a user interface.
 It automatically enabled this via drag and drop.
\end_layout

\begin_layout Standard
For some reason, dnd in many ways is not used as much as it used to be.
 Having to take the hand off the keyboard is admittedly a "productivity
 mark deduction."
\end_layout

\begin_layout Standard
So, in JMatter, I set out to enable associations in more than one way.
 For starters, dnd works out of the box.
 But one can also click a "pick" button that will display a listing of entries
 of the type for a given association, that the user simply picks from.
\end_layout

\begin_layout Standard
Let's look at a concrete example: let's say we're working with the Symposium
 manager demo application in JMatter.
 And let's further say that we're defining a new talk to be given.
 Talks have a many-to-one association to the speaker (or presenter) giving
 the talk.
\end_layout

\begin_layout Standard
My favorite way of establishing that association is with the in-place associator
 widget that's built-in to JMatter.
 Here's how it works.
 When editing the talk, click (or tab into) the association field in question,
 which in this case is 
\emph on
Speaker
\emph default
.
 Simply start typing and a matching list of entries automatically appears.
 This component dynamically fetches matching entries from the database as
 you type.
 The matched items listing also pages by default, so for a scenario with
 too many matching entires, only the first page will be fetched.
 In my experience with this component, this is one of the fastest ways of
 making an association between two objects.
\end_layout

\begin_layout Standard
Here's a snapshot of me trying to define a new talk, *In Action*, as it
 were
\begin_inset Foot
status collapsed

\begin_layout Standard
Please pardon the sarcasm
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/associator.png
	lyxscale 30
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Associating a Speaker to a talk
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only detail to tend to is to specify which field of Speaker are we searching
 by.
 That's what that little magnifying glass icon to the left of the text field
 is for.
 It's a drop-down combobox that dynamically lists the various fields you
 might want to search by.
\end_layout

\begin_layout Standard
The default field that JMatter should use for searching in the context of
 in-place associations is controlled by the 
\emph on
defaultSearchPath
\emph default
 metadata, as shown by this example:
\end_layout

\begin_layout LyX-Code
public static String defaultSearchPath = "name.first";
\end_layout

\begin_layout Standard
See section 
\begin_inset LatexCommand ref
reference "sub:dflt-searchpath"

\end_inset

.
\end_layout

\begin_layout Section
Paging
\end_layout

\begin_layout Standard
We've all had to implement this feature as developers.
 Today, many frameworks such as Tapestry for example, will provide components
 out of the box that will automatically take care of paging a listing on
 your behalf.
\end_layout

\begin_layout Standard
JMatter also provides paging out of the box.
 When I sat down and started to think about this feature, I saw a certain
 pattern.
 One's first, naive implementation of paging might consist of a simple forward
 and back navigation buttons:
\end_layout

\begin_layout LyX-Code
< >
\end_layout

\begin_layout Standard
Shortly afterwards comes the request for the ability to navigate to the
 first and last page in a listing, and so the above evolves to:
\end_layout

\begin_layout LyX-Code
<< < > >>
\end_layout

\begin_layout Standard
Then embellished, like so:
\end_layout

\begin_layout LyX-Code
<< < [Page 3] > >>
\end_layout

\begin_layout Standard
Over time, paging has evolved to let you navigate to a number of pages in
 the vicinity of the current page:
\end_layout

\begin_layout LyX-Code
1 2 ..
 7 [Page 8] 9 ..
 13 14
\end_layout

\begin_layout Standard
This is what most web-based applications do today.
\end_layout

\begin_layout Standard
What I realized is that paging, taken to its eventual limit, is essentially
 embodied in the behaviour of a scrollbar.
 Most scrollbars provide continous scrolling.
 Whereas in the case of paging, the scrolling is discrete.
 The more pages there are, the less this discrete behaviour is apparent.
 What's nice about today's scrollbars is that their size is inversely proportion
al to the length of the list.
 The larger the list, the smaller they are.
 Scrollbars have the advantage of giving you more of a visual perspective
 of where you are in the list.
 And you can simply drag the scrollbutton to any location along its dimension.
\end_layout

\begin_layout Standard
JMatter's Swing-based view mechanism defines a view implementation: a component
 named PageScrollBar which extends Swing's JScrollBar, shown at the bottom
 of the following two-page listing:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/paging.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Paging a Conference's Sessions
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As usual, developers of JMatter applications need not concern themselves
 with this at all.
 It's bundled into the framework and it just works.
 If however you feel the need to customize the way this scrollbar looks
 or behaves, it's easy enough with a little Swing experience to make whatever
 enhancements or decorations one might have in mind.
\end_layout

\begin_layout Section
Expos
\end_layout

\begin_layout Standard
JMatter GUIs are inherently Object Oriented UIs.
 I like to make the analogy to our operating systems' desktops.
 There are a number of ways to make such UIs more effective.
 Sometimes I look to these desktop systems for ideas and features.
\end_layout

\begin_layout Standard
One such feature is Apple's 
\emph on
Expos
\emph default
 which has since also been copied by the 
\emph on
Compiz Fusion
\emph default
 project on Linux: the idea of scaling down and fanning out one's windows
 temporarily for the purpose of easily switching focus to a window that
 is otherwise hidden by other windows with a higher z-index.
 JMatter incorporates such a feature.
 Pressing the 
\emph on
F12
\emph default
 key invokes the 
\emph on
JExplose
\emph default
 
\begin_inset Foot
status collapsed

\begin_layout Standard
There's no typo here.
 The author of this tool is French; 
\emph on
explose
\emph default
 in French means 
\emph on
explode.
\end_layout

\end_inset

 feature which does precisely this.
 This option is also available form the desktop pane's context menu.
\end_layout

\begin_layout Section
Navigation
\end_layout

\begin_layout Subsection
Window Placement
\end_layout

\begin_layout Standard
JMatter takes a certain strategy relating to the placement of new windows
 (internal frames) in its Graphical User Interface.
\end_layout

\begin_layout Standard
I recall trying various window placement strategies and then realizing something
 I was doing as a user of my applications: after creating a new view, I'd
 quickly reach for the window's title bar and place the window where I really
 wanted it.
 I don't think there's an algorithm for guessing the user's intent.
 So I started thinking about what might the next best thing be.
\end_layout

\begin_layout Standard
The strategy was to minimize the amount of work one has to do in moving
 the resulting window.
 What I do is place new windows such that their title bars are near the
 current mouse cursor location, thus minimizing the distance one would have
 to move their mouse to reach for it.
\end_layout

\begin_layout Standard
There's a somewhat hidden feature in JMatter which I very much like and
 that I'd like to share.
 This feature takes things one step further: it automatically puts the newly
 created window in placement mode.
 Allow me to explain..
\end_layout

\begin_layout Standard
This feature requires pressing a metakey to communicate your intent to use
 it: when you're about to invoke a command that creates a new view (e.g.
 the 
\emph on
Open
\emph default
 command) , hold down the 
\emph on
Control
\emph default
 key (on the mac, use the 
\emph on
Command
\emph default
 key).
\end_layout

\begin_layout Standard
The resulting window automatically "binds" to your mouse location.
 That is, it will follow your mouse.
 So, the way it works is you invoke the command with the 
\emph on
Control
\emph default
 key pressed and the new view is created, but it starts following your mouse
 around.
 Once you've found that ideal spot, a single left-click is all you need
 to do to pin it back down onto the desktop.
\end_layout

\begin_layout Subsection
New View Placement Options
\end_layout

\begin_layout Standard
Another feature of desktop systems, one that has been around for some time,
 and is specifically related to the file manager, is the idea of giving
 users options in terms of how to place newly-created views.
 When navigating a folder hierarchy, one can double-click on a folder, which
 typically opens a new window with the contents of that folder.
 Long ago, on ms-windows I recall always turning on the option "re-use existing
 window"; that is, replacing the existing view with the new one.
 This can really help with an otherwise rapid proliferation of windows on
 one's desktop.
\end_layout

\begin_layout Standard
Separately, the mozilla project introduced us to another navigation option:
 tabbed browsing, which is a sort of "middle of the road" approach: don't
 create a new window, but don't replace the existing view either.
 Since then, we've seen other applications, such as shell terminals, copy
 this handy feature.
\end_layout

\begin_layout Standard
JMatter now supports both modes of navitgation.
 A User's default browsing preferences can be specified through the 
\emph on
User
\emph default
 model object, which has an aggregate property named 
\emph on
Preferences
\emph default
.
 Its first and only option at the moment captures how a user generally prefers
 to navigate in JMatter: should new views be created by default:
\end_layout

\begin_layout Enumerate
in a new window?
\end_layout

\begin_layout Enumerate
in a new tab?
\end_layout

\begin_layout Enumerate
in-place, replacing the existing view?
\end_layout

\begin_layout Standard
Setting your preference is all it takes to change JMatter's default navigation
 behavior.
\end_layout

\begin_layout Standard
In many situations there may be exceptions to the default rule.
 Say, for example, that we wish to open a new view in a new tab even though
 the default setting is in-place navigation.
 To accommodate this, a new gesture has been introduced in JMatter: holding
 down the 
\emph on
Shift
\emph default
 key while invoking a command that produces a new view will cause a context
 menu to appear at the mouse location, for selecting how to create the new
 view.
 The choices again are the above three: in a new window, tab, or in-place.
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:nav1"

\end_inset

 captures the invocation of the 
\emph on
Open
\emph default
 command while holding down the 
\emph on
Shift
\emph default
 key.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/nav1.png
	lyxscale 30
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Invoking the Open command, holding down the Shift key
\begin_inset LatexCommand label
name "fig:nav1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:nav2"

\end_inset

 shows the navigation option pop up.
 I selected the 
\emph on
in new tab
\emph default
 option.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/nav2.png
	lyxscale 30
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Open in new tab
\begin_inset Quotes erd
\end_inset

 Option
\begin_inset LatexCommand label
name "fig:nav2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next figure shows the result of the view created in a new tab.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/nav3.png
	lyxscale 30
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Resulting View
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, this last screenshot shows that, with tabs, you have the option
 of detaching the view onto its own window or closing the tab (
\emph on
Ctrl+w
\emph default
 is the corresponding key binding).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/nav4.png
	lyxscale 30
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Tab Detach Option
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I believe this to be an important feature, finally producing a desktop with
 a number of effective navigation instruments:
\end_layout

\begin_layout Enumerate
Fundamentally an OOUI
\end_layout

\begin_layout Enumerate
DnD support
\end_layout

\begin_layout Enumerate
An expos-like feature
\end_layout

\begin_layout Enumerate
Tabbed, In-Place, or New-window view placement
\end_layout

\begin_layout Standard
Another complementary feature that is contemplated for JMatter is support
 for docking views.
 I have looked at flexdock, which is a terrific effort.
 But I'm looking for something that is more transparent: effectively a layout
 manager designed for JDesktopPane that transparently provides docking support.
 Let me know what you recommend.
\end_layout

\begin_layout Section
Copy and Paste
\end_layout

\begin_layout Standard
Every Swing application gets for free the ability to use the underlying
 platform's copy and paste capabilities when working with 
\emph on
JTextField
\emph default
s and 
\emph on
JTextArea
\emph default
s.
\end_layout

\begin_layout Standard
In JMatter you might have noticed that instances also sport their own Copy/Paste
 commands.
 You'll find this feature to be a little more powerful and interesting compared
 to the basic clipboard copy/paste feature.
\end_layout

\begin_layout Standard
The main difference is that unlike the clipboard, where you get one temporary
 area to copy to, JMatter provides a temporary "buffer" area for every distinct
 type.
\end_layout

\begin_layout Standard
So, for example in the Contact Manager demo application, I can go about
 and copy an Address here, a Contact object there, or an entire Person instance
 and all three copies exist in memory simultaneously, each in its own buffer.
 I can then, say, create a new Person instance and right-click "Paste" on
 the title view for the new instance.
 All of the information is copied over.
 This use case may not be very interesting or real.
\end_layout

\begin_layout Standard
But there are other situations.
 Take for example how a Person has a Contact property modeled using composition
 (or aggregation).
 Each instance has its own copy.
 Yet it's very possible for two persons to have the same contact information,
 or perhaps the same address, with the very real possibility that the two
 copies will change/diverge over time.
\end_layout

\begin_layout Standard
The copy/paste commands on instances are automatically placed by JMatter
 in a number of context menus for a number of views.
 You'll find these commands in the title view's context menu, as shown below.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/copy_on_instance_title_view.png
	lyxscale 30
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Copy on Instance Title View
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You'll also find it on aggregate objects' nodes as shown in figure 
\begin_inset LatexCommand ref
reference "fig:copypage2"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/copy_on_aggregate_node_view.png
	lyxscale 30
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Copy on Aggregate Node View
\begin_inset LatexCommand label
name "fig:copypage2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, you'll find it on the context menus for individual tab title views,
 as shown here:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/copy_on_tabtitle.png
	lyxscale 30
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Copy on Tab Title View
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This feature can come in handy and save repetitive data entry tasks, where
 one might otherwise be forced to invoke copy/paste individually on atomic
 fields.
 
\end_layout

\begin_layout Section
The 
\emph on
Restore Desktop
\emph default
 Feature
\end_layout

\begin_layout Standard
One last feature, though not completely polished, is worth mentioning.
 JMatter saves and restores end users' desktops between sessions.
\end_layout

\begin_layout Standard
That is, the size and positions and other information about open windows
 is recorded and stored to the database when one logs out or quits the applicati
on.
 Conversely an attempt is made to restore these views on login.
 What's nice about saving this information to database is that one's desktop
 configuration is independent of the workstation you log in to.
 Instead it's tied to your user information in the database.
\end_layout

\begin_layout Standard
This feature is at the moment fairly simple.
 Other than restoring the main window bounds and simple child windows (lists
 and instances), it does not yet properly restore other types of views at
 the moment.
\end_layout

\begin_layout Chapter
Summary
\end_layout

\begin_layout Standard
JMatter is a framework for building software applications that embrace the
 notion of domain-driven design: that the essence of a software application
 is the translation of domain knowledge into code; the modeling of the domain
 into a set of entities with interrelationships.
 Briefly: many of of those things that Eric Evans discusses in his book
 Domain-Driven Design 
\begin_inset LatexCommand cite
key "Evans"

\end_inset

.
 But this framework does more than embrace these ideas: it is a vehicle
 for implementing domain-driven applications today.
 The JMatter codebase constitutes a robust and generic implementation of
 all of the layers of a software application to support a given domain.
 This is an extremely agile proposition.
 In this short book alone, we managed to develop four fully-featured and
 distinct software applications.
\end_layout

\begin_layout Standard
How such agility is achieved can be described succinctly as follows:
\end_layout

\begin_layout Quote
By implementing all application services (search, forms, authorization,
 persistence, ui, etc..) generically, in a fashion decoupled from any one
 specific domain model, these implementations are free to be reused across
 domains.
\end_layout

\begin_layout Standard
The consequences of this reuse are dramatic:
\end_layout

\begin_layout Itemize
large time savings
\end_layout

\begin_layout Itemize
an application's codebase shrinks dramatically and becomes manageable
\end_layout

\begin_layout Itemize
there's a clean separation between application development and infrastructure
 development
\end_layout

\begin_layout Itemize
consistent, high-quality applications
\end_layout

\begin_layout Standard
This model of development puts into question certain rules about software
 development that up until now we'd assumed to be a given, namely:
\end_layout

\begin_layout Quote
that the cost of making a change to a software system late in the life of
 a software project is much higher; or conversely that it's cheaper to implement
 changes early on, when less software has been built upon requirements that
 may change.
\end_layout

\begin_layout Standard
The above rule inherently assumes that much of an application's codebase
 is coupled to requirements, so that when the requirements change, a lot
 of code will have to be thrown away and rewritten:
\end_layout

\begin_layout Itemize
GUI forms will have to be revised to reflect a new field
\end_layout

\begin_layout Itemize
There will undoubtedly be ripple effects to the database schema
\end_layout

\begin_layout Itemize
Queries will have to be revised to take a new field into account
\end_layout

\begin_layout Itemize
The authorization system will have to be updated because a new action was
 introduced
\end_layout

\begin_layout Standard
And the list goes on.
 The entire application has to be retrofitted to take the change into account.
\end_layout

\begin_layout Standard
In JMatter the repercussions are kept to a bare minimum: the database schema
 derives from the domain model, as does the user interface, and the authorizatio
n system, and the search system, and so on..
 All reflect the domain model.
\end_layout

\begin_layout Section
Looking Forward
\end_layout

\begin_layout Standard
What technologies to base a project on is always a difficult choice, and
 a moving target.
 For example, Java is used in many environments today, but we see a desire
 to move to languages such as Scala, Groovy, and Ruby.
 On the other hand, new languages may have less mature code libraries, and
 involve a certain risk.
\end_layout

\begin_layout Standard
JMatter strikes a great balance in its choice of technologies.
 It's a reality today; it's built upon a mature platform, a stable set of
 libraries, Hibernate being one example.
\end_layout

\begin_layout Standard
Looking forward, we will likely be exploring new languages for the JVM such
 as Scala, Groovy, and JRuby.
\end_layout

\begin_layout Standard
These languages will bring about tangible benefits:
\end_layout

\begin_layout Itemize
Traits (also known as mixins) are a powerful and missing feature (from Java)
 that will provide more flexibility in modeling.
 Internally, in terms of JMatter's own implementation, it will help streamline
 the implementation even further.
\end_layout

\begin_layout Itemize
The functional programming traits of some of these languages promise to
 bring about improvements in performance via lazy loading, and in thread
 safety via immutability.
\end_layout

\begin_layout Itemize
Powerful metaobject programming facilities, and the very designs of these
 languages promise to provide the necessary tools to evolve how domains
 are specified into a full-fledged domain-specific language.
\end_layout

\begin_layout Standard
As one small, concrete example, the Scala language defines the notion of
 a value object via the built-in primitive 
\emph on
val
\emph default
.
 Much redundancy in specifying a domain model can be done away with.
 You are likely to start seeing JMatter move in the direction of such languages
 in the coming years.
\end_layout

\begin_layout Chapter
\start_of_appendix
Keyboard Shortcuts
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="2">
<features islongtable="true">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="3.5in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
ShortCut
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Alt-`
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Analogous to the alt-tab mechanism for switching between windows on your
 desktop
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Alt-1, Alt-2, etc..
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
In a window with multiple tabs, switch to the first, second, [etc..] tab
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Ctrl-w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Closes the currently focused window
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Ctrl-n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
When a view of a listing is in focus, a shortcut for the command 
\emph on
New
\emph default
 on the listing's elements type.
 For example, if viewing a listing of Persons, instead of right-clicking
 
\emph on
New
\emph default
 in the titlebar, just press Ctrl-n
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Ctrl-f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
A shortcut that is active in listings, that places the focus on the search
 field
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
F12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Invokes 
\emph on
JExplose
\emph default
, a feature similar to Apple's 
\emph on
Expos,
\emph default
 that will automatically scale and sort all of the windows on your desktop
 in order to facilitate the selection and management of multiple windows.
 This feature can also be invoked from the Desktop's context menu (right-click
 on an empty spot on your desktop to bring up this menu).
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Ctrl-command
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
When invoking a command that generates a view window: if you find yourself
 frequently repositioning the generated window, then this shortcut is for
 you.
 By holding down the Ctrl key while invoking the command (either clicking
 on the button or right-clicking on a context menu item), then the generated
 window will be bound to your mouse: it will follow your mouse's movements.
 When you find the ideal place to position the newly-created window, just
 click with your mouse to 
\emph on
pin
\emph default
 it down into place.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Shift-Command
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
When invoking a command that generates a view, holding down the Shift key
 at the same time will prompt how you'd like the new view generated: in
 a new window, a new tab, or in place (i.e.
 replacing current view).
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Shift-Click
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Click on a JMatter internal window while holding down the shift key to move
 or drag the window about.
 This is the same as dragging the titlebar to move the window, but gives
 you a much larger surface area to work with.
 This feature is the same as the well-known alt-click on linux desktops.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Ctrl-Scrollwheel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
In the context of a calendar window, can change the resolution of the calendar
 cells from one minute to one hour using this gesture (for either day view
 and week view).
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Alt-/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Focus on selected item in Class Bar
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Ctrl-/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Open currently selected view's context menu.
 A keyboard equivalent for right-clicking.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Ctrl-I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Invoke JMatter's visual command interface (similar to quicksilver or gnome-do)
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Ctrl-q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Quit the application
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Chapter
Database Setup
\begin_inset LatexCommand label
name "cha:Database-Setup"

\end_inset


\end_layout

\begin_layout Standard
The JMatter framework taps the power of database systems.
 JMatter employs the excellent 
\emph on
Hibernate
\emph default
 
\begin_inset Quotes eld
\end_inset

O/R Mapping
\begin_inset Quotes erd
\end_inset

 framework which affords it database independence.
 That is, you're not constrained to using a specific database system.
 Options include PostgresQL, MySQL, Oracle, DB2, Sybase, Informix, SAP DB,
 and many more.
\end_layout

\begin_layout Standard
JMatter is tested primarily with PostgresQL and H2 (see 
\begin_inset LatexCommand htmlurl
target "http://www.h2database.org/"

\end_inset

), and has been verified to work with Oracle and MySQL.
\end_layout

\begin_layout Standard
We recommend either H2: a full-featured, minimal administration, fast, Java-impl
emented database, or PostgresQL: a mature, stable and open source database.
\end_layout

\begin_layout Standard
The JMatter distribution pre-bundles JDBC drivers for PostgreSQL, MySQL,
 and H2 and hsqldb.
 If you choose to use a different database vendor, you will need to obtain
 the corresponding JDBC driver jar file and place it in the 
\emph on
jmatter/lib/runtime/jdbc
\emph default
 directory.
\end_layout

\begin_layout Section
Configuring your own database for the ContactMgr Tutorial Application
\begin_inset OptArg
status open

\begin_layout Standard
Configuring your own database
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Create a Database
\begin_inset LatexCommand label
name "sub:Create-a-Database"

\end_inset


\end_layout

\begin_layout Standard
We'll use PostgresQL as an example.
\end_layout

\begin_layout Standard
To create a database in PostgresQL, invoke a command similar to this one:
\end_layout

\begin_layout LyX-Code
$ createdb -U postgres contactmgr
\end_layout

\begin_layout Standard
The -U flag is used to specify the name of the user who is creating the
 database.
 The username you should use depends on your specific installation (consult
 the PostgresQL documentation).
\end_layout

\begin_layout Standard
You might also want to create a user specifically for this application
\begin_inset Foot
status collapsed

\begin_layout Standard
Both 
\emph on
createdb
\emph default
 and 
\emph on
createuser
\emph default
 are programs that come with PostgresQL
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
$ createuser -U postgres contactmgr
\end_layout

\begin_layout Subsection
Specify the Database Connection Information
\begin_inset LatexCommand label
name "sub:Specify-DB-ConnInfo"

\end_inset


\end_layout

\begin_layout Standard
Make sure that you're in the 
\emph on
ContactMgr
\emph default
 folder before proceeding.
 Edit the file 
\emph on
resources/hibernate.properties
\emph default
.
 Modify these three lines accordingly
\begin_inset Foot
status collapsed

\begin_layout Standard
Let's assume for now that the database will reside on the same machine as
 your application.
 
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
hibernate.connection.url=jdbc:postgresql://localhost/contactmgr
\end_layout

\begin_layout LyX-Code
hibernate.connection.username=contactmgr
\end_layout

\begin_layout LyX-Code
hibernate.connection.password=
\end_layout

\begin_layout Standard
If you're using a database other than PostgresQL, you'll also need to revise
 these two lines:
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
hibernate.connection.driver_class=org.postgresql.Driver
\end_layout

\begin_layout LyX-Code
hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
\end_layout

\begin_layout Standard
Save the file.
\end_layout

\begin_layout Subsection
Generate the Database Schema
\end_layout

\begin_layout Standard
From the 
\emph on
ContactMgr
\emph default
 base directory, invoke this command:
\end_layout

\begin_layout LyX-Code
$ ant schema-export
\end_layout

\begin_layout Subsection
Browsing the database schema with psql
\end_layout

\begin_layout LyX-Code
$ psql contactmgr
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
contactmgr=> 
\backslash
dt
\end_layout

\begin_layout LyX-Code
                 List of relations
\end_layout

\begin_layout LyX-Code
 Schema |        Name         | Type  |   Owner
\end_layout

\begin_layout LyX-Code
--------+---------------------+-------+------------
\end_layout

\begin_layout LyX-Code
 public | business            | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | commandrestriction  | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | complextype         | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | compositequery      | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | contactmethod       | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | fieldrestriction    | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | folder              | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | folder_items        | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | loggedevent         | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | person              | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | queryspecifications | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | restriction         | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | role                | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | users               | table | contactmgr
\end_layout

\begin_layout LyX-Code
 public | usstate             | table | contactmgr
\end_layout

\begin_layout LyX-Code
(15 rows)
\end_layout

\begin_layout Chapter
Working from the Subversion Repository
\end_layout

\begin_layout Standard

\emph on
Credits: this appendix is an adaptation of a document written and volunteered
 by JMatter user 
\begin_inset Quotes eld
\end_inset

pyramid
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Checking out the code
\end_layout

\begin_layout Standard
The JMatter subversion repository is located at 
\begin_inset LatexCommand url
target "http://svn.jmatter.org/"

\end_inset

.
\end_layout

\begin_layout Standard
Checking out the code from the HEAD of the repository:
\end_layout

\begin_layout LyX-Code
svn checkout http://svn.jmatter.org/jmatter-complet/trunk jmatter-complet
\end_layout

\begin_layout Standard
To check out a specific release, look for the specific release tag name
 at:
\end_layout

\begin_layout LyX-Code
http://svn.jmatter.org/jmatter-complet/tags/
\end_layout

\begin_layout Standard
Then issue the checkout command, as illustrated by this example:
\end_layout

\begin_layout LyX-Code
svn checkout http://svn.jmatter.org/jmatter-complet/tags/Release-20060825
 
\end_layout

\begin_layout LyX-Code
                                jm_20060825release
\end_layout

\begin_layout Section
Directory Structure, Compiling, Running demo applications
\end_layout

\begin_layout Standard
The base directory is divided into two principal sections: the framework
 itself (located in directory 
\emph on
jmatter
\emph default
) and the demo applications (located in 
\emph on
demo-apps
\emph default
): ContactMgr, MyTunes, Sympster, MovieLib, and IssueMgr.
\end_layout

\begin_layout Standard
To build the framework jar file 
\emph on
dist/jmatter.jar
\emph default
, invoke:
\end_layout

\begin_layout LyX-Code
cd jmatter
\end_layout

\begin_layout LyX-Code
ant
\end_layout

\begin_layout Standard
To run a demo application, say the 
\emph on
ContactMgr
\emph default
 demo application:
\end_layout

\begin_layout LyX-Code
cd demo-apps/ContactMgr
\end_layout

\begin_layout LyX-Code
and schema-export
\end_layout

\begin_layout LyX-Code
ant run
\end_layout

\begin_layout Standard
Every demo application is built and run this way.
 These instructions are in accordance with the way any JMatter project is
 compiled and run.
\end_layout

\begin_layout Standard
All the demo applications should be preconfigured to use a local, file-based
 H2 database.
 If per chance it is not, then simply edit the file 
\emph on
resources/hibernate.properties
\emph default
.
 This file lists sample connection information for a variety of databases,
 including hsql, H2, postgresql, MySQL, and OracleXE.
 Uncomment the one you want and make sure the jdbc url and credentials are
 valid and you're ready to go.
\end_layout

\begin_layout Standard
To automate the manual step of exporting your schema, add this hibernate
 property:
\end_layout

\begin_layout LyX-Code
hibernate.hbm2ddl.auto=create
\end_layout

\begin_layout Chapter
Online Articles on JMatter
\end_layout

\begin_layout Itemize
Eitan Suez.
 
\emph on

\begin_inset LatexCommand htmlurl
name "Extreme Agility with jMatter"
target "http://www.clientjava.com/blog/2006/07/03/1151937901773.html"

\end_inset

.

\emph default
 June 2006.
\end_layout

\begin_layout Itemize
Eitan Suez.
 
\begin_inset LatexCommand htmlurl
name "What's the matter with JMatter?"
target "http://www.onjava.com/pub/a/onjava/2007/08/16/whats-the-matter-with-jmatter.html"

\end_inset

.
 August 2007.
\end_layout

\begin_layout Itemize
Andres Almiray.
 
\begin_inset LatexCommand htmlurl
name "Interview with Eitan Suez, creator of JMatter framework"
target "http://java.dzone.com/news/interview-eitan-suez-creator-j"

\end_inset

February 2008.
\end_layout

\begin_layout Chapter
FAQ
\end_layout

\begin_layout Standard
This FAQ will be expanded in future versions of this documentation.
\end_layout

\begin_layout Enumerate
How do I customize my application's name in the main window's title bar?
\end_layout

\begin_deeper
\begin_layout Enumerate
Edit the file 
\emph on
src/applicationContext.xml
\emph default
 and look for a comment labeled 
\begin_inset Quotes eld
\end_inset

TODO: Customize App Name Here
\begin_inset Quotes erd
\end_inset

.
 This is also the place where you customize the page size of listings in
 the user interface (the default is 15).
\end_layout

\end_deeper
\begin_layout Enumerate
How do I add or remove a command to all my model objects regardless of type?
\end_layout

\begin_deeper
\begin_layout Enumerate
The base class for all JMatter model objects is 
\emph on
AbstractComplexEObject
\emph default
.
 When JMatter introspects commands, it recurses up the type's inheritance
 hierarchy.
 To add a command to all model objects, edit 
\emph on
AbstractComplexEObject
\emph default
 and add a new command like you would any model object (marked with the
 
\emph on
@Cmd
\emph default
 annotation).
 Likewise, to remove an existing command, say for example the 
\begin_inset Quotes eld
\end_inset

Export to XML
\begin_inset Quotes erd
\end_inset

 command, simply comment out or remove the 
\emph on
@Cmd
\emph default
 annotation on the corresponding method.
\end_layout

\end_deeper
\begin_layout Chapter
Contributing to this project
\end_layout

\begin_layout Standard
Here are few ways in which you can help this project succeed:
\end_layout

\begin_layout Enumerate
Use JMatter
\end_layout

\begin_layout Enumerate
Spread the word
\end_layout

\begin_layout Enumerate
Consider buying a print copy of this book from 
\emph on
lulu.com
\emph default
 (follow the link from the jmatter.org web site).
 A fraction of the price of the book goes back to the developers.
\end_layout

\begin_layout Enumerate
If you're in the business of developing commercial software solutions, buy
 a license of JMatter.
 Or get your company to purchase licenses.
 These licenses are priced ridiculously low (I've estimated that the break-even
 point for JMatter is approximately one week into your first project) and
 are royalty-free.
\end_layout

\begin_layout Enumerate
Join the mailing list! Discuss features, suggest design improvements, become
 a part of our community
\end_layout

\begin_layout Enumerate
If you're a software developer, contribute bug fixes, features, enhancements
\end_layout

\begin_layout Enumerate
Donate directly (see 
\begin_inset LatexCommand url
target "http://jmatter.org/pages/donate"

\end_inset

)
\end_layout

\begin_layout Chapter
A Desktop within a Desktop?
\end_layout

\begin_layout Standard
One cannot help making the observation that the applications we're developing
 are desktop-like in nature.
 We end up having a desktop running within a operating system's desktop.
 The features of our applications' desktops are in many ways a replication
 of the features already built into our operating systems.
 The main difference being that instead of managing files and folders, we're
 in a sense extending the desktop to allow for the management of business
 objects, in any combination we choose.
 When we wrote our contact manager, that combination happens to consist
 of persons and businesses, for example.
\end_layout

\begin_layout Section
Dreaming of a Better 
\emph on
Virtual
\emph default
 World
\end_layout

\begin_layout Standard
The state of operating systems today looks all charming and wonderful.
 Take for example the new MacOS reborn in v10.0.
 Beautiful graphics, colors, lots of applications we can run.
 On the surface, it all looks and feels like a virtual garden of eden.
\end_layout

\begin_layout Standard
I see a much colder, harsher landscape.
 I see a landscape of islands of processes that communicate with one another
 hardly ever.
 If they do, it's via messages in a bottle.
 One of the few ways for such applications to talk to one another is via
 the clipboard.
 You copy (or drag) some text or maybe an image from one application and
 paste it (or drop it) onto another.
 That's essentially the extent to which applications can communicate in
 an ad-hoc basis.
\end_layout

\begin_layout Standard
Let's go a little further though.
 Let's think about the code required to implement an email application,
 a web browser, a word processor, our finance application, etc..
 Each application must fend for itself: each one has to build its own search
 features, its own mechanism for persisting information, its own user interface,
 its own mechanism for calendaring, for validating information, etc..
\end_layout

\begin_layout Standard
This is not entirely true; the operating system does provide certain services
 that any application can avail itself to: reading a file, writing a record
 to a database perhaps, opening a socket, creating a button, a text field.
 Terrific.
 It's a start.
\end_layout

\begin_layout Standard
Again what we see is that the notion of orthogonal services that can be
 provided to all the applications that run in an operating system is missing.
 If the ideas embodied in JMatter were to be applied to an operating system,
 then we could create a virtual world where our software applications would
 suddenly and dramatically shrink in size.
 The reason would be simple: all you'd have to do to build your application
 is define your model objects.
 Half of them would already be defined in other applications and you wouldn't
 be writing them from scratch: you'd be composing applications.
\end_layout

\begin_layout Standard
Contributors to such an operating system might add new and interesting behaviors
 on existing objects.
 Maybe the ability for an email message object to receive an image object,
 maybe the ability to submit your financial information electronically to
 your accountant.
 You'd be able to file email messages in folders that you place on your
 desktop.
 The notion of multiple separate applications would vanish.
 They'd all run under a single application, managed by the operating system.
 When you're performing a search, you'll be searching your entire virtual
 world in the same way, regardless of whether you're looking for a piece
 of text in a file or an email message, or maybe looking for a financial
 transaction in a specific electronic account.
\end_layout

\begin_layout Standard
We wouldn't need such large hard drives, and for many tasks, would not require
 such a fast microprocessor.
 Each application wouldn't request of the operating system a chunk of 50
 megabytes to run in; your memory footprint would drop.
\end_layout

\begin_layout Standard
When you perform a software update, you'll be inheriting new orthogonal
 services: new capabilities that all of your objects would inherit, not
 just a single application.
\end_layout

\begin_layout Standard
This is my vision for operating systems.
 It turns out these ideas are indeed very old ones.
 What I'm describing, to a certain extent, is Smalltalk.
\end_layout

\begin_layout Standard
Indeed the ideas behind JMatter were inspired by the NakedObjects framework,
 which in turn was inspired by Smalltalk.
\end_layout

\begin_layout Section
Collapsing the desktops
\end_layout

\begin_layout Standard
So, my hope is that some day a single desktop will exist and the ideas in
 JMatter will be integrated into our operating systems.
 Until then, enjoy smashing your competition to bits with JMatter.
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "Mat&Paw"

\end_inset

Richard Pawson and Robert Matthews.
 
\emph on
Naked Objects
\emph default
.
 Wiley; 1st edition (November 2002).
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "Raskin"

\end_inset

Jef Raskin.
 
\emph on
The Humane Interface: New Directions for Designing Interactive Systems
\emph default
.
 Addison-Wesley Professional; 1st edition (March 29, 2000).
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "Lewis"

\end_inset

Simon Lewis.
 
\emph on
The Art and Science of Smalltalk.

\emph default
 Prentice Hall; 1st edition (May 11, 1995).
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
label "4"
key "GoF"

\end_inset

Gamma, Helm, Johnson, Vlissides.
 
\emph on
Design Patterns
\emph default
.
 Addison-Wesley (1995).
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
label "5"
key "Evans"

\end_inset

Eric Evans.
 
\emph on
Domain Driven Design
\emph default
.
 Addison-Wesley (2004).
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
label "6"
key "Jasper"

\end_inset

David R.
 Heffelfinger.
 
\emph on
JasperReports for Java Developers.

\emph default
 PackT Publishing (2006).
\end_layout

\end_body
\end_document
